<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[唐巧的技术博客]]></title>
  <subtitle><![CDATA[记录下自己学习的点滴]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2016-03-20T14:54:34.000Z</updated>
  <id>http://blog.devtang.com/</id>
  
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[如何实现自己没实现过的需求之文本动画]]></title>
    <link href="http://blog.devtang.com/2016/03/20/text-animation-guide/"/>
    <id>http://blog.devtang.com/2016/03/20/text-animation-guide/</id>
    <published>2016-03-20T13:34:23.000Z</published>
    <updated>2016-03-20T14:54:34.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>吕伟（<a href="http://weibo.com/u/1660258615" target="_blank" rel="external">@我在罪恶坑的日子</a>）iOS 开发者，这些年在上海工作。专业：扯淡，兼职：开发。<br>感谢投稿，<a href="http://www.ismash.cn/post/ru-he-shi-xian-zi-ji-mei-shi-xian-guo-de-xu-qiu-zhi-wen-ben-dong-hua-pian" target="_blank" rel="external">原文链接</a>。</p>
</blockquote>
<p>大家好，我是非知名程序员，想跟大家说一段传统相声节目，额，对不起，说错了。想跟大家分享一点关于文本和动画的东西。这不是一篇纯血统，高、精、尖的技术文章，但依然希望有人能像喜欢混血美女一样喜欢。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>记得以前看到过一个很赞的文字效果的动画，类似于这样：</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13845905/1e55a5d0-ec7e-11e5-9631-68aaf6b07ba1.gif" alt="textanimation"></p>
<p>当时被惊艳到了，最近偶然间又再次见到，依然还是那么喜欢。假设我们现在需要实现这样的需求。一般碰到需求我们都会去 GitHub 上看看，俗称找轮子（GitHub 基本上只有你想不到的，就没有它没有的）。大多数情况下，没有问题。或者说有点小问题：轮子太多，无从下嘴。</p>
<h2 id="u9009_u62E9"><a href="#u9009_u62E9" class="headerlink" title="选择"></a>选择</h2><blockquote>
<p>选轮子就像选姑娘，你不知道后面等着你的是什么 —–罪恶坑小程如是说</p>
</blockquote>
<p>程序员江湖，每位大侠的武功和套路不尽一样，少林，武当，昆仑各门各派，百花争艳。实现轮子的思路自然也不一样。有的轮子高深晦涩难懂，功能强大，有的清晰明了，功能简单。不过有一点相同是，选错了就会被坑，只是坑大坑小问题。选轮子自然需要无比谨慎，既要匹配需求同时也要能在掉坑里的时候填上（废话，出 bug 了，你不填，谁填），要能 hold 住。然而填坑哪能那么简单呢，首先轮子实现思路，代码的结构，运行时序你要搞清楚吧，提供了哪些功能，没提供哪些功能，你要了解吧。基本上一个复杂点的轮子，研究下来就要好些时间了。这还不包括你开会，沟通，解 bug，喝茶，倒水，上厕所，抽烟，骂娘，吐槽产品需求的时间。所以，妹子们，不要问我们今天加不加班，要问今天能不能在你睡前下班。（项目快上线了，小程不加班谁加班。嗯哼。）</p>
<h2 id="u521B_u9020"><a href="#u521B_u9020" class="headerlink" title="创造"></a>创造</h2><blockquote>
<p>如果能用代码扮演上帝话，苍老师的量产不是问题，就看产品经理定的需求是拟物还是扁平。—-罪恶坑小程如是说</p>
</blockquote>
<p>既然选轮子的时间成本也不低，那有时候我们可以自己造一个轮子。其实写一个的好处也多，有成就感，写好了可以吹牛逼，写坏了填坑速度快。但问题是，以前没写过怎么办？没把握怎么办？比如我们现在需要实现上面的文字效果，但是又不知道怎么写，怎么办？</p>
<p>没关系，上帝创造世间也分了七步走，跟着这位带头大哥后面学，总不会错的。</p>
<h2 id="u5F00_u59CB"><a href="#u5F00_u59CB" class="headerlink" title="开始"></a>开始</h2><blockquote>
<p>罗马不是一天建成的，毛片不是一次性拍完的 —-罪恶坑小程如是说 </p>
</blockquote>
<p>咦，好像扯得有点多了。对不起，现在开始正式拍（苍老师准备下，小程也准备下，Action）：</p>
<h4 id="1-__u5206_u89E3_u4EFB_u52A1"><a href="#1-__u5206_u89E3_u4EFB_u52A1" class="headerlink" title="1.  分解任务"></a>1. <strong> 分解任务 </strong></h4><p>通过简单观察我们可以马上知道，上面那个动画效果是通过对每个字符做动画完成的。而在 iOS 里，文本显示控件最常见和常用的是 UILabel。而 iOS 的 Explicit Animation 有 Properties Animation 和 keyframe Animation 两种。</p>
<p>但是 UILabel 控件没有提供对其 Text 中每个字符的控制的功能，我们需要改造下。既然要对每个字符做动画，那少不了需要<code>frame</code>，<code>bounds</code>，<code>position</code>，<code>transform</code>，这些属性。<br>这样看来我们需要两个武器：一个做排版功能的 framework，不用说，肯定是 <a href="http://objccn.io/issue-5-1/" target="_blank" rel="external">TextKit</a>。而另一个是能显示单个字符也拥有<code>frame</code>，<code>bounds</code>，<code>position</code>，<code>transform</code>等属性的类，很自然，我们想到<code>CATextLayer</code>。</p>
<h4 id="2-__u5148_u89E3_u51B3_u6587_u672C_u5E03_u5C40"><a href="#2-__u5148_u89E3_u51B3_u6587_u672C_u5E03_u5C40" class="headerlink" title="2.  先解决文本布局"></a>2. <strong> 先解决文本布局 </strong></h4><p>TextKit 里主要是三个类 <code>NSTextStorage</code>，<code>NSLayoutManager</code>，<code>NSContainer</code>。它们一起帮组我们解决文字布局，排版的工作。</p>
<ul>
<li><p><strong>NSTextStorage</strong>：<code>NSMutableAttributedString</code>的子类，持有文字内容，当字符发生改变时，通知<code>NSLayoutManager</code>对象</p>
</li>
<li><p><strong>NSLayoutManager</strong>: 我们的男主角，从<code>NSTextStorage</code>里获取文字内容后，转换成对应的 glyph，根据<code>NSTextContainer</code>的 visible Region 显示 glyph。</p>
</li>
<li><p><strong>NSContainer</strong>: 确定一个 region 来放置 text。这个 region 被<code>NSLayoutManager</code>用来决定哪里可以 break lines</p>
</li>
</ul>
<p>不过可惜 UILabel 没有这三个类作为自己的属性对象，我们需要自己解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TextAnimationLabel: UILabel,NSLayoutManagerDelegate &#123;   &#10;     let textStorage:NSTextStorage = NSTextStorage(string: &#34;&#34;)&#10;     let textLayoutManager:NSLayoutManager = NSLayoutManager()&#10;     let textContainer:NSTextContainer = NSTextContainer()&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>除此以外我们还需要两个 Array 用来保存文本变换前的旧字符和变换后的新字符:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var oldCharacterTextLayers:[CATextLayer] = [] &#10;var newCharacterTextLayers:[CATextLayer] = []</span><br></pre></td></tr></table></figure>
<p>因为我们需要用我们自己的 textStorage 对象，所以我们需要覆盖 text 和 attributedText 等属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override var text:String!&#123;&#10;    get &#123;&#10;        return super.text&#10;    &#125;&#10;    set &#123;&#10;        super.text = text&#10;        let attributedText = NSMutableAttributedString(string: newValue)&#10;        let textRange = NSMakeRange(0,newValue.characters.count)&#10;        attributedText.setAttributes([NSForegroundColorAttributeName:self.textColor], range: textRange)&#10;        attributedText.setAttributes([NSFontAttributeName:self.font], range: textRange)&#10;        let paragraphyStyle = NSMutableParagraphStyle()&#10;        paragraphyStyle.alignment = self.textAlignment&#10;        attributedText.addAttributes([NSParagraphStyleAttributeName:paragraphyStyle], range: textRange)&#10;        self.attributedText = attributedText&#10;        &#125;&#10;        &#10; &#125;&#10;    &#10;override var attributedText:NSAttributedString!&#123;&#10;    get &#123;&#10;        return self.textStorage as NSAttributedString&#10;    &#125;&#10;    set&#123;&#10;        cleanOutOldCharacterTextLayers()&#10;        oldCharacterTextLayers = Array(newCharacterTextLayers)&#10;        textStorage.setAttributedString(newValue)&#10;        self.startAnimation &#123; () -&#62; () in&#10;        &#125;&#10;            self.endAnimation(nil)&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当 TextStorage 的文本内容改变时，会触发一个通知 send textLayoutManager 以便重新布局排版。显然我们可以在排版布局完成后来为每个字符创建设置一个 CATextLayer，并设置相应的 frame 以便正确的显示内容。我们可以有个函数来完成计算。并且 layout finish 完成时调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Mark:NSLayoutMangerDelegate&#10;func layoutManager(layoutManager: NSLayoutManager, didCompleteLayoutForTextContainer textContainer: NSTextContainer?, atEnd layoutFinishedFlag: Bool) &#123;&#10;        calculateTextLayers()&#10;        print(&#34;\(textStorage.string)&#34;)&#10;&#125;&#10;    &#10;    &#10;//MARK:CalculateTextLayer&#10;func calculateTextLayers()&#10;&#123;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们的主要想法，是找到 text 里每个 character 以及对应的 glyph rect. 然后用 character 和 glyph rect 创建 CATextLayer</p>
<p>首先我们要有一个空数组用来存放新的 CATextLayer。并且获取 textStorage 的 attributedText。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func calculateTextLayers()&#10;&#123;&#10;    newCharacterTextLayers.removeAll(keepCapacity:false)&#10;    let attributedText = textStorage.string&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们要通过 LayoutManger 找到 TextContainer 的 used Rect，这样方便我们可以让文本垂直居中，就像普通的 Label 那样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func calculateTextLayers()&#10;&#123;&#10;    newCharacterTextLayers.removeAll(keepCapacity:false)&#10;    let attributedText = textStorage.string&#10;    let wordRange = NSMakeRange(0, attributedText.characters.count)&#10;    let attributedString = self.internalAttributedText();&#10;    let layoutRect = textLayoutManager.usedRectForTextContainer(textContainer)&#10;    var index = wordRange.location&#10;    let totalLength = NSMaxRange(wordRange)&#10;    while index &#60; totalLength &#123;&#10;         ...&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们开始迭代处理文本里的每个字符，创建一个 glyphRange 并且用这个 glyphRange 找到对应的 character，然后我们将 glyph index 丢给 LayoutManager 得到 textContainer，再用 container 和 glyphRange 取得 glyphRect(这里需要注意下 kerning 的问题)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let glyphRange = NSMakeRange(index, 1)&#10;let characterRange = textLayoutManager.characterRangeForGlyphRange(glyphRange, actualGlyphRange: nil)&#10;let textContainer = textLayoutManager.textContainerForGlyphAtIndex(index, effectiveRange: nil)&#10;var glyphRect = textLayoutManager.boundingRectForGlyphRange(glyphRange, inTextContainer: textContainer!)</span><br></pre></td></tr></table></figure>
<p>最终我们还需要注意的就是 glyph 的 kerning，如果 <code>kerningRange.location == index</code>，我们需要将前一个 textLayer 取出来调整其 Rect 的宽度至新的 glyphRect 的最右边，保证 glyph 不会被裁切掉（可以对比下面两张图片）</p>
<p><img width="122" src="https://cloud.githubusercontent.com/assets/3759810/13854816/4a6b5258-eca8-11e5-9870-15ed2d4f0d70.png"></p>
<p><img width="122" src="https://cloud.githubusercontent.com/assets/3759810/13854821/4c5b947e-eca8-11e5-811e-e9abb161345f.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let kerningRange = textLayoutManager.rangeOfNominallySpacedGlyphsContainingIndex(index)&#10;if kerningRange.location == index &#38;&#38; kerningRange.length &#62; 1 &#123;&#10;    if newCharacterTextLayers.count &#62; 0 &#123;&#10;        // &#22914;&#26524;&#21069;&#19968;&#20010; textlayer &#30340; frame.size.width &#19981;&#21464;&#22823;&#30340;&#35805;&#65292;&#10;        // &#24403;&#21069;&#30340; textLayer &#20250;&#36974;&#25377;&#20303;&#23383;&#20307;&#30340;&#19968;&#37096;&#20998;&#65292;&#27604;&#22914; &#8220;Yes&#8221; &#30340; Y &#21491;&#19978;&#35282;&#20250;&#34987;&#20999;&#25481;&#19968;&#37096;&#20998;&#10;        let previousLayer = newCharacterTextLayers[newCharacterTextLayers.endIndex - 1]&#10;        var frame = previousLayer.frame&#10;        frame.size.width += CGRectGetMaxX(glyphRect) - CGRectGetMaxX(frame)&#10;        previousLayer.frame = frame&#10;     &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里关于 kerning 和 glyph 要多说一点。先来说下 glyph，简单来说 glyph 是表示一个 character 的具体样式 , 但他们却不是一一对应的关系，比如一个字母 “A” 可以有不同的写法来表示例如：</p>
<p><img width="417" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878224/e142bef8-ed4a-11e5-9c84-798cb5939f36.png"></p>
<p>除此以外，还有这种情况：</p>
<p><img width="243" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878392/fab15e02-ed4b-11e5-9d38-2dc00ed45b0b.png"></p>
<p>上面是的 “ff” 虽然是两个 character，但是 glyph 却是一个。<br>不过不用担心，强大 LayoutManager 提供了两个方法帮助我们通过一个找到对应另外那个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func characterIndexForGlyphAtIndex(_ glyphIndex: Int) -&#62; Int&#10;func glyphIndexForCharacterAtIndex(_ charIndex: Int) -&#62; Int</span><br></pre></td></tr></table></figure>
<p>现在我们说下 kerning。通常，在水平排布的文本中，glyph 都是一个挨着一个放置的，但是在某些时候为了让文本的可读性更好，看上去更加优雅美观，一个字形和另外一个字形之间可能会稍微的错位下，比如下面这种情况：</p>
<p><img width="601" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878767/7631a33c-ed4e-11e5-9d03-46d89d8af9c8.png"><br>这也是上面为什么”Y“会出现显示不全的原因了。</p>
<p>接下来就比较简单了，创建 Textlayer, 设置垂直居中，添加到数组当中，<code>index += characterRange.length</code>，开始下次循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glyphRect.origin.y += (self.bounds.size.height/2)-(layoutRect.size.height/2)&#10;let textLayer = CATextLayer(frame: glyphRect, string: attributedString.attributedSubstringFromRange(characterRange));&#10;layer.addSublayer(textLayer);&#10;newCharacterTextLayers.append(textLayer);&#10;index += characterRange.length</span><br></pre></td></tr></table></figure>
<h4 id="3-__u52A8_u753B_u5B9E_u73B0"><a href="#3-__u52A8_u753B_u5B9E_u73B0" class="headerlink" title="3.  动画实现"></a>3. <strong> 动画实现 </strong></h4><p>上面我们解决了字符排版的问题，接下来动画的实现就相对的容易了，仔细观察那个动画，很容易得出主要是对 <code>opacity</code> 和 <code>transform</code> 两个属性做属性动画，<code>opacity</code> 让每个字体逐渐显示和逐渐消失，而 <code>transform</code>则做了两种变形，一种是往下移动，另外一种是旋转。用 <code>CABasicAnimation</code> 可以解决单个属性动画，而 <code>CAAnimationGroup</code> 则帮我们解决多个动画叠加的复合效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func groupAnimationWithLayerChanges(old olderLayer:CALayer, new newLayer:CALayer) &#10;     -&#62; CAAnimationGroup? &#123;&#10;&#10;    var animationGroup:CAAnimationGroup?&#10;    var animations:[CABasicAnimation] = [CABasicAnimation]()&#10;&#10;    if !CATransform3DEqualToTransform(olderLayer.transform,&#10;    newLayer.transform) &#123;&#10;         let basicAnimation = CABasicAnimation(keyPath: &#34;transform&#34;)&#10;         basicAnimation.fromValue = NSValue(CATransform3D: olderLayer.transform)&#10;         basicAnimation.toValue = NSValue(CATransform3D: newLayer.transform)&#10;         animations.append(basicAnimation)&#10;         &#125;&#10;&#10;    if olderLayer.opacity != newLayer.opacity &#123;&#10;       let basicAnimation = CABasicAnimation(keyPath: &#34;opacity&#34;)&#10;       basicAnimation.fromValue = olderLayer.opacity&#10;       basicAnimation.toValue = newLayer.opacity&#10;       animations.append(basicAnimation)&#10;       &#125;&#10;&#10;    if animations.count &#62; 0 &#123;&#10;       animationGroup = CAAnimationGroup()&#10;       animationGroup!.animations = animations&#10;   &#125;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一个问题，就是隐式动画的问题，Core Animation 基于一个假说，就是屏幕上的任何东西都可以 (或者可能) 做动画，我们平时在写代码时应该有这种印象就是你只是 layer 设置了一个值，没有添加动画，但是你会看到一个平滑过渡的显示效果而不是非常突兀的变化。这就是隐式动画。当我们改变一个属性时，Core Animation 帮我们做了一个动画，动画时间取决于当前 NSTransaction 的设置，而动画类型取决于图层行为。</p>
<p>这里有个有趣的东西，多说一点，就是当我们对 UIView 关联的图层做动画而不是一个单独的图层做动画，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func changeColor()&#10;&#123;&#10;    CATransaction.begin();&#10;    CATransaction.setAnimationDuration(1.0)&#10;    CGFloat red = CGFloat(arc4random() / (CGFloat)INT_MAX);&#10;    CGFloat green = CGFloat(arc4random() / (CGFloat)INT_MAX);&#10;    CGFloat blue = CGFloat(arc4random() / (CGFloat)INT_MAX);&#10;    self.layerView.layer.backgroundColor = UIColor.(colorWithRed:red green:green blue:blue alpha:1.0).CGColor;&#10;    CATransaction.commit();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>图层的颜色瞬间切换到新的值，而不是之前的平滑过渡，隐式动画似乎给关闭了。<br>我们知道 UIView 和 CALayer 最重要的关系就是 UIView 是 CALayer 的 delegate，<br>当我们改变 CALayer 的属性时，它会调用 <code>func actionForKey(_ event: String) -&gt; CAAction?</code> </p>
<p>这个方法，接下来发生的事情在官方文档里都有写，实际上是如下几步:</p>
<ul>
<li><p><em>If the layer has a delegate that implements the actionForLayer:forKey: method, the layer calls that method. The delegate must do one of the following:</em></p>
<ol>
<li><p>Return the action object for the given key.</p>
</li>
<li><p>Return the NSNull object if it does not handle the action.</p>
</li>
</ol>
</li>
<li><p><em>The layer looks in the layer’s actions dictionary for a matching key/action pair.</em></p>
</li>
<li><em>The layer looks in the style dictionary for an actions dictionary for a matching key/action pair.</em></li>
<li><em>The layer calls the defaultActionForKey: class method to look for any class-defined actions.</em></li>
</ul>
<p>UIView 作为它关联图层的 Delegate，实现了 <code>actionForLayer(_ layer: CALayer, forKey event: String) -&gt; CAAction?</code> ，当不在一个动画块中，UIView 返回 nil，而在动画块中则返回一个非空值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#34;OutSide:\(self.view.actionForLayer(self.view.layer, forKey: &#34;backgroundColor&#34;))&#34;)&#10;UIView.beginAnimations(nil, context: nil)&#10;print(&#34;InSide:\(self.view.actionForLayer(self.view.layer,&#10;forKey: &#34;backgroundColor&#34;))&#34;)&#10;UIView.commitAnimations()</span><br></pre></td></tr></table></figure>
<p>显示结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OutSide:Optional(&#60;null&#62;)&#10;InSide:Optional(&#60;CABasicAnimation: 0x7f7f93ff81b0&#62;)</span><br></pre></td></tr></table></figure>
<p>当然返回 nil 并不是禁用隐式动画的唯一方法，下面这样也行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CATransaction.setDisableActions(true)</span><br></pre></td></tr></table></figure>
<p>那为什么说这个问题呢？因为我们在对每个字符做动画的时候需要先将隐式动画关闭，否者将会做两次动画，比如下面这样:</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13857496/2443d70a-ecb5-11e5-8661-a499e9c8719d.gif" alt="closeimplicitanimation"></p>
<p>那么，我们先生成一份 oldlayer, 然后改变相应的属性，生产新的 newLayer。然后创建相应的动画组，添加显式动画。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let olderLayer = animationObjc.animatableLayerCopy(layer)&#10;CATransaction.begin()&#10;CATransaction.setDisableActions(true)&#10;newLayer = effectAnimationClosure(layer: layer)&#10;CATransaction.commit()&#10;var animationGroup:CAAnimationGroup?&#10;animationGroup = groupAnimationWithLayerChanges(old: olderLayer, new: newLayer!)&#10;layer.addAnimation(textAniamtionGroup, forKey: textAnimationGroupKey)</span><br></pre></td></tr></table></figure>
<h2 id="u6536_u5DE5"><a href="#u6536_u5DE5" class="headerlink" title="收工"></a>收工</h2><p>好了，当上面所有的工作完成之后，就是我们最开始看到的那个效果，代码已经上传 GitHub，你可以从 <a href="https://github.com/morpheus1984/TextKitAndAnimationEffect.git" target="_blank" rel="external">这里</a> 下载。其实这个 demo 里实现的 label 还有很大优化的空间。比如支持多种类型的动画效果，动画效果可配置等等。这是我接下来打算做的事情。<br>本人才疏学浅，错漏难免，欢迎大家批评指正。如果你发现 bug，可以提个 pull request。如果你有更好地思路也请告诉我，让我进步，我请你喝咖啡 ：）。</p>
<p>这是我的微信号（未完结，请往下看）：</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13864468/9fdcae9c-ecdc-11e5-9c49-278b327d1ba7.png" alt="wechat"></p>
<h2 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h2><p>不知不觉工作许多年了，这几年萝莉变成了姑娘，姑娘变成了孩子妈。大家从 QQ 空间杀到朋友圈。从晒女朋友，到晒结婚照继而到晒娃。这几年鸣人同志都不负众望当上了火影 (丫也不请吃饭)。大家都在发生变化。</p>
<p>学会开始写点东西分享可能是我想要的一个变化。</p>
<p>本来作为非知名程序员，平时都是自己上 GitHub 玩，自认为比起一干牛人既没本领可以提振民心士气，又没有独门绝技可以分享。直到我收到了一封来自组织的信。</p>
<p>最近我加入了一个公会，里面云集了各类高手，轻功，内力，暗器，大家各有所长，时不时分享下自己的看家本领。还是那句老话，不看不知道，一看吓一跳。世界还是外面的大，姑娘还是城里的靓。在群里，大家都很积极活跃，学习氛围异常的好。其实自打做起程序员起，这么多年来，虽然生性慵懒，但是自学却未敢放下，毕竟逆水行舟，不进则退。不可否认的是一个人的学习是很苦闷无聊的，但一群人陪着你一起苦闷无聊也是很欣慰的。</p>
<p>最后我想引用那封邮件里面的话来表达下我对公会的看法:</p>
<blockquote>
<p>这个社群的意义证明了，在互联网时代，依然有这么多人愿意为知识的积累和个人的成长付费，知识本身的价值得到重新的认知，人们以一种去中心化的方式连接起来，P2P 的创作和分享，可能会让知识和技能的积累、传播达到了一种新的高度、深度和广度</p>
</blockquote>
<p>我想一贯懒散的我为何突然想写这么个 blog 可能也是因为这个，毕竟知识的受益者永远是那些积极参与学习并持续思考的人。</p>
<p>额，最后想说的是，是的，那段引用的文字你没看错，这是个需要付费的群，免费时代的付费群，它叫 <a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=402078207&amp;idx=1&amp;sn=c0b437784c7fc789e06767eedf5cdf87&amp;scene=18#wechat_redirect" target="_blank" rel="external">攻城狮之路</a>。</p>
<p>知识是很昂贵的，我一直这么认为。另外，其实这是篇硬广。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>吕伟（<a href="http://weibo.com/u/1660258615" target="_blank" rel="external">@我在罪恶坑的日子</a>）iOS 开发者，这些年在上海工作。专业：扯淡，兼职：开发。<br>感谢投]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="投稿" scheme="http://blog.devtang.com/tags/%E6%8A%95%E7%A8%BF/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 视图控制器转场详解]]></title>
    <link href="http://blog.devtang.com/2016/03/13/iOS-transition-guide/"/>
    <id>http://blog.devtang.com/2016/03/13/iOS-transition-guide/</id>
    <published>2016-03-13T08:15:47.000Z</published>
    <updated>2016-03-19T13:54:01.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：<a href="http://weibo.com/u/1815689155" target="_blank" rel="external">seedante</a>，神秘人士，他的 <a href="https://github.com/seedante" target="_blank" rel="external">GitHub</a>。<br>感谢投稿，<a href="https://github.com/seedante/iOS-Note/wiki/ViewController-Transition" target="_blank" rel="external">原文链接</a>。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>屏幕左边缘右滑返回，TabBar 滑动切换，你是否喜欢并十分依赖这两个操作，甚至觉得 App 不支持这类操作的话简直反人类？这两个操作在大屏时代极大提升了操作效率，其背后的技术便是今天的主题：视图控制器转换(View Controller Transition)。</p>
<p>视图控制器中的视图显示在屏幕上有两种方式：最主要的方式是内嵌在容器控制器中，比如 UINavigationController，UITabBarController, UISplitController；由另外一个视图控制器显示它，这种方式通常被称为模态(Modal)显示。View Controller Transition 是什么？在 NavigationController 里 push 或 pop 一个 View Controller，在 TabBarController 中切换到其他 View Controller，以 Modal 方式显示另外一个 View Controller，这些都是 View Controller Transition。在 storyboard 里，每个 View Controller 是一个 Scene，View Controller Transition 便是从一个 Scene 转换到另外一个 Scene；为方便，以下对 View Controller Transition 的中文称呼采用 Objccn.io 中的翻译「转场」。</p>
<p>在 iOS 7 之前，我们只能使用系统提供的转场效果，大部分时候够用，但仅仅是够用而已，总归会有各种不如意的小地方，但我们却无力改变；iOS 7 开放了相关 API 允许我们对转场效果进行全面定制，这太棒了，自定义转场动画以及对交互手段的支持带来了无限可能。</p>
<p>本文并非华丽的转场动画教程，相反，文中的转场动画效果都十分简单，但本文的内容并不简单，我将带你探索转场背后的机制，缺陷以及实现过程中的技巧与陷阱。阅读本文需要读者至少要对 ViewController 和 View 的结构以及协议有基本的了解，最好自己亲手实现过一两种转场动画。如果你对此感觉没有信心，推荐观看官方文档：<a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1" target="_blank" rel="external">View Controller Programming Guide for iOS</a>，学习此文档将会让你更容易理解本文的内容。对你想学习的小节，我希望你自己亲手写下这些代码，一步步地看着效果是如何实现的，至少对我而言，看各种相关资料时只有字面意义上的理解，正是一步步的试验才能让我理解每一个步骤。本文涉及的内容较多，为了避免篇幅过长，我只给出关键代码而不是从新建工程开始教你每一个步骤。本文基于 Xcode 7 以及 Swift 2，Demo 合集地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo.git" target="_blank" rel="external">iOS-ViewController-Transition-Demo</a>。</p>
<h2 id="Chapter1">Transition 解释</h2>

<p>前言里从行为上解释了转场，那在转场时发生了什么？下图是从 WWDC 2013 Session 218 整理的，解释了转场时视图控制器和其对应的视图在结构上的变化：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/The%20Anatomy%20of%20Transition.png?raw=true" alt="The Anatomy of Transition"></p>
<p>转场过程中，作为容器的父 VC 维护着多个子 VC，但在视图结构上，只保留一个子 VC 的视图，所以转场的本质是下一场景(子 VC)的视图替换当前场景(子 VC)的视图以及相应的控制器(子 VC)的替换，表现为当前视图消失和下一视图出现，基于此进行动画，动画的方式非常多，所以限制最终呈现的效果就只有你的想象力了。图中的 Parent VC 可替换为 UIViewController, UITabbarController 或 UINavigationController 中的任何一种。</p>
<p>目前为止，官方支持以下几种方式的自定义转场：</p>
<ol>
<li>在 UINavigationController 中 push 和 pop;</li>
<li>在 UITabBarController 中切换 Tab;</li>
<li>Modal 转场：presentation 和 dismissal，俗称视图控制器的模态显示和消失，仅限于<code>modalPresentationStyle</code>属性为 UIModalPresentationFullScreen 或 UIModalPresentationCustom 这两种模式;</li>
<li>UICollectionViewController 的布局转场：UICollectionViewController 与 UINavigationController 结合的转场方式，实现很简单。</li>
</ol>
<p>官方的支持包含了 iOS 中的大部分转场方式，还有一种自定义容器中的转场并没有得到系统的直接支持，不过借助协议这种灵活的方式，我们依然能够实现对自定义容器控制器转场的定制，在压轴环节我们将实现这一点。</p>
<p>iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，非常灵活。转场协议由5种协议组成，在实际中只需要我们提供其中的两个或三个便能实现绝大部分的转场动画：</p>
<p>1.<strong>转场代理(Transition Delegate)：</strong></p>
<p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。有如下三种转场代理，对应上面三种类型的转场：</p>
<pre><code>&lt;UINavigationControllerDelegate&gt; //UINavigationController 的 delegate 属性遵守该协议。
&lt;UITabBarControllerDelegate&gt; //UITabBarController 的 delegate 属性遵守该协议。
&lt;UIViewControllerTransitioningDelegate&gt; //UIViewController 的 transitioningDelegate 属性遵守该协议。
</code></pre><p>这里除了<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerTransitioningDelegate_protocol/index.html#//apple_ref/doc/uid/TP40013060" target="_blank" rel="external"><code>&lt;UIViewControllerTransitioningDelegate&gt;</code></a>是 iOS 7 新增的协议，其他两种在 iOS 2 里就存在了，在 iOS 7 时扩充了这两种协议来支持自定义转场。</p>
<p>转场发生时，UIKit 将要求转场代理将提供转场动画的核心构件：动画控制器和交互控制器(可选的)；由我们实现。</p>
<p>2.<strong>动画控制器(Animation Controller)：</strong></p>
<p>最重要的部分，负责添加视图以及执行动画；遵守<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerAnimatedTransitioning_Protocol/index.html#//apple_ref/doc/uid/TP40013387" target="_blank" rel="external"><code>&lt;UIViewControllerAnimatedTransitioning&gt;</code></a>协议；由我们实现。</p>
<p>3.<strong>交互控制器(Interaction Controller)：</strong></p>
<p>通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerInteractiveTransitioning_protocol/index.html#//apple_ref/doc/uid/TP40013059" target="_blank" rel="external"><code>&lt;UIViewControllerInteractiveTransitioning&gt;</code></a>协议；系统已经打包好现成的类供我们使用。</p>
<p>4.<strong>转场环境(Transition Context):</strong></p>
<p>提供转场中需要的数据；遵守<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerContextTransitioning_protocol/index.html#//apple_ref/doc/uid/TP40013057" target="_blank" rel="external"><code>&lt;UIViewControllerContextTransitioning&gt;</code></a>协议；由 UIKit 在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。</p>
<p>5.<strong>转场协调器(Transition Coordinator)：</strong></p>
<p>可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerTransitionCoordinator_Protocol/index.html#//apple_ref/doc/uid/TP40013295" target="_blank" rel="external"><code>&lt;UIViewControllerTransitionCoordinator&gt;</code></a>协议；由 UIKit 在转场时生成，UIViewController 在 iOS 7 中新增了方法<code>transitionCoordinator()</code>返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。</p>
<p>总结下，5个协议只需要我们操心3个；实现一个最低限度可用的转场动画，我们只需要提供上面五个组件里的两个：转场代理和动画控制器即可，还有一个转场环境是必需的，不过这由系统提供；当进一步实现交互转场时，还需要我们提供交互控制器，也有现成的类供我们使用。</p>
<h2 id="Chapter2">阶段一：非交互转场</h2>

<p>这个阶段要做两件事，提供转场代理并由代理提供动画控制器。在转场代理协议里动画控制器和交互控制器都是可选实现的，没有实现或者返回 nil 的话则使用默认的转场效果。动画控制器是表现转场效果的核心部分，代理部分非常简单，我们先搞定动画控制器吧。</p>
<h3 id="Chapter2.1">动画控制器协议</h3>

<p>动画控制器负责添加视图以及执行动画，遵守<code>UIViewControllerAnimatedTransitioning</code>协议，该协议要求实现以下方法：</p>
<pre><code>//执行动画的地方，最核心的方法。
(Required)func animateTransition(_ transitionContext: UIViewControllerContextTransitioning)
//返回动画时间，&quot;return 0.5&quot; 已足够，非常简单，出于篇幅考虑不贴出这个方法的代码实现。
(Required)func transitionDuration(_ transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval
//如果实现了，会在转场动画结束后调用，可以执行一些收尾工作。
(Optional)func animationEnded(_ transitionCompleted: Bool)
</code></pre><p>最重要的是第一个方法，该方法接受一个遵守<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议的转场环境对象，上一节的 API 解释里提到这个协议，它提供了转场所需要的重要数据：参与转场的视图控制器和转场过程的状态信息。</p>
<p>UIKit 在转场开始前生成遵守转场环境协议<code>&lt;UIViewControllerContextTransitioning&gt;</code>的对象 transitionContext，它有以下几个方法来提供动画控制器需要的信息：</p>
<pre><code>//返回容器视图，转场动画发生的地方。
func containerView() -&gt; UIView?
//获取参与转场的视图控制器，有 UITransitionContextFromViewControllerKey 和 UITransitionContextToViewControllerKey 两个 Key。 
func viewControllerForKey(_ key: String) -&gt; UIViewController?
//iOS 8新增 API 用于方便获取参与参与转场的视图，有 UITransitionContextFromViewKey 和 UITransitionContextToViewKey 两个 Key。
func viewForKey(_ key: String) -&gt; UIView? AVAILABLE_IOS(8_0)
</code></pre><p>通过<code>viewForKey:</code>获取的视图是<code>viewControllerForKey:</code>返回的控制器的根视图，或者 nil。<code>viewForKey:</code>方法返回 nil 只有一种情况： UIModalPresentationCustom 模式下的 Modal 转场 ，通过此方法获取 presentingView 时得到的将是 nil，在后面的 Modal 转场里会详细解释。</p>
<p>前面提到转场的本质是下一个场景的视图替换当前场景的视图，从当前场景过渡下一个场景。下面称即将消失的场景的视图为 fromView，对应的视图控制器为 fromVC，即将出现的视图为 toView，对应的视图控制器称之为 toVC。几种转场方式的转场操作都是可逆的，一种操作里的 fromView 和 toView 在逆向操作里的角色互换成对方，fromVC 和 toVC 也是如此。<strong>在动画控制器里，参与转场的视图只有 fromView 和 toView 之分，与转场方式无关。转场动画的最终效果只限制于你的想象力。</strong>这也是动画控制器在封装后可以被第三方使用的重要原因。</p>
<p>在 iOS 8 中可通过以下方法来获取参与转场的三个重要视图，在 iOS 7 中则需要通过对应的视图控制器来获取，为避免 API 差异导致代码过长，示例代码中直接使用下面的视图变量：</p>
<pre><code>let containerView = transitionContext.containerView()
let fromView = transitionContext.viewForKey(UITransitionContextFromViewKey)
let toView = transitionContext.viewForKey(UITransitionContextToViewKey)
</code></pre><h3 id="Chapter2.2">动画控制器实现</h3>

<p>转场 API 是协议的好处是不限制具体的类，只要对象实现该协议便能参与转场过程，这也带来另外一个好处：封装便于复用，尽管三大转场代理协议的方法不尽相同，但它们返回的动画控制器遵守的是同一个协议，因此可以将动画控制器封装作为第三方动画控制器在其他控制器的转场过程中使用。</p>
<p>三种转场方式都有一对可逆的转场操作，你可以为了每一种操作实现单独的动画控制器，也可以实现通用的动画控制器。处于篇幅的考虑，本文示范一个比较简单的 Slide 动画控制器：Slide left and right，而且该动画控制器在三种转场方式中是通用的，不必修改就可以直接在工程中使用。效果示意图：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/SlideAnimation.gif?raw=true" alt="SlideAnimation"></p>
<p>在交互式转场章节里我们将在这个基础上实现文章开头提到的两种效果：NavigationController 右滑返回 和 TabBarController 滑动切换。尽管对动画控制器来说，转场方式并不重要，可以对 fromView 和 toView 进行任何动画，但上面的动画和 Modal 转场风格上有点不配，主要动画的方向不对，不过我在这个 Slide 动画控制器里为 Modal 转场适配了和系统的风格类似的竖直移动动画效果；另外 Modal 转场并没有比较合乎操作直觉的交互手段，而且和前面两种容器控制器的转场在机制上有些不同，所以我将为 Modal 转场示范另外一个动画。</p>
<p>在转场中操作是可逆的，返回操作时的动画应该也是逆向的。对此，Slide 动画控制器需要针对转场的操作类型对动画的方向进行调整。Swift 中 enum 的关联值可以视作有限数据类型的集合体，在这种场景下极其合适。设定转场类型：</p>
<pre><code>enum SDETransitionType{
    //UINavigationControllerOperation 是枚举类型，有 None, Push, Pop 三种值。
    case NavigationTransition(UINavigationControllerOperation) 
    case TabTransition(TabOperationDirection)
    case ModalTransition(ModalOperation)
}

enum TabOperationDirection{
    case Left, Right
}

enum ModalOperation{
    case Presentation, Dismissal
}
</code></pre><p>使用示例：在 TabBarController 中切换到左边的页面。</p>
<pre><code>let transitionType = SDETransitionType.TabTransition(.Left)
</code></pre><p>Slide 动画控制器的核心代码：</p>
<pre><code>class SlideAnimationController: NSObject, UIViewControllerAnimatedTransitioning {
    init(type: SDETransitionType) {...}

    func animateTransition(transitionContext: UIViewControllerContextTransitioning) {
        ...
         //1
        containerView.addSubview(toView)

        //计算位移 transform，NavigationVC 和 TabBarVC 在水平方向进行动画，Modal 转场在竖直方向进行动画。
        var toViewTransform = ...
        var fromViewTransform = ...
        toView.transform = toViewTransform

        //根据协议中的方法获取动画的时间。
        let duration = self.transitionDuration(transitionContext)
        UIView.animateWithDuration(duration, animations: {
            fromView.transform = fromViewTransform
            toView.transform = CGAffineTransformIdentity
            }, completion: { _ in
                //考虑到转场中途可能取消的情况，转场结束后，恢复视图状态。
                fromView.transform = CGAffineTransformIdentity
                toView.transform = CGAffineTransformIdentity
                //2
                let isCancelled = transitionContext.transitionWasCancelled()
                transitionContext.completeTransition(!isCancelled)
        })
    }
}
</code></pre><p>注意上面的代码有2处标记，是动画控制器必须完成的：</p>
<ol>
<li>将 toView 添加到容器视图中，使得 toView 在屏幕上显示( Modal 转场中此点稍有不同，下一节细述)；</li>
<li>正确地结束转场过程。转场的结果有两种：完成或取消。非交互转场的结果只有完成一种情况，不过交互式转场需要考虑取消的情况。如何结束取决于转场的进度，通过<code>transitionWasCancelled()</code>方法来获取转场的状态，使用<code>completeTransition:</code>来完成或取消转场。</li>
</ol>
<p>实际上，这里示范的简单的转场动画和那些很复杂的转场动画在转场的部分要做的事情都是上面提到的这两点，它们的区别主要在于动画的部分。</p>
<p>转场结束后，fromView 会从视图结构中移除，UIKit 自动替我们做了这事，你也可以手动处理提前将 fromView 移除，这完全取决于你。<code>UIView</code>的类方法<code>transitionFromView:toView:duration:options:completion:</code>也能做同样的事，使用下面的代码替换上面的代码，甚至不需要获取 containerView 以及手动添加 toView 就能实现一个类似的转场动画：</p>
<pre><code>UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: { _ in
    let isCancelled = transitionContext.transitionWasCancelled()
    transitionContext.completeTransition(!isCancelled)
})
</code></pre><h3 id="Chapter2.3">特殊的 Modal 转场</h3>

<h4 id="Chapter2.3.1">Modal 转场的差异</h4>

<p>Modal 转场中需要做的事情和两种容器 VC 的转场一样，但在细节上有些差异。</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/ContainerVC%20VS%20Modal.png?raw=true" alt="ContainerVC VS Modal"></p>
<p>UINavigationController 和 UITabBarController 这两个容器 VC 的根视图在屏幕上是不可见的(或者说是透明的)，可见的只是内嵌在这两者中的子 VC 中的视图，转场是从子 VC 的视图转换到另外一个子 VC 的视图，其根视图并未参与转场；而 Modal 转场，以 presentation 为例，是从 presentingView 转换到 presentedView，根视图 presentingView 也就是 fromView 参与了转场。而且 NavigationController 和 TabBarController 转场中的 containerView 也并非这两者的根视图。</p>
<p>Modal 转场与两种容器 VC 的转场的另外一个不同是：Modal 转场结束后 presentingView 可能依然可见，UIModalPresentationPageSheet 模式就是这样。这种不同导致了 Modal 转场和容器 VC 的转场对 fromView 的处理差异：容器 VC 的转场结束后 fromView 会被主动移出视图结构，这是可预见的结果，我们也可以在转场结束前手动移除；而 Modal 转场中，presentation 结束后 presentingView(fromView) 并未主动被从视图结构中移除。准确来说，是 UIModalPresentationCustom 这种模式下的 Modal 转场结束时 fromView 并未从视图结构中移除；UIModalPresentationFullScreen 模式的 Modal 转场结束后 fromView 依然主动被从视图结构中移除了。这种差异导致在处理 dismissal 转场的时候很容易出现问题，没有意识到这个不同点的话出错时就会毫无头绪。下面来看看 dismissal 转场时的场景。</p>
<p>ContainerView 在转场期间作为 fromView 和 toView 的父视图。三种转场过程中的 containerView 是 UIView 的私有子类，不过我们并不需要关心 containerView 具体是什么。在 dismissal 转场中：</p>
<ol>
<li>UIModalPresentationFullScreen 模式：presentation 后，presentingView 被主动移出视图结构，在 dismissal 中 presentingView 是 toView 的角色，其将会重新加入 containerView 中，实际上，我们不主动将其加入，UIKit 也会这么做，前面的两种容器控制器的转场里不是这样处理的，不过这个差异基本没什么影响。</li>
<li>UIModalPresentationCustom 模式：转场时 containerView 并不担任 presentingView 的父视图，后者由 UIKit 另行管理。在 presentation 后，fromView(presentingView) 未被移出视图结构，在 dismissal 中，注意不要像其他转场中那样将 toView(presentingView) 加入 containerView 中，否则本来可见的 presentingView 将会被移除出自身所处的视图结构消失不见。如果你在使用 Custom 模式时没有注意到这点，就很容易掉进这个陷阱而很难察觉问题所在，这个问题曾困扰了我一天。</li>
</ol>
<p>对于 Custom 模式，我们可以参照其他转场里的处理规则来打理：presentation 转场结束后主动将 fromView(presentingView) 移出它的视图结构，并用一个变量来维护 presentingView 的父视图，以便在 dismissal 转场中恢复；在 dismissal 转场中，presentingView 的角色由原来的 fromView 切换成了 toView，我们再将其重新恢复它原来的视图结构中。测试表明这样做是可行的。但是这样一来，在实现上，需要在转场代理中维护一个动画控制器并且这个动画控制器要维护 presentingView 的父视图，第三方的动画控制器必须为此改造。显然，这样的代价是无法接受的。</p>
<p><strong>小结</strong>：经过上面的尝试，建议是，不要干涉官方对 Modal 转场的处理，我们去适应它。在 Custom 模式下，由于 presentingView 不受 containerView 管理，在 dismissal 转场中不要像其他的转场那样将 toView(presentingView) 加入 containerView，否则 presentingView 将消失不见，而应用则也很可能假死；而在 presentation 转场中，切记不要手动将 fromView(presentingView) 移出其父视图。</p>
<p>iOS 8 为<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议添加了<code>viewForKey:</code>方法以方便获取 fromView 和 toView，但是在 Modal 转场里要注意，从上面可以知道，Custom 模式下，presentingView 并不受 containerView 管理，这时通过<code>viewForKey:</code>方法来获取 presentingView 得到的是 nil，必须通过<code>viewControllerForKey:</code>得到 presentingVC 后来获取。因此在 Modal 转场中，较稳妥的方法是从 fromVC 和 toVC 中获取 fromView 和 toView。</p>
<p>顺带一提，前面提到的<code>UIView</code>的类方法<code>transitionFromView:toView:duration:options:completion:</code>能在 Custom 模式下工作，却与 FullScreen 模式有点不兼容。</p>
<h4 id="Chapter2.3.2">Modal 转场实践</h4>

<p>UIKit 已经为 Modal 转场实现了多种效果，当 UIViewController 的<code>modalPresentationStyle</code>属性为<code>.Custom</code> 或<code>.FullScreen</code>时，我们就有机会定制转场效果，此时<code>modalTransitionStyle</code>指定的转场动画将会被忽略。</p>
<p>Modal 转场开放自定义功能后最令人感兴趣的是定制 presentedView 的尺寸，下面来我们来实现一个带暗色调背景的小窗口效果。Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CustomModalTransition" target="_blank" rel="external">CustomModalTransition</a>。</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/ModalTransition.gif?raw=true" alt="ModalTransition"></p>
<p>由于需要保持 presentingView 可见，这里的 Modal 转场应该采用 UIModalPresentationCustom 模式，此时 presentedVC 的<code>modalPresentationStyle</code>属性值应设置为<code>.Custom</code>。而且与容器 VC 的转场的代理由容器 VC 自身的代理提供不同，Modal 转场的代理由 presentedVC 提供。动画控制器的核心代码：</p>
<pre><code>class OverlayAnimationController: NSobject, UIViewControllerAnimatedTransitioning{
    ... 
    func animateTransition(transitionContext: UIViewControllerContextTransitioning) {            
        ...
        //不像容器 VC 转场里需要额外的变量来标记操作类型，UIViewController 自身就有方法跟踪 Modal 状态。
        //处理 Presentation 转场：
        if toVC.isBeingPresented(){
            //1
            containerView.addSubview(toView)
            //在 presentedView 后面添加暗背景视图 dimmingView，注意两者在 containerView 中的位置。
            let dimmingView = UIView()
            containerView.insertSubview(dimmingView, belowSubview: toView)

            //设置 presentedView 和 暗背景视图 dimmingView 的初始位置和尺寸。
            let toViewWidth = containerView.frame.width * 2 / 3
            let toViewHeight = containerView.frame.height * 2 / 3
            toView.center = containerView.center
            toView.bounds = CGRect(x: 0, y: 0, width: 1, height: toViewHeight)

            dimmingView.backgroundColor = UIColor(white: 0.0, alpha: 0.5)
            dimmingView.center = containerView.center
            dimmingView.bounds = CGRect(x: 0, y: 0, width: toViewWidth, height: toViewHeight)

            //实现出现时的尺寸变化的动画：
            UIView.animateWithDuration(duration, delay: 0, options: .CurveEaseInOut, animations: {
                toView.bounds = CGRect(x: 0, y: 0, width: toViewWidth, height: toViewHeight)
                dimmingView.bounds = containerView.bounds
                }, completion: {_ in
                    //2
                    let isCancelled = transitionContext.transitionWasCancelled()
                    transitionContext.completeTransition(!isCancelled)
            })
        }
        //处理 Dismissal 转场，按照上一小节的结论，.Custom 模式下不要将 toView 添加到 containerView，省去了上面标记1处的操作。
        if fromVC.isBeingDismissed(){
            let fromViewHeight = fromView.frame.height
            UIView.animateWithDuration(duration, animations: {
                fromView.bounds = CGRect(x: 0, y: 0, width: 1, height: fromViewHeight)
                }, completion: { _ in
                    //2
                    let isCancelled = transitionContext.transitionWasCancelled()
                    transitionContext.completeTransition(!isCancelled)
            })
        }
    }
}
</code></pre><h4 id="Chapter2.3.3">iOS 8的改进：UIPresentationController</h4>

<p>iOS 8 针对分辨率日益分裂的 iOS 设备带来了新的适应性布局方案，以往有些专为在 iPad 上设计的控制器也能在 iPhone 上使用了，一个大变化是在视图控制器的(模态)显示过程，包括转场过程，引入了<code>UIPresentationController</code>类，该类接管了 UIViewController 的显示过程，为其提供转场和视图管理支持。当 UIViewController 的<code>modalPresentationStyle</code>属性为<code>.Custom</code>时(不支持<code>.FullScreen</code>)，我们有机会通过控制器的转场代理提供<code>UIPresentationController</code>的子类对 Modal 转场进行进一步的定制。官方对该类参与转场的流程和使用方法有非常详细的说明：<a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1" target="_blank" rel="external">Creating Custom Presentations</a>。</p>
<p><code>UIPresentationController</code>类主要给 Modal 转场带来了以下几点变化：</p>
<ol>
<li>定制 presentedView 的外观：设定 presentedView 的尺寸以及在 containerView 中添加自定义视图并为这些视图添加动画；</li>
<li>可以选择是否移除 presentingView；</li>
<li>可以在不需要动画控制器的情况下单独工作；</li>
<li>iOS 8 中的适应性布局。</li>
</ol>
<p>以上变化中第1点 iOS 7 中也能做到，3和4是 iOS 8 带来的新特性，只有第2点才真正解决了 iOS 7 中的痛点。在 iOS 7 中定制外观时，动画控制器需要负责管理额外添加的的视图，<code>UIPresentationController</code>类将该功能剥离了出来独立负责，其提供了如下的方法参与转场，对转场过程实现了更加细致的控制，从命名便可以看出与动画控制器里的<code>animateTransition:</code>的关系：</p>
<pre><code>func presentationTransitionWillBegin()
func presentationTransitionDidEnd(_ completed: Bool)
func dismissalTransitionWillBegin()
func dismissalTransitionDidEnd(_ completed: Bool)
</code></pre><p>除了 presentingView，<code>UIPresentationController</code>类拥有转场过程中剩下的角色：</p>
<pre><code>//指定初始化方法。
init(presentedViewController presentedViewController: UIViewController, presentingViewController presentingViewController: UIViewController)
var presentingViewController: UIViewController { get }
var presentedViewController: UIViewController { get }
var containerView: UIView? { get }
//提供给动画控制器使用的视图，默认返回 presentedVC.view，通过重写该方法返回其他视图，但一定要是 presentedVC.view 的上层视图。
func presentedView() -&gt; UIView?     
</code></pre><p>没有 presentingView 是因为 Custom 模式下 presentingView 不受 containerView 管理，<code>UIPresentationController</code>类并没有改变这一点。iOS 8 扩充了转场环境协议，可以通过<code>viewForKey:</code>方便获取转场的视图，而该方法在 Modal 转场中获取的是<code>presentedView()</code>返回的视图。因此我们可以在子类中将 presentedView 包装在其他视图后重写该方法返回包装后的视图当做 presentedView 在动画控制器中使用。</p>
<p>接下来，我用<code>UIPresentationController</code>子类实现上一节「Modal 转场实践」里的效果，presentingView 和 presentedView 的动画由动画控制器负责，剩下的事情可以交给我们实现的子类来完成。</p>
<p>参与角色都准备好了，但有个问题，无法直接访问动画控制器，不知道转场的持续时间，怎么与转场过程同步？这时候前面提到的用处甚少的转场协调器(Transition Coordinator)将在这里派上用场。该对象可通过 UIViewController 的<code>transitionCoordinator()</code>方法获取，这是 iOS 7 为自定义转场新增的 API，该方法只在控制器处于转场过程中才返回一个与当前转场有关的有效对象，其他时候返回 nil。</p>
<p>转场协调器遵守<code>&lt;UIViewControllerTransitionCoordinator&gt;</code>协议，它含有以下几个方法：</p>
<pre><code>//与动画控制器中的转场动画同步，执行其他动画
animateAlongsideTransition:completion:
//与动画控制器中的转场动画同步，在指定的视图内执行动画
animateAlongsideTransitionInView:animation:completion:
</code></pre><p>由于转场协调器的这种特性，动画的同步问题解决了。</p>
<pre><code>class OverlayPresentationController: UIPresentationController {
    let dimmingView = UIView()

    //Presentation 转场开始前该方法被调用。
    override func presentationTransitionWillBegin() {
        self.containerView?.addSubview(dimmingView)

        let initialWidth = containerView!.frame.width*2/3, initialHeight = containerView!.frame.height*2/3
        self.dimmingView.backgroundColor = UIColor(white: 0.0, alpha: 0.5)
        self.dimmingView.center = containerView!.center
        self.dimmingView.bounds = CGRect(x: 0, y: 0, width: initialWidth , height: initialHeight)
        //使用 transitionCoordinator 与转场动画并行执行 dimmingView 的动画。
        presentedViewController.transitionCoordinator()?.animateAlongsideTransition({ _ in
            self.dimmingView.bounds = self.containerView!.bounds
        }, completion: nil)
    }
    //Dismissal 转场开始前该方法被调用。添加了 dimmingView 消失的动画，在上一节中并没有添加这个动画，
    //实际上由于 presentedView 的形变动画，这个动画根本不会被注意到，此处只为示范。
    override func dismissalTransitionWillBegin() {
        presentedViewController.transitionCoordinator()?.animateAlongsideTransition({ _ in
            self.dimmingView.alpha = 0.0
            }, completion: nil)
    }    
}
</code></pre><p><code>OverlayPresentationController</code>类接手了 dimmingView 的工作后，需要回到上一节<code>OverlayAnimationController</code>里把涉及 dimmingView 的部分删除，然后在 presentedVC 的转场代理属性<code>transitioningDelegate</code>中提供该类实例就可以实现和上一节同样的效果。</p>
<pre><code>func presentationControllerForPresentedViewController(_ presented: UIViewController, 
                              presentingViewController presenting: UIViewController, 
                                      sourceViewController source: UIViewController) -&gt; UIPresentationController?{
    return OverlayPresentationController(presentedViewController: presented, presentingViewController: presenting)
}
</code></pre><p>在 iOS 7 中，Custom 模式的 Modal 转场里，presentingView 不会被移除，如果我们要移除它并妥善恢复会破坏动画控制器的独立性使得第三方动画控制器无法直接使用；在 iOS 8 中，<code>UIPresentationController</code>解决了这点，给予了我们选择的权力，通过重写下面的方法来决定 presentingView 是否在 presentation 转场结束后被移除：</p>
<pre><code>func shouldRemovePresentersView() -&gt; Bool
</code></pre><p>返回 true 时，presentation 结束后 presentingView 被移除，在 dimissal 结束后 UIKit 会自动将 presentingView 恢复到原来的视图结构中。通过<code>UIPresentationController</code>的参与，Custom 模式完全实现了 FullScreen 模式下的全部特性。</p>
<p>你可能会疑惑，除了解决了 iOS 7中无法干涉 presentingView 这个痛点外，还有什么理由值得我们使用<code>UIPresentationController</code>类？除了能与动画控制器配合，<code>UIPresentationController</code>类也能脱离动画控制器独立工作，在转场代理里我们仅仅提供后者也能对 presentedView 的外观进行定制，缺点是无法控制 presentedView 的转场动画，因为这是动画控制器的职责，这种情况下，presentedView 的转场动画采用的是默认的动画效果，转场协调器实现的动画则是采用默认的动画时间。</p>
<p>iOS 8 带来了适应性布局，<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIContentContainer_Ref/index.html#//apple_ref/doc/uid/TP40014526" target="_blank" rel="external"><code>&lt;UIContentContainer&gt;</code></a>协议用于响应视图尺寸变化和屏幕旋转事件，之前用于处理屏幕旋转的方法都被废弃了。UIViewController 和 UIPresentationController 类都遵守该协议，在 Modal 转场中如果提供了后者，则由后者负责前者的尺寸变化和屏幕旋转，最终的布局机会也在后者里。在<code>OverlayPresentationController</code>中重写以下方法来调整视图布局以及应对屏幕旋转：</p>
<pre><code>override func containerViewWillLayoutSubviews() {
    self.dimmingView.center = self.containerView!.center
    self.dimmingView.bounds = self.containerView!.bounds

    let width = self.containerView!.frame.width * 2 / 3, height = self.containerView!.frame.height * 2 / 3
    self.presentedView()?.center = self.containerView!.center
    self.presentedView()?.bounds = CGRect(x: 0, y: 0, width: width, height: height)
}
</code></pre><h3 id="Chapter2.4">转场代理</h3>

<p>完成动画控制器后，只需要在转场前设置好转场代理便能实现动画控制器中提供的效果。转场代理的实现很简单，但是在设置代理时有不少陷阱，需要注意。</p>
<h4 id="Chapter2.4.1">UINavigationControllerDelegate</h4>

<p>定制 UINavigationController 这种容器控制器的转场时，很适合实现一个子类，自身集转场代理，动画控制器于一身，也方便使用，不过这样做有时候又限制了它的使用范围，别人也实现了自己的子类时便不能方便使用你的效果，这里采取的是将转场代理封装成一个类。</p>
<pre><code>class SDENavigationControllerDelegate: NSObject, UINavigationControllerDelegate {
    //在&lt;UINavigationControllerDelegate&gt;对象里，实现该方法提供动画控制器，返回 nil 则使用系统默认的效果。
    func navigationController(navigationController: UINavigationController, 
         animationControllerForOperation operation: UINavigationControllerOperation, 
                         fromViewController fromVC: UIViewController, 
                             toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
        //使用上一节实现的 Slide 动画控制器，需要提供操作类型信息。
        let transitionType = SDETransitionType.NavigationTransition(operation)
        return SlideAnimationController(type: transitionType)
    }
}
</code></pre><p>如果你在代码里为你的控制器里这样设置代理：</p>
<pre><code>//错误的做法，delegate 是弱引用，在离开这行代码所处的方法范围后，delegate 将重新变为 nil，然后什么都不会发生。
self.navigationController?.delegate = SDENavigationControllerDelegate()
</code></pre><p>可以使用强引用的变量来引用新实例，且不能使用本地变量，在控制器中新增一个变量来维持新实例就可以了。</p>
<pre><code>self.navigationController?.delegate = strongReferenceDelegate
</code></pre><p>解决了弱引用的问题，这行代码应该放在哪里执行呢？很多人喜欢在<code>viewDidLoad()</code>做一些配置工作，但在这里设置无法保证是有效的，因为这时候控制器可能尚未进入 NavigationController 的控制器栈，<code>self.navigationController</code>返回的可能是 nil；如果是通过代码 push 其他控制器，在 push 前设置即可；<code>prepareForSegue:sender:</code>方法是转场前更改设置的最后一次机会，可以在这里设置；保险点，使用<code>UINavigationController</code>子类，自己作为代理，省去到处设置的麻烦。</p>
<p>不过，通过代码设置终究显得很繁琐且不安全，在 storyboard 里设置一劳永逸：在控件库里拖拽一个 NSObject 对象到相关的 UINavigationControler 上，在控制面板里将其类别设置为<code>SDENavigationControllerDelegate</code>，然后拖拽鼠标将其设置为代理。</p>
<p>最后一步，像往常一样触发转场：</p>
<pre><code>self.navigationController?.pushViewController(toVC, animated: true)//or
self.navigationController?.popViewControllerAnimated(true)
</code></pre><p>在 storyboard 中通过设置 segue 时开启动画也将看到同样的 Slide 动画。Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/NavigationControllerTransition" target="_blank" rel="external">NavigationControllerTransition</a>。</p>
<h4 id="Chapter2.4.2">UITabBarControllerDelegate</h4>

<p>同样作为容器控制器，UITabBarController 的转场代理和 UINavigationController 类似，通过类似的方法提供动画控制器，不过<code>&lt;UINavigationControllerDelegate&gt;</code>的代理方法里提供了操作类型，但<code>&lt;UITabBarControllerDelegate&gt;</code>的代理方法没有提供滑动的方向信息，需要我们来获取滑动的方向。</p>
<pre><code>class SDETabBarControllerDelegate: NSObject, UITabBarControllerDelegate {
    //在&lt;UITabBarControllerDelegate&gt;对象里，实现该方法提供动画控制器，返回 nil 则没有动画效果。
    func tabBarController(tabBarController: UITabBarController, animationControllerForTransitionFromViewController 
                                    fromVC: UIViewController, 
                     toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?{
        let fromIndex = tabBarController.viewControllers!.indexOf(fromVC)!
        let toIndex = tabBarController.viewControllers!.indexOf(toVC)!

        let tabChangeDirection: TabOperationDirection = toIndex &lt; fromIndex ? .Left : .Right
        let transitionType = SDETransitionType.TabTransition(tabChangeDirection)
        let slideAnimationController = SlideAnimationController(type: transitionType)
        return slideAnimationController
    }
}
</code></pre><p>为 UITabBarController 设置代理的方法和陷阱与上面的 UINavigationController 类似，注意<code>delegate</code>属性的弱引用问题。点击 TabBar 的相邻页面进行切换时，将会看到 Slide 动画；通过以下代码触发转场时也将看到同样的效果：</p>
<pre><code>tabBarVC.selectedIndex = ...//or
tabBarVC.selectedViewController = ...
</code></pre><p>Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/ScrollTabBarController" target="_blank" rel="external">ScrollTabBarController</a>。</p>
<h4 id="Chapter2.4.3">UIViewControllerTransitioningDelegate</h4>

<p>Modal 转场的代理协议<code>&lt;UIViewControllerTransitioningDelegate&gt;</code>是 iOS 7 新增的，其为 presentation 和 dismissal 转场分别提供了动画控制器。在「特殊的 Modal 转场」里实现的<code>OverlayAnimationController</code>类可同时处理 presentation 和 dismissal 转场。<code>UIPresentationController</code>只在 iOS 8中可用，通过<code>available</code>关键字可以解决 API 的版本差异。 </p>
<pre><code>class SDEModalTransitionDelegate: NSObject, UIViewControllerTransitioningDelegate {
    func animationControllerForPresentedController(presented: UIViewController, 
                             presentingController presenting: UIViewController, 
                                     sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
        return OverlayAnimationController()
    }

    func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
        return OverlayAnimationController()
    }

    @available(iOS 8.0, *)
    func presentationControllerForPresentedViewController(presented: UIViewController, 
                                presentingViewController presenting: UIViewController, 
                                        sourceViewController source: UIViewController) -&gt; UIPresentationController? {
        return OverlayPresentationController(presentedViewController: presented, presentingViewController: presenting)
    }
}
</code></pre><p>Modal 转场的代理由 presentedVC 的<code>transitioningDelegate</code>属性来提供，这与前两种容器控制器的转场不一样，不过该属性作为代理同样是弱引用，记得和前面一样需要有强引用的变量来维护该代理，而 Modal 转场需要 presentedVC 来提供转场代理的特性使得 presentedVC 自身非常适合作为自己的转场代理。另外，需要将 presentedVC 的<code>modalPresentationStyle</code>属性设置为<code>.Custom</code>或<code>.FullScreen</code>，只有这两种模式下才支持自定义转场，该属性默认值为<code>.FullScreen</code>。自定义转场时，决定转场动画效果的<code>modalTransitionStyle</code>属性将被忽略。</p>
<p>开启转场动画的方式依然是两种：在 storyboard 里设置 segue 并开启动画，但这里并不支持<code>.Custom</code>模式，不过还有机会挽救，转场前的最后一个环节<code>prepareForSegue:sender:</code>方法里可以动态修改<code>modalPresentationStyle</code>属性；或者全部在代码里设置，示例如下：</p>
<pre><code>let presentedVC = ...
presentedVC.transitioningDelegate = strongReferenceSDEModalTransitionDelegate
//当与 UIPresentationController 配合时该属性必须为.Custom。
presentedVC.modalPresentationStyle = .Custom/.FullScreen      
presentingVC.presentViewController(presentedVC, animated: true, completion: nil)
</code></pre><p>Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CustomModalTransition" target="_blank" rel="external">CustomModalTransition</a>。</p>
<h2 id="Chapter3">阶段二：交互式转场</h2>

<p>激动人心的部分来了，好消息是交互转场的实现难度比你想象的要低。</p>
<h3 id="Chapter3.1">实现交互化</h3>

<p>在非交互转场的基础上将之交互化需要两个条件：</p>
<ol>
<li><p>由转场代理提供交互控制器，这是一个遵守<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>协议的对象，不过系统已经打包好了现成的类<code>UIPercentDrivenInteractiveTransition</code>供我们使用。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。</p>
</li>
<li><p>交互控制器还需要交互手段的配合，最常见的是使用手势，或是其他事件，来驱动整个转场进程。</p>
</li>
</ol>
<p>满足以上两个条件很简单，但是很容易犯错误。</p>
<p><strong>正确地提供交互控制器</strong>：</p>
<p>如果在转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程(比如手势)，转场过程将一直处于开始阶段无法结束，应用界面也会失去响应：在 NavigationController 中点击 NavigationBar 也能实现 pop 返回操作，但此时没有了交互手段的支持，转场过程卡壳；在 TabBarController 的代理里提供交互控制器存在同样的问题，点击 TabBar 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。</p>
<p>以为 NavigationController 提供交互控制器为例：</p>
<pre><code>class SDENavigationDelegate: NSObject, UINavigationControllerDelegate {
    var interactive = false
    let interactionController = UIPercentDrivenInteractiveTransition()
    ...

    func navigationController(navigationController: UINavigationController, interactionControllerForAnimationController 
                               animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? {
        return interactive ? self.interactionController : nil
    }
}
</code></pre><p>TabBarController 的实现类似，Modal 转场代理分别为 presentation 和 dismissal 提供了各自的交互控制器，也需要注意上面的问题。</p>
<p>问题的根源是交互控制的工作机制导致的，交互过程实际上是由转场环境对象<code>&lt;UIViewControllerContextTransitioning&gt;</code>来管理的，它提供了如下几个方法来控制转场的进度：</p>
<pre><code>func updateInteractiveTransition(_ percentComplete: CGFloat)//更新转场进度，进度数值范围为0.0~1.0。
func cancelInteractiveTransition()//取消转场，转场动画从当前状态返回至转场发生前的状态。
func finishInteractiveTransition()//完成转场，转场动画从当前状态继续直至结束。
</code></pre><p>交互控制协议<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>只有一个必须实现的方法：</p>
<pre><code>func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning)
</code></pre><p>在转场代理里提供了交互控制器后，转场开始时，该方法自动被 UIKit 调用对转场环境进行配置。</p>
<p>系统打包好的<code>UIPercentDrivenInteractiveTransition</code>中的控制转场进度的方法与转场环境对象提供的三个方法同名，实际上只是前者调用了后者的方法而已。系统以一种解耦的方式使得动画控制器，交互控制器，转场环境对象互相协作，我们只需要使用<code>UIPercentDrivenInteractiveTransition</code>的三个同名方法来控制进度就够了。如果你要实现自己的交互控制器，而不是<code>UIPercentDrivenInteractiveTransition</code>的子类，就需要调用转场环境的三个方法来控制进度，压轴环节我们将示范如何做。</p>
<p>交互控制器控制转场的过程就像将动画控制器实现的动画制作成一部视频，我们使用手势或是其他方法来控制转场动画的播放，可以前进，后退，继续或者停止。<code>finishInteractiveTransition()</code>方法被调用后，转场动画从当前的状态将继续进行直到动画结束，转场完成；<code>cancelInteractiveTransition()</code>被调用后，转场动画从当前的状态回拨到初始状态，转场取消。</p>
<p>在 NavigationController 中点击 NavigationBar 的 backBarButtomItem 执行 pop 操作时，由于我们无法介入 backBarButtomItem 的内部流程，就失去控制进度的手段，于是转场过程只有一个开始，永远不会结束。其实我们只需要有能够执行上述几个方法的手段就可以对转场动画进行控制，用户与屏幕的交互手段里，手势是实现这个控制过程的天然手段，我猜这是其被称为交互控制器的原因。</p>
<p><strong>交互手段的配合</strong>：</p>
<p>下面使用演示如何利用屏幕边缘滑动手势<code>UIScreenEdgePanGestureRecognizer</code>在 NavigationController 中控制 Slide 动画控制器提供的动画来实现右滑返回的效果，该手势绑定的动作方法如下：</p>
<pre><code>func handleEdgePanGesture(gesture: UIScreenEdgePanGestureRecognizer){
    //根据移动距离计算交互过程的进度。
    let percent = ...
    switch gesture.state{
    case .Began:
        //转场开始前获取代理，一旦转场开始，VC 将脱离控制器栈，此后 self.navigationController 返回的是 nil。
        self.navigationDelegate = self.navigationController?.delegate as? SDENavigationDelegate
        //更新交互状态
        self.navigationDelegate?.interactive = true
        //1.交互控制器没有 start 之类的方法，当下面这行代码执行后，转场开始；
        //如果转场代理提供了交互控制器，它将从这时候开始接管转场过程。
        self.navigationController?.popViewControllerAnimated(true)
    case .Changed:
        //2.更新进度：
        self.navigationDelegate?.interactionController.updateInteractiveTransition(percent)
    case .Cancelled, .Ended:
        //3.结束转场：
        if percent &gt; 0.5{
            //完成转场。
            self.navigationDelegate?.interactionController.finishInteractiveTransition()
        }else{
            //或者，取消转场。
            self.navigationDelegate?.interactionController.cancelInteractiveTransition()
        }
        //无论转场的结果如何，恢复为非交互状态。
        self.navigationDelegate?.interactive = false
    default: self.navigationDelegate?.interactive = false
    }
}
</code></pre><p>交互转场的流程就是三处数字标记的代码。不管是什么交互方式，使用什么转场方式，都是在使用这三个方法控制转场的进度。<strong>对于交互式转场，交互手段只是表现形式，本质是驱动转场进程。</strong>很希望能够看到更新颖的交互手法，比如通过点击页面不同区域来控制一套复杂的流程动画。TabBarController 的 Demo 中也实现了滑动切换 Tab 页面，代码是类似的，就不占篇幅了；示范的 Modal 转场我没有为之实现交互控制，原因也提到过了，没有比较合乎操作直觉的交互手段，不过真要为其添加交互控制，代码和上面是类似的。</p>
<p>转场交互化后结果有两种：完成和取消。取消后动画将会原路返回到初始状态，但已经变化了的数据怎么恢复？</p>
<p>一种情况是，控制器的系统属性，比如，在 TabBarController 里使用上面的方法实现滑动切换 Tab 页面，中途取消的话，已经变化的<code>selectedIndex</code>属性该怎么恢复为原值；上面的代码里，取消转场的代码执行后，<code>self.navigationController</code>返回的依然还是是 nil，怎么让控制器回到 NavigationController 的控制器栈顶。对于这种情况，UIKit 自动替我们恢复了，不需要我们操心(可能你都没有意识到这回事)；</p>
<p>另外一种就是，转场发生的过程中，你可能想实现某些效果，一般是在下面的事件中执行，转场中途取消的话可能需要取消这些效果。</p>
<pre><code>func viewWillAppear(_ animated: Bool)
func viewDidAppear(_ animated: Bool)
func viewWillDisappear(_ animated: Bool)
func viewDidDisappear(_ animated: Bool)
</code></pre><p>交互转场介入后，视图在这些状态间的转换变得复杂，WWDC 上苹果的工程师还表示转场过程中 view 的<code>Will</code>系方法和<code>Did</code>系方法的执行顺序并不能得到保证，虽然几率很小，但如果你依赖于这些方法执行的顺序的话就可能需要注意这点。而且，<code>Did</code>系方法调用时并不意味着转场过程真的结束了。另外，fromView 和 toView 之间的这几种方法的相对顺序更加混乱，具体的案例可以参考这里：<a href="http://wangling.me/2014/02/the-inconsistent-order-of-view-transition-events.html" target="_blank" rel="external">The Inconsistent Order of View Transition Events</a>。</p>
<p>如何在转场过程中的任意阶段中断时取消不需要的效果？这时候该转场协调器(Transition Coordinator)再次出场了。</p>
<h3 id="Chapter3.2">Transition Coordinator</h3>

<p>转场协调器(Transition Coordinator)的出场机会不多，但却是关键先生。Modal<br>转场中，<code>UIPresentationController</code>类只能通过转场协调器来与动画控制器同步，并行执行其他动画；这里它可以在交互式转场结束时执行一个闭包：</p>
<pre><code>func notifyWhenInteractionEndsUsingBlock(_ handler: (UIViewControllerTransitionCoordinatorContext) -&gt; Void)
</code></pre><p>当转场由交互状态转变为非交互状态(在手势交互过程中则为手势结束时)，无论转场的结果是完成还是被取消，该方法都会被调用；得益于闭包，转场协调器可以在转场过程中的任意阶段搜集动作并在交互中止后执行。闭包中的参数是一个遵守<code>&lt;UIViewControllerTransitionCoordinatorContext&gt;</code>协议的对象，该对象由 UIKit 提供，和前面的转场环境对象<code>&lt;UIViewControllerContextTransitioning&gt;</code>作用类似，它提供了交互转场的状态信息。</p>
<pre><code>override func viewWillAppear(animated: Bool) {
    super.viewWillDisappear(animated)
    self.doSomeSideEffectsAssumingViewDidAppearIsGoingToBeCalled()
    //只在处于交互转场过程中才可能取消效果。
    if let coordinator = self.transitionCoordinator() where coordinator.initiallyInteractive() == true{
        coordinator.notifyWhenInteractionEndsUsingBlock({
            interactionContext in
            if interactionContext.isCancelled(){
                self.undoSideEffects()
            }
        })
    }
}
</code></pre><p>不过交互状态结束时并非转场过程的终点(此后动画控制器提供的转场动画根据交互结束时的状态继续或是返回到初始状态)，而是由动画控制器来结束这一切：</p>
<pre><code>optional func animationEnded(_ transitionCompleted: Bool)
</code></pre><p>如果实现了该方法，将在转场动画结束后调用。</p>
<p>UIViewController 可以通过<code>transitionCoordinator()</code>获取转场协调器，该方法的文档中说只有在 Modal 转场过程中，该方法才返回一个与当前转场相关的有效对象。实际上，NavigationController 的转场中 fromVC 和 toVC 也能返回一个有效对象，TabBarController 有点特殊，fromVC 和 toVC 在转场中返回的是 nil，但是作为容器的 TabBarController 可以使用该方法返回一个有效对象。</p>
<p>转场协调器除了上面的两种关键作用外，也在 iOS 8 中的适应性布局中担任重要角色，可以查看<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIContentContainer_Ref/index.html#//apple_ref/doc/uid/TP40014526" target="_blank" rel="external"><code>&lt;UIContentContainer&gt;</code></a>协议中的方法，其中响应尺寸和屏幕旋转事件的方法都包含一个转场协调器对象，视图的这种变化也被系统视为广义上的 transition，参数中的转场协调器也由 UIKit 提供。这个话题有点超出本文的范围，就不深入了，有需要的话可以查看文档和相关 session。</p>
<h3 id="Chapter3.3">封装交互控制器</h3>

<p><code>UIPercentDrivenInteractiveTransition</code>类是一个系统提供的交互控制器，在转场代理的相关方法里提供一个该类实例就够了，还有其他需求的话可以实现其子类来完成，那这里的封装是指什么？系统把交互控制器打包好了，但是交互控制器工作还需要其他的配置。程序员向来很懒，能够自动完成的事绝不肯写一行代码，写一行代码就能搞定的事绝不写第二行，所谓少写一行是一行。能不能顺便把交互控制器的配置也打包好省得写代码啊？当然可以。</p>
<p>热门转场动画库 <a href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller" target="_blank" rel="external">VCTransitionsLibrary</a> 封装好了多种动画效果，并且自动支持 pop, dismissal 和 tab change 等操作的手势交互，其手法是在转场代理里为 toVC 添加手势并绑定相应的处理方法。</p>
<p>为何没有支持 push 和 presentation 这两种转场？因为 push 和 presentation 这两种转场需要提供 toVC，而库并没有 toVC 的信息，这需要作为使用者的开发者来提供；对于逆操作的 pop 和 dismiss，toVC 的信息已经存在了，所以能够实现自动支持。而 TabBarController 则是个例外，它是在已知的子 VC 之间切换，不存在这个问题。需要注意的是，库这样封装了交互控制器后，那么你将无法再让同一种手势支持 push 或 presentation，要么只支持单向的转场，要么你自己实现双向的转场。当然，如果知道 toVC 是什么类的话，你可以改写这个库让 push 和 present 得到支持。不过，对于在初始化时需要配置额外信息的类，这种简单的封装可能不起作用。<a href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller" target="_blank" rel="external">VCTransitionsLibrary</a> 库还支持添加自定义的简化版的动画控制器和交互控制器，在封装和灵活之间的平衡控制得很好，代码非常值得学习。</p>
<p>只要愿意，我们还可以变得更懒，不，是效率更高。<a href="https://github.com/forkingdog/FDFullscreenPopGesture.git" target="_blank" rel="external">FDFullscreenPopGesture</a> 通过 category 的方法让所有的 UINavigationController 都支持右滑返回，而且，一行代码都不用写，这是配套的博客：<a href="http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/" target="_blank" rel="external">一个丝滑的全屏滑动返回手势</a>。那么也可以实现一个类似的 FullScreenTabScrollGesture 让所有的 UITabBarController 都支持滑动切换，不过，UITabBar 上的 icon 渐变动画有点麻烦，因为其中的 UITabBarItem 并非 UIView 子类，无法进行动画。<a href="https://github.com/leichunfeng/WXTabBarController.git" target="_blank" rel="external">WXTabBarController</a> 这个项目完整地实现了微信界面的滑动交互以及 TabBar 的渐变动画。不过，它的滑动交互并不是使用转场的方式完成的，而是使用 UIScrollView，好处是兼容性更好。兼容性这方面国内的环境比较差，iOS 9 都出来了，可能还需要兼容 iOS 6，而自定义转场需要至少 iOS 7 的系统。该项目实现的 TabBar 渐变动画是基于 TabBar 的内部结构实时更新相关视图的 alpha 值来实现的(不是UIView 动画），这点非常难得，而且使用 UIScrollView 还可以实现自动控制 TabBar 渐变动画，相比之下，使用转场的方式来实现这个效果会麻烦一点。</p>
<p>一个较好的转场方式需要顾及更多方面的细节，NavigationController 的 NavigationBar 和 TabBarController 的 TabBar 这两者在先天上有着诸多不足需要花费更多的精力去完善，本文就不在这方面深入了，上面提及的几个开源项目都做得比较好，推荐学习。</p>
<h3 id="Chapter3.4">交互转场的限制</h3>

<p>如果希望转场中的动画能完美地被交互控制，必须满足2个隐性条件：</p>
<ol>
<li>使用 UIView 动画的 API。你当然也可以使用 Core Animation 来实现动画，甚至，这种动画可以被交互控制，但是当交互中止时，会出现一些意外情况：如果你正确地用 Core Animation 的方式复现了 UIView 动画的效果(不仅仅是动画，还包括动画结束后的处理)，那么手势结束后，动画将直接跳转到最终状态；而更多的一种状况是，你并没有正确地复现 UIView 动画的效果，手势结束后动画会停留在手势中止时的状态，界面失去响应。所以，如果你需要完美的交互转场动画，必须使用 UIView 动画。</li>
<li>在动画控制器的<code>animateTransition:</code>中提交动画。问题和第1点类似，在<code>viewWillDisappear:</code>这样的方法中提交的动画也能被交互控制，但交互停止时，立即跳转到最终状态。</li>
</ol>
<p>如果你希望制作多阶段动画，在某个动画结束后再执行另外一段动画，可以通过 UIView Block Animation 的 completion 闭包来实现动画链，或者是通过设定动画执行的延迟时间使得不同动画错分开来，但是交互转场不支持这两种形式。UIView 的 keyFrame Animation API 可以帮助你，通过在动画过程的不同时间节点添加关键帧动画就可以实现多阶段动画。我实现过一个这样的多阶段转场动画，Demo 在此：<a href="https://github.com/seedante/SDECollectionViewAlbumTransition.git" target="_blank" rel="external">CollectionViewAlbumTransition</a>。</p>
<h2 id="Chapter4">插曲：UICollectionViewController 布局转场</h2>

<p>前面一直没有提到这种转场方式，与三大主流转场不同，布局转场只针对 CollectionViewController 搭配 NavigationController 的组合，且是作用于布局，而非视图。采用这种布局转场时，NavigationController 将会用布局变化的动画来替代 push 和 pop 的默认动画。苹果自家的照片应用中的「照片」Tab 页面使用了这个技术：在「年度-精选-时刻」几个时间模式间切换时，CollectionViewController 在 push 或 pop 时尽力维持在同一个元素的位置同时进行布局转换。</p>
<p>布局转场的实现比三大主流转场要简单得多，只需要满足四个条件：NavigationController + CollectionViewController, 且要求后者都拥有相同数据源， 并且开启<code>useLayoutToLayoutNavigationTransitions</code>属性为真。</p>
<pre><code>let cvc0 = UICollectionViewController(collectionViewLayout: layout0)
//作为 root VC 的 cvc0 的该属性必须为 false，该属性默认为 false。
cvc0.useLayoutToLayoutNavigationTransitions = false
let nav = UINavigationController(rootViewController: cvc0)
//cvc0, cvc1, cvc2 必须具有相同的数据，如果在某个时刻修改了其中的一个数据源，其他的数据源必须同步，不然会出错。
let cvc1 = UICollectionViewController(collectionViewLayout: layout1)
cvc1.useLayoutToLayoutNavigationTransitions = true
nav.pushViewController(cvc1, animated: true)

let cvc2 = UICollectionViewController(collectionViewLayout: layout2)
cvc2.useLayoutToLayoutNavigationTransitions = true
nav.pushViewController(cvc2, animated: true)

nav.popViewControllerAnimated(true)
nav.popViewControllerAnimated(true)
</code></pre><p>Push 进入控制器栈后，不能更改<code>useLayoutToLayoutNavigationTransitions</code>的值，否则应用会崩溃。当 CollectionView 的数据源(section 和 cell 的数量)不完全一致时，push 和 pop 时依然会有布局转场动画，但是当 pop 回到 rootVC 时，应用会崩溃。可否共享数据源保持同步来克服这个缺点？测试表明，这样做可能会造成画面上的残缺，以及不稳定，建议不要这么做。</p>
<p>此外，iOS 7 支持 UICollectionView 布局的交互转换(Layout Interactive Transition)，过程与控制器的交互转场(ViewController Interactive Transition)类似，这个功能和布局转场(CollectionViewController Layout Transition)容易混淆，前者是在自身布局转换的基础上实现了交互控制，后者是 CollectionViewController 与 NavigationController 结合后在转场的同时进行布局转换。感兴趣的话可以看<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/index.html#//apple_ref/occ/instm/UICollectionView/startInteractiveTransitionToCollectionViewLayout:completion:" target="_blank" rel="external">这个功能的文档</a>。</p>
<p>布局转场不支持交互控制。Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CollectionViewControllerLayoutTransition" target="_blank" rel="external">CollectionViewControllerLayoutTransition</a>。</p>
<h2 id="Chapter5">进阶</h2>

<p>是否觉得本文中实现的例子的动画效果太过简单？的确很简单，与 <a href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller" target="_blank" rel="external">VCTransitionsLibrary</a> 这样的转场动画库提供的十种动画效果相比是很简单的，不过就动画而言，与本文示例的本质是一样的，它们都是针对 fromView 和 toView 的整体进行的动画，但在效果上更加复杂。我在本文中多次强调转场动画的本质是是对即将消失的当前视图和即将出现的下一屏幕的内容进行动画，「在动画控制器里，参与转场的视图只有 fromView 和 toView 之分，与转场方式无关。转场动画的最终效果只限制于你的想象力」，当然，还有你的实现能力。</p>
<p>本文前面的目的是帮助你熟悉转场的整个过程，你也看到了，转场动画里转场部分的实现其实很简单，大部分复杂的转场动画与本文范例里简单的转场动画相比，复杂的部分在动画部分，转场的部分都是一样的。因此，学习了前面的内容后并不能帮助你立马就能够实现 Github 上那些热门的转场动画，它们成为热门的原因在于动画本身，与转场本身关系不大，但它们与转场结合后就有了神奇的力量。那学习了作为进阶的本章能立马实现那些热门的转场效果吗？有可能，有些效果其实很简单，一点就透，还有一些效果涉及的技术属于本文主题之外的内容，我会给出相关的提示就不深入了。</p>
<p>本章的进阶分为两个部分：</p>
<ol>
<li>案例分析：动画的方式非常多，有些并不常见，有些只是简单到令人惊讶的组合，只是你不曾了解过所以不知道如何实现，一旦了解了就不再是难事。尽管这些动画本身并不属于转场技术这个主题，但与转场动画组合后往往有着惊艳的视觉效果，这部分将提供一些实现此类转场动画的思路，技巧和工具来扩展视野。有很多动画类型我也没有尝试过，可能的话我会继续更新一些有意思的案例。</li>
<li>自定义容器转场：官方支持四种方式的转场，而且这些也足以应付绝大多数需求了，但依然有些地方无法顾及。本文一直通过探索转场的边界的方式来总结使用方法以及陷阱，在本文的压轴部分，我们将挣脱系统的束缚来实现自定义容器控制器的转场效果。</li>
</ol>
<h3 id="Chapter5.1">案例分析</h3>

<p>动画的持续时间一般不超过0.5秒，稍纵即逝，有时候看到一个复杂的转场动画也不容易知道实现的方式，我一般是通过逐帧解析的手法来分析实现的手段：开源的就运行一下，使用系统自带的 QuickPlayer 对 iOS 设备进行录屏，再使用 QuickPlayer 打开视频，按下 cmd+T 打开剪辑功能，这时候就能查看每一帧了；Gif 等格式的原型动画的动图就直接使用系统自带的 Preview 打开看中间帧。</p>
<p><strong>子元素动画</strong></p>
<p>当转场动画涉及视图中的子视图时，往往无法依赖第三方的动画库来实现，你必须为这种效果单独定制，神奇移动就是一个典型的例子。神奇移动是 Keynote 中的一个动画效果，如果某个元素在连续的两页 Keynote 同时存在，在页面切换时，该元素从上一页的位置移动到下一页的位置，非常神奇。在转场中怎么实现这个效果呢？最简单的方法是截图配合移动动画：伪造那个元素的视图添加到 containerView 中，从 fromView 中的位置移动到 toView 中的位置，这期间 fromView 和 toView 中的该元素视图隐藏，等到移动结束恢复 toView 中该元素的显示，并将伪造的元素视图从 containerView 中移除。</p>
<p>UIView 有几个<code>convert</code>方法用于在不同的视图之间转换坐标：</p>
<pre><code>func convertPoint(_ point: CGPoint, toView view: UIView?) -&gt; CGPoint
func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint
func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint
func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint
</code></pre><p>对截图这个需求，iOS 7 提供了趁手的工具，UIView Snapshot API：</p>
<pre><code>func snapshotViewAfterScreenUpdates(_ afterUpdates: Bool) -&gt; UIView
//获取视图的部分内容
func resizableSnapshotViewFromRect(_ rect: CGRect, afterScreenUpdates afterUpdates: Bool, withCapInsets capInsets: UIEdgeInsets) -&gt; UIView
</code></pre><p>当<code>afterScreenUpdates</code>参数值为<code>true</code>时，这两个方法能够强制视图立刻更新内容，同时返回更新后的视图内容。在 push 或 presentation 中，如果 toVC 是 CollectionViewController 并且需要对 visibleCells 进行动画，此时动画控制器里是无法获取到的，因为此时 collectionView 还未向数据源询问内容，执行此方法后能够达成目的。UIView 的<code>layoutIfNeeded()</code>也能要求立即刷新布局达到同样的效果。</p>
<p><strong>Mask 动画</strong></p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/MaskAnimtion.gif?raw=true" alt="MaskAnimtion"></p>
<p>左边的动画教程：<a href="http://www.raywenderlich.com/86521/how-to-make-a-view-controller-transition-animation-like-in-the-ping-app" target="_blank" rel="external">How To Make A View Controller Transition Animation Like in the Ping App</a>；右边动画的开源地址：<a href="https://github.com/andreamazz/BubbleTransition.git" target="_blank" rel="external">BubbleTransition</a>。</p>
<p>Mask 动画往往在视觉上令人印象深刻，这种动画通过使用一种特定形状的图形作为 mask 截取当前视图内容，使得当前视图只表现出 mask 图形部分的内容，在 PS 界俗称「遮罩」。UIView 有个属性<code>maskView</code>可以用来遮挡部分内容，但这里的效果并不是对<code>maskView</code>的利用；CALayer 有个对应的属性<code>mask</code>，而 CAShapeLayer 这个子类搭配 UIBezierPath 类可以实现各种不规则图形。这种动画一般就是 mask + CAShapeLayer + UIBezierPath 的组合拳搞定的，实际上实现这种圆形的形变是很简单的，只要发挥你的想象力，可以实现任何形状的形变动画。</p>
<p>这类转场动画在转场过程中对 toView 使用 mask 动画，不过，右边的这个动画实际上并不是上面的组合来完成的，它的真相是这样：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/Truth%20behind%20BubbleTransition.gif?raw=true" alt="Truth behind BubbleTransition"></p>
<p>这个开发者实在是太天才了，这个手法本身就是对 mask 概念的应用，效果卓越，但方法却简单到难以置信。关于使用 mask + CAShapeLayer + UIBezierPath 这种方法实现 mask 动画的方法请看我的<a href="http://www.jianshu.com/p/3c925a1609f8" target="_blank" rel="external">这篇文章</a>。</p>
<p><strong>高性能动画框架</strong></p>
<p>有些动画使用 UIView 的动画 API 难以实现，或者难以达到较好的性能，又或者两者皆有，幸好我们还有其他选择。<a href="https://yalantis.com/blog/uidynamics-uikit-or-opengl-3-types-of-ios-animations-for-the-star-wars/" target="_blank" rel="external">StartWar</a> 使用更底层的 OpenGL 框架来解决性能问题以及 Objc.io 在探讨转场这个话题时<a href="http://objccn.io/issue-5-3/" target="_blank" rel="external">使用 GPUImage 定制动画</a>都是这类的典范。在交互控制器章节中提到过，官方只能对 UIView 动画 API 实现的转场动画实施完美的交互控制，这也不是绝对的，接下来我们就来挑战这个难题。</p>
<h3 id="Chapter5.2">自定义容器控制器转场</h3>

<p>压轴环节我们将实现这样一个效果：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/CustomContainerVCButtonTransition.gif?raw=true" alt="ButtonTransition"><br><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/ContainerVCTransition.mov.gif?raw=true" alt="ContainerVC Interacitve Transition"></p>
<p>Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CustomContainerVCTransition" target="_blank" rel="external">CustomContainerVCTransition</a>。</p>
<p>分析一下思路，这个控制器和 UITabBarController 在行为上比较相似，只是 TabBar 由下面跑到了上面。我们可以使用 UITabBarController 子类，然后打造一个伪 TabBar 放在顶部，原来的 TabBar 则隐藏，行为上完全一致，使用 UITabBarController 子类的好处是可以减轻实现转场的负担，不过，有时候这样的子类不是你想要的，UIViewController 子类能够提供更多的自由度，好吧，一个完全模仿 UITabBarController 行为的 UIViewController 子类，实际上我没有想到非得这样做的原因，但我想肯定有需要定制自己的容器控制器的场景，这正是本节要探讨的。Objc.io 也讨论过<a href="http://objccn.io/issue-12-3/" target="_blank" rel="external">这个话题</a>，文章的末尾把实现交互控制当做作业留了下来。珠玉在前，我就站在大牛的肩上继续这个话题吧。Objc.io 的这篇文章写得较早使用了 Objective-C 语言，如果要读者先去读这篇文章再继续读本节的内容，难免割裂，所以本节还是从头讨论这个话题吧，最终效果如上面所示，在自定义的容器控制器中实现交互控制切换子视图，也可以通过填充了 UIButton 的 ButtonTabBar 来实现 TabBar 一样行为的 Tab 切换，在通过手势切换页面时 ButtonTabBar 会实现渐变色动画。ButtonTabBar 有很大扩展性，改造或是替换为其他视图还是有很多应用场景的。</p>
<h4 id="Chapter5.2.1">实现分析</h4>

<p>既然这个自定义容器控制器和 UITabBarController 行为类似，我便实现了一套类似的 API：<code>viewControllers</code>数组是容器 VC 维护的子 VC 数组，初始化时提供要显示的子 VC，更改<code>selectedIndex</code>的值便可跳转到对应的子视图。利用 Swift 的属性观察器实现修改<code>selectedIndex</code>时自动执行子控制器转场。下面是实现子 VC 转场的核心代码，转场结束后遵循系统的惯例将 fromView 移除：</p>
<pre><code>class SDEContainerViewController: UIViewController{
    ...
    //发生转场的容器视图，是 root view 的子视图。
    private let privateContainerView = UIView()
    var selectedIndex: Int = NSNotFound{
        willSet{
            transitionViewControllerFromIndex(selectedIndex, toIndex: newValue)
        }
    }
    //实现 selectedVC 转场：
    private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int){
        //添加 toVC 和 toView
        let newSelectedVC = viewControllers![toIndex]
        self.addChildViewController(newSelectedVC)
        self.privateContainerView.addSubview(newSelectedVC.view)
        newSelectedVC.didMoveToParentViewController(self)

        UIView.animateWithDuration(transitionDuration, animations: {
            /*转场动画*/
            }, completion: { finished in
                //移除 fromVC 和 fromView。
                let priorSelectedVC = viewControllers![fromIndex]
                priorSelectedVC.willMoveToParentViewController(nil)
                priorSelectedVC.view.removeFromSuperview()
                priorSelectedVC.removeFromParentViewController()
        })
    }
}
</code></pre><p>实现转场就是这么十几行代码而已，其他容器 VC 转场过程做了类似的事情。回忆下我们在动画控制器里做的事情，实际上只是上面代码中的一部分。转场协议这套 API 将这个过程分割为五个组件，这套复杂的结构带来了可高度自定义的动画效果和交互控制。我们温习下转场协议，来看看如何在既有的转场协议框架下实现自定义容器控制器的转场动画以及交互控制：</p>
<ol>
<li>转场代理：既有的转场代理协议并没有直接支持我们这种转场方式，没关系，我们自定义一套代理协议来提供动画控制器和交互控制器；</li>
<li>动画控制器：动画控制器是可复用的，这里采用动画控制器章节封装的 Slide 动画控制器，可以拿来直接使用而不用修改；</li>
<li>交互控制器：官方封装了一个现成的交互控制器类，但这个类是与 UIKit 提供的转场环境对象配合使用的，而这里的转场显然需要我们来提供转场环境对象，因此<code>UIPercentDrivenInteractiveTransition</code>无法在这里使用，需要我们来实现这个协议；</li>
<li>转场环境：在官方支持的转场方式中，转场环境是由 UIKit 主动提供给我们的，既然现在的转场方式不是官方支持的，显然需要我们自己提供这个对象以供动画控制器和交互控制器使用；</li>
<li>转场协调器：在前面的章节中我提到过，转场协调器(Transition Coordinator)的使用场景有限而关键，也是由系统提供，我们也可以重写相关方法来提供。这个部分我留给读者当作是本文的一道作业吧。</li>
</ol>
<p>下面我们来将上面的十几行代码(不包括实际的动画代码)使用协议封装成本文前半部分里熟悉的样子。</p>
<h4 id="Chapter5.2.2">协议补完</h4>

<p>模仿 UITabBarControllerDelegate 协议的 ContainerViewControllerDelegate 协议：</p>
<pre><code>//在 Swift 协议中声明可选方法必须在协议声明前添加 @objc 修饰符。
@objc protocol ContainerViewControllerDelegate{
    func containerController(containerController: SDEContainerViewController, animationControllerForTransitionFromViewController 
                                          fromVC: UIViewController, 
                           toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?
    optional func containerController(containerController: SDEContainerViewController, interactionControllerForAnimation 
                                      animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning?
}
</code></pre><p>在容器控制器<code>SDEContainerViewController</code>类中，添加转场代理属性：</p>
<pre><code>weak var containerTransitionDelegate: ContainerViewControllerDelegate?
</code></pre><p>代理的定位就是提供动画控制器和交互控制器，系统打包的<code>UIPercentDrivenInteractiveTransition</code>类只是调用了转场环境对象的对应方法而已，执行<code>navigationController.pushViewController(toVC, animated: true)</code>这类语句触发转场后 UIKit 就接管了剩下的事情，再综合文档的描述，可知转场环境便是实现这一切的核心。</p>
<p>在文章前面的部分里转场环境对象的作用只是提供涉及转场过程的信息和状态，现在需要我们实现该协议，并且实现隐藏的那部分职责。<br><code>&lt;UIViewControllerContextTransitioning&gt;</code>协议里的绝大部分方法都是必须实现的，不过现在我们先实现非交互转场的部分，实现这个是很简单的，主要是调用动画控制器执行转场动画。在「实现分析」一节里我们看到实现转场的代码只有十几行而已，动画控制器需要做的只是处理视图和动画的部分，转场环境对象则要负责管理子 VC，通过<code>SDEContainerViewController</code>提供 containerView 以及 fromVC 和 toVC，实现并不是难事。显然由我们实现的自定义容器 VC 来提供转场环境对象是最合适的，并且转场环境对象应该是私有的，其初始化方法极其启动转场的方法如下：</p>
<pre><code>class ContainerTransitionContext: NSObject, UIViewControllerContextTransitioning{
    init(containerViewController: SDEContainerViewController, 
                   containerView: UIView, 
       fromViewController fromVC: UIViewController, 
           toViewController toVC: UIViewController){...}

    //非协议方法，是启动非交互式转场的便捷方法。
    func startNonInteractiveTransitionWith(delegate: ContainerViewControllerDelegate){
        //转场开始前添加 toVC，转场动画结束后会调用 completeTransition: 方法，在该方法里完成后续的操作。
        self.privateContainerViewController.addChildViewController(privateToViewController)
        //通过 ContainerViewControllerDelegate 协议定义的方法生成动画控制器，方法名太长了略去。
        self.privateAnimationController = delegate.XXXmethod
        //启动转场并执行动画。
        self.privateAnimationController.animateTransition(self)
    }
    //协议方法，动画控制器在动画结束后调用该方法，完成管理子 VC 的后续操作，并且考虑交互式转场可能取消的情况撤销添加的子 VC。
    func completeTransition(didComplete: Bool) {
        if didComplete{
            //转场完成，完成添加 toVC 的工作，并且移除 fromVC 和 fromView。
            self.privateToViewController.didMoveToParentViewController(privateContainerViewController)
            self.privateFromViewController.willMoveToParentViewController(nil)
            self.privateFromViewController.view.removeFromSuperview()
            self.privateFromViewController.removeFromParentViewController()
        }else{
            //转场取消，移除 toVC 和 toView。
            self.privateToViewController.didMoveToParentViewController(privateContainerViewController)
            self.privateToViewController.willMoveToParentViewController(nil)
            self.privateToViewController.view.removeFromSuperview()
            self.privateToViewController.removeFromParentViewController()
        }
        //非协议方法，处理收尾工作：如果动画控制器实现了 animationEnded: 方法则执行；如果转场取消了则恢复数据。
        self.transitionEnd()
    }
}
</code></pre><p>在<code>SDEContainerViewController</code>类中，添加转场环境属性：</p>
<pre><code>private var containerTransitionContext: ContainerTransitionContext?
</code></pre><p>并修改<code>transitionViewControllerFromIndex:toIndex</code>方法实现自定义容器 VC 转场动画：</p>
<pre><code>private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int){
    if self.containerTransitionDelegate != nil{
        let fromVC = viewControllers![fromIndex]
        let toVC = viewControllers![toIndex]
        self.containerTransitionContext = ...//利用 fromVC 和 toVC 初始化。
        self.containerTransitionContext?.startNonInteractiveTransitionWith(containerTransitionDelegate!)
    }else{/*没有提供转场代理的话，则使用最初没有动画的转场代码，或者提供默认的转场动画*/}
}
</code></pre><p>这样我们就利用协议实现了自定义容器控制器的转场动画，可以使用第三方的动画控制器来实现不同的效果。</p>
<p>不过要注意这几个对象之间错综复杂的引用关系避免引用循环，关系图如下：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/Reference%20in%20Transition.png?raw=true" alt="Reference in Transition"></p>
<h4 id="Chapter5.2.3">交互控制</h4>

<p>交互控制器的协议<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>仅仅要求实现一个必须的方法:</p>
<pre><code>func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning)
</code></pre><p>根据文档的描述，该方法用于配置以及启动交互转场。我们前面使用的<code>UIPercentDrivenInteractiveTransition</code>类提供的更新进度的方法只是调用了转场环境对象的相关方法。所以，是转场环境对象替交互控制器把脏活累活干了，我们的实现还是维持这种关系好了。正如前面说的，「交互手段只是表现形式，本质是驱动转场进程」，让我们回到转场环境对象里实现对动画进度的控制吧。</p>
<p>怎么控制动画的进度？这个问题的本质是怎么实现对 UIView 的 <code>animateWithDuration:animations:completion:</code>这类方法生成的动画的控制。能够控制吗？能。</p>
<h5 id="Chapter5.2.3.1">动画控制和 CAMediaTiming 协议</h5>

<p>这个协议定义了一套时间系统，是控制动画进度的关键。UIView Animation 是使用 Core Animation 框架实现的，也就是使用 UIView 的 CALayer 对象实现的动画，而 CALayer 对象遵守该协议。</p>
<p>在交互控制器的小节里我打了一个比方，交互控制器就像一个视频播放器一样控制着转场动画这个视频的进度。依靠 CAMediaTiming 这套协议，我们可以在 CALayer 对象上对添加的动画实现控制。官方的实现很有可能也是采用了同样的手法。CAMediaTiming 协议中有以下几个属性：</p>
<pre><code>//speed 作用类似于播放器上控制加速/减速播放，默认为1，以正常速度播放动画，为0时，动画将暂停。
var speed: Float 
//修改 timeOffset 类似于拖动进度条，对一个2秒的动画，该属性为1的话，动画将跳到中间的部分。
//但当动画从中间播放到预定的末尾时，会续上0秒到1秒的动画部分。
var timeOffset: CFTimeInterval
//动画相对于父 layer 延迟开始的时间，这是一个实际作用比字面意义复杂的属性。 
var beginTime: CFTimeInterval  
</code></pre><p>Core Animation 的文档中提供了如何暂停和恢复动画的示例：<a href="https://developer.apple.com/library/ios/qa/qa1673/_index.html" target="_blank" rel="external">How to pause the animation of a layer tree</a>。我们将之利用实现对进度的控制，这种方法对其中的子视图上添加的动画也能够实现控制，这正是我们需要的。假设在 containerView 中的 toView 上执行一个简单的沿着 X 轴方向移动 100 单位的位移动画，由<code>executeAnimation()</code>方法执行。下面是使用手势控制该动画进度的核心代码：</p>
<pre><code>func handlePan(gesture: UIPanGestureRecognizer){
    switch gesture.state{
    case .Began:
        //开始动画前将 speed 设为0，然后执行动画，动画将停留在开始的时候。
        containerView.layer.speed = 0
        //在transitionContext里，这里替换为 animator.animateTransition(transitionContext)。
        executeAnimation() 
    case .Changed:
        let percent = ...
        //此时 speed 依然为0，调整 timeOffset 可以直接调整动画的整体进度，这里的进度控制以时间计算，而不是比例。
        containerView.layer.timeOffset = percent * duration
    case .Ended, .Cancelled:
        if progress &gt; 0.5{
            //恢复动画的运行不能简单地仅仅将 speed 恢复为1，这是一套比较复杂的机制。
            let pausedTime = view.layer.timeOffset
            containerView.layer.speed = 1.0 
            containerView.layer.timeOffset = 0.0
            containerView.layer.beginTime = 0.0
            let timeSincePause = view.layer.convertTime(CACurrentMediaTime(), fromLayer: nil) - pausedTime
            containerView.layer.beginTime = timeSincePause
        }else{/*逆转动画*/}
        default:break
    }
}
</code></pre><h5 id="Chapter5.2.3.2">取消转场</h5>

<p>交互控制动画时有可能被取消，这往往带来两个问题：恢复数据和逆转动画。</p>
<p>这里需要恢复的数据是<code>selectedIndex</code>，我们在交互转场开始前备份当前的<code>selectedIndex</code>，如果转场取消了就使用这个备份数据恢复。逆转动画反而看起来比较难以解决。</p>
<p>在上面的 pan 手势处理方法中，我们如何逆转动画的运行呢？既然<code>speed</code>为0时动画静止不动，调整为负数是否可以实现逆播放呢？不能，效果是视图消失不见。不过我们还可以调整<code>timeOffset</code>属性，从当前值一直恢复到0。问题是如何产生动画的效果？动画的本质是视图属性在某段时间内的连续变化，当然这个连续变化并不是绝对的连续，只要时间间隔够短，变化的效果就会流畅得看上去是连续变化，在这里让这个变化频率和屏幕的刷新同步即可，<code>CADisplayLink</code>可以帮助我们实现这点，它可以在屏幕刷新时的每一帧执行绑定的方法：</p>
<pre><code>//在上面的/*逆转动画*/处添加以下两行代码：
let displayLink = CADisplayLink(target: self, selector: &quot;reverseAnimation:&quot;)
displayLink.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode)

func reverseAnimation(displayLink: CADisplayLink){
    //displayLink.duration表示每一帧的持续时间，屏幕的刷新频率为60，duration = 1/60。
    //这行代码计算的是，屏幕刷新一帧后，timeOffset 应该回退一帧的时间。
    let timeOffset = view.layer.timeOffset - displayLink.duration
    if timeOffset &gt; 0{
        containerView.layer.timeOffset = timeOffset
    }else{
        //让 displayLink 失效，停止对当前方法的调用。
        displayLink.invalidate()
        //回到最初的状态。
        containerView.layer.timeOffset = 0
        //speed 恢复为1后，视图立刻跳转到动画的最终状态。
        containerView.layer.speed = 1
    }
}
</code></pre><p>最后一句代码会令人疑惑，为何让视图恢复为最终状态，与我们的初衷相悖。<code>speed</code>必须恢复为1，不然后续发起的转场动画无法顺利执行，视图也无法响应触摸事件，直接原因未知。但<code>speed</code>恢复为1后会出现一个问题：由于在原来的动画里 fromView 最终会被移出屏幕，尽管 Slide 动画控制器 UIView 动画里的 completion handle 里会恢复 fromView 和 toView 的状态，这种状态的突变会造成闪屏现象。怎么解决？添加一个假的 fromView 到 containerView替代已经被移出屏幕外的真正的 fromView，然后在很短的时间间隔后将之移除，因为此时 fromView 已经归位。在恢复<code>speed</code>后添加以下代码：</p>
<pre><code>let fakeFromView = privateFromViewController.view.snapshotViewAfterScreenUpdates(false)
containerView.addSubview(fakeFromView)
performSelector(&quot;removeFakeFromView:&quot;, withObject: fakeFromView, afterDelay: 1/60)
//在 Swift 中动态调用私有方法会出现无法识别的选择器错误，解决办法是将私有方法设置为与 objc 兼容，需要添加 @objc 修饰符。
@objc private func removeFakeFromView(fakeView: UIView){
    fakeView.removeFromSuperview()
}
</code></pre><p>经过试验，上面用来控制和取消 UIView 动画的方法也适用于用 Core Animation 实现的动画，毕竟 UIView 动画是用 Core Animation 实现的。不过，我们在前面提到过，官方对 Core Animation 实现的交互转场动画的支持有缺陷，估计官方鼓励使用更高级的接口吧，因为转场动画结束后需要调用<code>transitionContext.completeTransition(!isCancelled)</code>，而使用 Core Animation 完成这一步需要进行恰当的配置，实现的途径有两种且实现并不简单，相比之下 UIView 动画使用 completion block 对此进行了封装，使用非常方便。转场协议的结构已经比较复杂了，选择 UIView 动画能够显著降低实现成本。</p>
<p>上面的实现忽略了一个细节：时间曲线。逆转动画时每一帧都回退相同的时间，也就是说，逆转动画的时间曲线是线性的。交互控制器的协议<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>还有两个可选方法：</p>
<pre><code>optional func completionCurve() -&gt; UIViewAnimationCurve
optional func completionSpeed() -&gt; CGFloat
</code></pre><p>这两个方法记录了动画采用的动画曲线和速度，在逆转动画时如果能够根据这两者计算出当前帧应该回退的时间，那么就能实现完美的逆转，显然这是一个数学问题。恩，我们跳过这个细节吧，因为我数学不好，讨论这个问题很吃力。推荐阅读 Objc.io 的<a href="http://objccn.io/issue-12-6/" target="_blank" rel="external">交互式动画</a>一文，该文探讨了如何打造自然真实的交互式动画。</p>
<h5 id="Chapter5.2.3.3">最后的封装</h5>

<p>接下来要做的事情就是将上述代码封装在转场环境协议要求实现的三个方法里：</p>
<pre><code>func updateInteractiveTransition(percentComplete: CGFloat)
func finishInteractiveTransition()
func cancelInteractiveTransition()
</code></pre><p>正如系统打包的<code>UIPercentDrivenInteractiveTransition</code>类只是调用了 UIKit 提供的转场环境对象里的同名方法，我实现的<code>SDEPercentDrivenInteractiveTransition</code>类也采用了同样的方式调用我们实现的<code>ContainerTransitionContext</code>类的同名方法。</p>
<p>引入交互控制器后的转场引用关系图：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/Reference%20in%20Transition%20with%20Interactor.png?raw=true" alt="Reference in Transition with Interactor"></p>
<p>回到<code>SDEContainerViewController</code>类里修改转场过程的入口处：</p>
<pre><code>private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int){
    ...
    if containerTransitionDelegate != nil{
        let fromVC = viewControllers![fromIndex]
        let toVC = viewControllers![toIndex]
        self.containerTransitionContext = ...//利用 fromVC 和 toVC 初始化。
        //interactive 属性标记是否进入交互状态，由手势来更新该属性的状态。
        if interactive{
            priorSelectedIndex = fromIndex //备份数据，以备取消转场时使用。
            self.containerTransitionContext?.startInteractiveTranstionWith(containerTransitionDelegate!)
        }else{
            self.containerTransitionContext?.startNonInteractiveTransitionWith(containerTransitionDelegate!)
        }
    }else{/*没有提供转场代理的话，则使用最初没有动画的转场代码，或者提供默认的转场动画*/}
} 
</code></pre><p>实现手势控制的部分就如前面的交互控制器章节里的那样，完整的代码请看 Demo。</p>
<p>顺便说下 ButtonTabButton 在交互切换页面时的渐变色动画，这里我只是随着转场的进度更改了 Button 的字体颜色而已。那么当交互结束时如何继续剩下的动画或者取消渐变色动画呢，就像交互转场动画的那样。答案是<code>CADidplayLink</code>，前面我使用它在交互取消时逆转动画，这里使用了同样的手法。</p>
<p>关于转场协调器，文档表明在转场发生时<code>transitionCoordinator()</code>返回一个有效对象，但系统并不支持当前的转场方式，测试表明在当前的转场过程中这个方法返回的是 nil，需要重写该方法来提供。该对象只需要实现前面提到三个方法，其中在交互中止时执行绑定的闭包的方法可以通过通知机制来实现，有点困难的是两个与动画控制器同步执行动画的方法，其需要精准地与动画控制器中的动画保持同步，这两个方法都要接受一个遵守<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerTransitionCoordinatorContext_Protocol/index.html#//apple_ref/doc/uid/TP40013294" target="_blank" rel="external"><code>&lt;UIViewControllerTransitionCoordinatorContext&gt;</code></a>协议的参数，该协议与转场环境协议非常相似，这个对象可以由我们实现的转场环境对象来提供。不过既然现在由我们实现了转场环境对象，也就知道了执行动画的时机，提交并行的动画似乎并不是难事。这部分就留给读者来挑战了。</p>
<h2 id="Chapter6">尾声：转场动画的设计</h2>

<p>虽然我不是设计师，但还是想在结束之前聊一聊我对转场动画设计的看法。动画的使用无疑能够提升应用的体验，但仅限于使用了合适的动画。</p>
<p>除了一些加载动画可以炫酷华丽极尽炫技之能事，绝大部分的日常操作并不适合使用过于炫酷或复杂的动画，比如 <a href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller" target="_blank" rel="external">VCTransitionsLibrary</a> 这个库里的大部分效果。该库提供了多达10种转场效果，从技术上讲，大部分效果都是针对 transform 进行动画，如果你对这些感兴趣或是恰好有这方面的使用需求，可以学习这些效果的实现，从代码角度看，封装技巧也很值得学习，这个库是学习转场动画的极佳范例；不过从使用效果上看，这个库提供的效果像 PPT 里提供的动画效果一样，绝大部分都应该避免在日常操作中使用。不过作为开发者，我们应该知道技术实现的手段，即使这些效果并不适合在绝大部分场景中使用。</p>
<p>场景转换的目的是过渡到下一个场景，在操作频繁的日常场景中使用复杂的过场动画容易造成视觉疲劳，这种情景下使用简单的动画即可，实现起来非常简单，更多的工作往往是怎么把它们与其他特性更好地结合起来，正如 <a href="https://github.com/forkingdog/FDFullscreenPopGesture.git" target="_blank" rel="external">FDFullscreenPopGesture</a> 做的那样。除了日常操作，也会遇到一些特殊的场景需要定制复杂的转场动画，这种复杂除了动画效果本身的复杂，这需要掌握相应的动画手段，也可能涉及转场过程的配合，这需要对转场机制比较熟悉。比如 <a href="https://github.com/Yalantis/StarWars.iOS" target="_blank" rel="external">StarWars</a>，这个转场动画在视觉上极其惊艳，一出场便获得上千星星的青睐，它有贴合星战内涵的创意设计和惊艳的视觉表现，以及优秀的性能优化，如果要评选年度转场动画甚至是史上最佳，我会投票给它；而我在本文里实现的范例，从动画效果来讲，都是很简单的，可以预见本文无法吸引大众的转发，压轴环节里的自定义容器控制器转场也是如此，但是后者需要熟知转场机制才能实现。从这点来看，转场动画在实际使用中走向两个极端：日常场景中的转场动画十分简单，实现难度很低；特定场景的转场动画可能非常复杂，不过实现难度并不能一概而论，正如我在案例分析一节里指出的几个案例那样。</p>
<p>希望本文能帮助你。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：<a href="http://weibo.com/u/1815689155" target="_blank" rel="external">seedante</a>，神秘人士，他的 <a href="https://github.com/s]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="投稿" scheme="http://blog.devtang.com/tags/%E6%8A%95%E7%A8%BF/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（四） - map 和 flatMap]]></title>
    <link href="http://blog.devtang.com/2016/03/05/swift-gym-4-map-and-flatmap/"/>
    <id>http://blog.devtang.com/2016/03/05/swift-gym-4-map-and-flatmap/</id>
    <published>2016-03-05T12:15:34.000Z</published>
    <updated>2016-03-08T14:51:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/swift-brain-gym-map-and-flatmap" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第四节，练习前请做好准备运动，保持头脑清醒。</p>
<p>我之前一直以为我是懂 <code>map</code> 和 <code>flatMap</code> 的。但是直到我看到别人说：「一个实现了 <code>flatMap</code> 方法的类型其实就是 monad。」我又发现这个熟悉的东西变得陌生起来，本节烧脑体操打算更细致一些介绍 <code>map</code> 和 <code>flatMap</code>，为了下一节介绍 monad 做铺垫。</p>
<h2 id="u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6"><a href="#u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="准备运动：基础知识"></a>准备运动：基础知识</h2><p><img src="http://ww4.sinaimg.cn/mw690/65dc76a3gw1f0sz177142j20dk07bjsd.jpg" alt=""></p>
<h3 id="u6570_u7EC4_u4E2D_u7684_map__u548C_flatMap"><a href="#u6570_u7EC4_u4E2D_u7684_map__u548C_flatMap" class="headerlink" title="数组中的 map 和 flatMap"></a>数组中的 <code>map</code> 和 <code>flatMap</code></h3><p>数组中的 <code>map</code> 对数组元素进行某种规则的转换，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.map &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// brr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]</span><br></pre></td></tr></table></figure>
<p>而 <code>flatMap</code> 和 <code>map</code> 的差别在哪里呢？我们可以对比一下它们的定义。为了方便阅读，我在删掉了定义中的 <code>@noescape</code> 、<code>throws</code> 和 <code>rethrows</code> 关键字，如果你对这些关键字有疑问，可以查阅上一期的烧脑文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension SequenceType &#123;&#10;    public func map&#60;T&#62;(transform: (Self.Generator.Element) -&#62; T) &#10;         -&#62; [T]&#10;&#125;&#10;&#10;extension SequenceType &#123;&#10;    public func flatMap&#60;S : SequenceType&#62;(transform: (Self.Generator.Element) -&#62; S) &#10;         -&#62; [S.Generator.Element]&#10;&#125;&#10;&#10;extension SequenceType &#123;&#10;    public func flatMap&#60;T&#62;(transform: (Self.Generator.Element) -&#62; T?) &#10;         -&#62; [T]&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们从中可以发现，<code>map</code> 的定义只有一个，而 <code>flatMap</code> 的定义有两个重载的函数，这两个重载的函数都是接受一个闭包作为参数，返回一个数组。但是差别在于，闭包的定义不一样。</p>
<p>第一个函数闭包的定义是：<code>(Self.Generator.Element) -&gt; S</code>，并且这里 S 被定义成：<code>S : SequenceType</code>。所以它是接受数组元素，然后输出一个 <code>SequenceType</code> 类型的元素的闭包。有趣的是， <code>flatMap</code> 最终执行的结果并不是 <code>SequenceType</code> 的数组，而是 <code>SequenceType</code> 内部元素另外组成的数组，即：<code>[S.Generator.Element]</code>。</p>
<p>是不是有点晕？看看示例代码就比较清楚了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [[1, 2, 3], [6, 5, 4]]&#10;let brr = arr.flatMap &#123;&#10;    $0&#10;&#125;&#10;// brr = [1, 2, 3, 6, 5, 4]</span><br></pre></td></tr></table></figure>
<p>你看出来了吗？在这个例子中，数组 arr 调用 <code>flatMap</code> 时，元素<code>[1, 2, 3]</code> 和 <code>[6, 5, 4]</code> 分别被传入闭包中，又直接被作为结果返回。但是，最终的结果中，却是由这两个数组中的元素共同组成的新数组：<code>[1, 2, 3, 6, 5, 4]</code> 。</p>
<p>需要注意的是，其实整个 <code>flatMap</code> 方法可以拆解成两步：</p>
<ul>
<li>第一步像 <code>map</code> 方法那样，对元素进行某种规则的转换。</li>
<li>第二步，执行 <code>flatten</code> 方法，将数组中的元素一一取出来，组成一个新数组。</li>
</ul>
<p>所以，刚刚的代码其实等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [[1, 2, 3], [6, 5, 4]]&#10;let crr = Array(arr.map&#123; $0 &#125;.flatten())&#10;// crr = [1, 2, 3, 6, 5, 4]</span><br></pre></td></tr></table></figure>
<p>讲完了 <code>flatMap</code> 的第一种重载的函数，我们再来看第二种重载。</p>
<p>在第二种重载中，闭包的定义变成了：<code>(Self.Generator.Element) -&gt; T?</code>，返回值 T 不再像第一种重载中那样要求是数组了，而变成了一个 Optional 的任意类型。而 <code>flatMap</code> 最终输出的数组结果，其实不是这个 <code>T?</code> 类型，而是这个 <code>T?</code> 类型解包之后，不为 <code>.None</code> 的元数数组：<code>[T]</code>。</p>
<p>我们还是直接看代码吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr: [Int?] = [1, 2, nil, 4, nil, 5]&#10;let brr = arr.flatMap &#123; $0 &#125;&#10;// brr = [1, 2, 4, 5]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>flatMap</code> 将数组中的 nil 都丢弃掉了，只保留了非空的值。</p>
<p>在实际业务中，这样的例子还挺常见，比如你想构造一组图片，于是你使用 UIImage 的构造函数，但是这个函数可能会失败（比如图像的名字不存在时），所以返回的是一个 Optional 的 UIImage 对象。使用 <code>flatMap</code> 方法可以方便地将这些对象中为 .None 的都去除掉。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let images = (1...6).flatMap &#123;&#10;    UIImage(named: &#34;imageName-\($0)&#34;) &#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Optional__u4E2D_u7684_map__u548C_flatMap"><a href="#Optional__u4E2D_u7684_map__u548C_flatMap" class="headerlink" title="Optional 中的 map 和 flatMap"></a>Optional 中的 <code>map</code> 和 <code>flatMap</code></h3><p>其实 <code>map</code> 和 <code>flatMap</code> 不止存在于数组中，在 Optional 中也存在。我们先看看定义吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Optional&#60;Wrapped&#62; : _Reflectable, NilLiteralConvertible &#123;&#10;    case None&#10;    case Some(Wrapped)&#10;&#10;    public func map&#60;U&#62;( f: (Wrapped) throws -&#62; U) &#10;        rethrows -&#62; U?&#10;&#10;    public func flatMap&#60;U&#62;( f: (Wrapped) throws -&#62; U?) &#10;        rethrows -&#62; U?&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>所以，对于一个 Optional 的变量来说，<code>map</code> 方法允许它再次修改自己的值，并且不必关心自己是否为 <code>.None</code>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a1: Int? = 3&#10;let b1 = a1.map&#123; $0 * 2 &#125;&#10;// b1 = 6&#10;&#10;let a2: Int? = nil&#10;let b2 = a2.map&#123; $0 * 2 &#125;&#10;// b2 = nil</span><br></pre></td></tr></table></figure>
<p>再举一个例子，比如我们想把一个字符串转成 NSDate 实例，如果不用 <code>map</code> 方法，我们只能这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let date: NSDate? = NSDate()&#10;let formatter = NSDateFormatter()&#10;formatter.dateFormat = &#34;YYYY-MM-dd&#34;&#10;var formatted: String? = nil&#10;if let date = date &#123;&#10;    formatted = formatter.stringFromDate(date)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>而使用 <code>map</code> 函数后，代码变得更短，更易读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let date: NSDate? = NSDate()&#10;let formatter = NSDateFormatter()&#10;formatter.dateFormat = &#34;YYYY-MM-dd&#34;&#10;let formatted = date.map(formatter.stringFromDate)</span><br></pre></td></tr></table></figure>
<p>看出来特点了吗？当我们的输入是一个 Optional，同时我们需要在逻辑中处理这个 Optional 是否为 nil，那么就适合用 <code>map</code> 来替代原来的写法，使得代码更加简短。</p>
<p>那什么时候使用 Optional 的 <code>flatMap</code> 方法呢？答案是：当我们的闭包参数有可能返回 nil 的时候。</p>
<p>比如，我们希望将一个字符串转换成 Int，但是转换可能失败，这个时候我们就可以用 <code>flatMap</code> 方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s: String? = &#34;abc&#34;&#10;let v = s.flatMap &#123; (a: String) -&#62; Int? in&#10;    return Int(a)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我在这里还发现了更多的使用 <code>map</code> 和 <code>flatMap</code> 的例子，分享给大家：<a href="http://blog.xebia.com/the-power-of-map-and-flatmap-of-swift-optionals/" target="_blank" rel="external">http://blog.xebia.com/the-power-of-map-and-flatmap-of-swift-optionals/</a>。</p>
<h2 id="map__u548C_flatMap__u7684_u6E90_u7801"><a href="#map__u548C_flatMap__u7684_u6E90_u7801" class="headerlink" title="map 和 flatMap 的源码"></a><code>map</code> 和 <code>flatMap</code> 的源码</h2><p><img src="https://quotesaga.s3.amazonaws.com/quote/QS_be152af2851e4e4e8d5049b0d5cbaed9.jpg" alt=""></p>
<blockquote>
<p>Talk is cheap. Show me the code.</p>
<p>– Linus Torvalds</p>
</blockquote>
<p>为了更好地理解，我们去翻翻苹果开源的 Swift 代码，看看 <code>map</code> 和 <code>flatMap</code> 的实现吧。</p>
<h3 id="u6570_u7EC4_u7684_map__u7684_u6E90_u7801"><a href="#u6570_u7EC4_u7684_map__u7684_u6E90_u7801" class="headerlink" title="数组的 map 的源码"></a>数组的 <code>map</code> 的源码</h3><p>源码地址是：<a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift</a>，摘录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func map&#60;T&#62;(@noescape transform: (Generator.Element) throws -&#62; T)&#10;        rethrows -&#62; [T] &#123;&#10;    let count: Int = numericCast(self.count)&#10;    if count == 0 &#123;&#10;        return []&#10;    &#125;&#10;    &#10;    var result = ContiguousArray&#60;T&#62;()&#10;    result.reserveCapacity(count)&#10;    &#10;    var i = self.startIndex&#10;    &#10;    for _ in 0..&#60;count &#123;&#10;        result.append(try transform(self[i]))&#10;        i = i.successor()&#10;    &#125;&#10;    &#10;    _expectEnd(i, self)&#10;    return Array(result)&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6570_u7EC4_u7684_flatMap__u7684_u6E90_u7801_uFF08_u91CD_u8F7D_u51FD_u6570_u4E00_uFF09"><a href="#u6570_u7EC4_u7684_flatMap__u7684_u6E90_u7801_uFF08_u91CD_u8F7D_u51FD_u6570_u4E00_uFF09" class="headerlink" title="数组的 flatMap 的源码（重载函数一）"></a>数组的 <code>flatMap</code> 的源码（重载函数一）</h3><p>刚刚也说到，数组的 <code>flatMap</code> 有两个重载的函数。我们先看第一个的函数实现。源码地址是：<a href="https://github.com/apple/swift/blob/master/stdlib/public/core/SequenceAlgorithms.swift.gyb" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/SequenceAlgorithms.swift.gyb</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;public func flatMap&#60;S : SequenceType&#62;(&#10;        transform: ($&#123;GElement&#125;) throws -&#62; S&#10;    ) rethrows -&#62; [S.$&#123;GElement&#125;] &#123;&#10;        var result: [S.$&#123;GElement&#125;] = []&#10;        for element in self &#123;&#10;            result.appendContentsOf(try transform(element))&#10;        &#125;&#10;        return result&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>对于这个代码，我们可以看出，它做了以下几件事情：</p>
<ol>
<li>构造一个名为 <code>result</code> 的新数组，用于存放结果。</li>
<li>遍历自己的元素，对于每个元素，调用闭包的转换函数 <code>transform</code>，进行转换。</li>
<li>将转换的结果，使用 <code>appendContentsOf</code> 方法，将结果放入 <code>result</code> 数组中。</li>
</ol>
<p>而这个 <code>appendContentsOf</code> 方法，即是把数组中的元素取出来，放入新数组。以下是一个简单示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr = [1, 3, 2]&#10;arr.appendContentsOf([4, 5])&#10;// arr = [1, 3, 2, 4, 5]</span><br></pre></td></tr></table></figure>
<p>所以这种 <code>flatMap</code> 必须要求 <code>transform</code> 函数返回的是一个 <code>SequenceType</code> 类型，因为 <code>appendContentsOf</code> 方法需要的是一个 <code>SequenceType</code> 类型的参数。</p>
<h3 id="u6570_u7EC4_u7684_flatMap__u7684_u6E90_u7801_uFF08_u91CD_u8F7D_u51FD_u6570_u4E8C_uFF09"><a href="#u6570_u7EC4_u7684_flatMap__u7684_u6E90_u7801_uFF08_u91CD_u8F7D_u51FD_u6570_u4E8C_uFF09" class="headerlink" title="数组的 flatMap 的源码（重载函数二）"></a>数组的 <code>flatMap</code> 的源码（重载函数二）</h3><p>当我们的闭包参数返回的类型不是 <code>SequenceType</code> 时，就会匹配上第二个重载的 <code>flatMap</code> 函数。以下是函数的源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func flatMap&#60;T&#62;(&#10;    @noescape transform: ($&#123;GElement&#125;) throws -&#62; T?&#10;    ) rethrows -&#62; [T] &#123;&#10;        var result: [T] = []&#10;        for element in self &#123;&#10;            if let newElement = try transform(element) &#123;&#10;                result.append(newElement)&#10;            &#125;&#10;        &#125;&#10;        return result&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们也用同样的方式，把该函数的逻辑理一下：</p>
<ol>
<li>构造一个名为 <code>result</code> 的新数组，用于存放结果。(和另一个重载函数完全一样)</li>
<li>遍历自己的元素，对于每个元素，调用闭包的转换函数 <code>transform</code>，进行转换。(和另一个重载函数完全一样)</li>
<li>将转换的结果，判断结果是否是 nil，如果不是，使用使用 <code>append</code> 方法，将结果放入 <code>result</code> 数组中。（唯一差别的地方）</li>
</ol>
<p>所以，该 <code>flatMap</code> 函数可以过滤闭包执行结果为 nil 的情况，仅收集那些转换后非空的结果。</p>
<p>对于这种重载的 <code>flatMap</code> 函数，它和 <code>map</code> 函数的逻辑非常相似，仅仅多做了一个判断是否为 nil 的逻辑。</p>
<p>所以，面试题来了：「什么情况下数组的 <code>map</code> 可以和 <code>flatMap</code> 等价替换？」</p>
<p>答案是：当 <code>map</code> 的闭包函数返回的结果不是 <code>SequenceType</code> 的时候。因为这样的话，<code>flatMap</code> 就会调到我们当前讨论的这种重载形式。而这种重载形式和 <code>map</code> 的差异就仅仅在于要不要判断结果为 nil。</p>
<p>下面是一个示例代码，可以看出：<code>brr</code> 和 <code>crr</code> 虽然分别使用 <code>map</code> 和 <code>flatMap</code> 生成，但是结果完全一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.map &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// brr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]&#10;&#10;let crr = arr.flatMap &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// crr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]</span><br></pre></td></tr></table></figure>
<h3 id="Optional__u7684_map__u548C_flatMap__u6E90_u7801"><a href="#Optional__u7684_map__u548C_flatMap__u6E90_u7801" class="headerlink" title="Optional 的 map 和 flatMap 源码"></a>Optional 的 <code>map</code> 和 <code>flatMap</code> 源码</h3><p>看完数组的实现，我们再来看看 Optional 中的相关实现。源码地址是：<a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift</a>，摘录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// If `self == nil`, returns `nil`.  &#10;/// Otherwise, returns `f(self!)`.&#10;public func map&#60;U&#62;(@noescape f: (Wrapped) throws -&#62; U) &#10;        rethrows -&#62; U? &#123;&#10;    switch self &#123;&#10;    case .Some(let y):&#10;        return .Some(try f(y))&#10;    case .None:&#10;        return .None&#10;    &#125;&#10;&#125;&#10;&#10;/// Returns `nil` if `self` is `nil`, &#10;/// `f(self!)` otherwise.&#10;@warn_unused_result&#10;public func flatMap&#60;U&#62;(@noescape f: (Wrapped) throws -&#62; U?) &#10;        rethrows -&#62; U? &#123;&#10;    switch self &#123;&#10;    case .Some(let y):&#10;        return try f(y)&#10;    case .None:&#10;        return .None&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Optional 的这两函数真的是惊人的相似，如果你只看两段函数的注释的话，甚至看不出这两个函数的差别。</p>
<p>这两函数实现的差别仅仅只有两处：</p>
<ol>
<li><code>f</code> 函数一个返回 <code>U</code>，另一个返回 <code>U?</code> 。</li>
<li>一个调用的结果直接返回，另一个会把结果放到 .Some 里面返回。</li>
</ol>
<p>两个函数最终都保证了返回结果是 Optional 的。只是将结果转换成 Optional 的位置不一样。</p>
<p>这就像我老婆给我说：「我喜欢这个东西，你送给我吗？不送的话我就直接刷你卡买了！」。。。买东西的结果本质上是一样的，谁付钱本质上也是一样的，差别只是谁动手而已。</p>
<p>既然 Optional 的 <code>map</code> 和 <code>flatMap</code> 本质上是一样的，为什么要搞两种形式呢？这其实是为了调用者更方便而设计的。调用者提供的闭包函数，既可以返回 Optional 的结果，也可以返回非 Optional 的结果。对于后者，使用 <code>map</code> 方法，即可以将结果继续转换成 Optional 的。结果是 Optional 的意味着我们可以继续链式调用，也更方便我们处理错误。</p>
<p>我们来看一段略烧脑的代码，它使用了 Optional 的 <code>flatMap</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 4]&#10;let res = arr.first.flatMap &#123;&#10;    arr.reduce($0, combine: max)&#10;&#125;&#10;`</span><br></pre></td></tr></table></figure>
<p>这段代码的功能是：计算出数组中的元素最大值，按理说，求最大值直接使用 <code>reduce</code> 方法就可以了。不过有一种特殊情况需要考虑：即数组中的元素个数为 0 的情况，在这种情况下，没有最大值。</p>
<p>我们使用 Optional 的 <code>flatMap</code> 方法来处理了这种情况。arr 的 <code>first</code> 方法返回的结果是 Optional 的，当数组为空的时候，<code>first</code> 方法返回 .None，所以，这段代码可以处理数组元素个数为 0 的情况了。</p>
<h2 id="u70E7_u8111_u7684_map__u548C_flatMap"><a href="#u70E7_u8111_u7684_map__u548C_flatMap" class="headerlink" title="烧脑的 map 和 flatMap"></a>烧脑的 <code>map</code> 和 <code>flatMap</code></h2><h3 id="u5173_u4E8E_u53D6_u540D"><a href="#u5173_u4E8E_u53D6_u540D" class="headerlink" title="关于取名"></a>关于取名</h3><p><img src="http://ww1.sinaimg.cn/large/65dc76a3gw1f0sygrb8chj20c606egmg.jpg" alt=""></p>
<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.</p>
<p>– Phil Karlton</p>
</blockquote>
<p>有一位大师说，计算机世界真正称得上难题的就只有两个：第一个是缓存过期问题，第二个就是取名字。作为文章最后的烧脑环节，我们来聊聊取名字这个事吧。</p>
<p>我来提几个看起来「无厘头」的问题：</p>
<ul>
<li>数组的 <code>map</code> 函数和 Optinal 的 <code>map</code> 函数的实现差别巨大？但是为什么都叫 <code>map</code> 这个名字？</li>
<li>数组的 <code>flatMap</code> 函数和 Optinal 的 <code>flatMap</code> 函数的实现差别巨大？但是为什么都叫 <code>flatMap</code> 这个名字？</li>
<li>数组的 <code>flatMap</code> 有两个重载的函数，两个重载的函数差别巨大，但是为什么都叫 <code>flatMap</code> 这个名字？</li>
</ul>
<p>在我看来，这样的取名其实都是有背后的原因的，我试着分享一下我的理解。我们先说结论，然后再解释。这段结论来自：<a href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" target="_blank" rel="external">http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/</a>。</p>
<ul>
<li>数组和 Optional 的 <code>map</code> 函数都叫一样的名字，是因为它们都是 <a href="https://en.wikipedia.org/wiki/Functor" target="_blank" rel="external">Functor</a>。</li>
<li>数组和 Optinal 的 <code>flatMap</code> 函数都叫一样的名字，是因为它们都是 <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="external">Monad</a>)。</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/large/65dc76a3gw1f0scj26hf9j205805k3yk.jpg" alt=""></p>
<p>好吧，我猜你心里开始骂娘了：「为了解释一个问题，引入了两个新问题：谁知道什么是 Functor 和 Monad ！」</p>
<p>不要着急，我们先说严谨的结论有助于更好地总结和归纳，我下面试着解释一下 Functor 和 Monad 。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><p>Functor 在 <a href="https://en.wikipedia.org/wiki/Functor" target="_blank" rel="external">Wikipedia</a> 上的定义非常学术。我想了一个相对比较容易理解的定义：所谓的 Functor，就是可以把一个函数应用于一个「封装过的值」上，得到一个新的「封装过的值」。通常情况下，我们会把这个函数叫做 <code>map</code>。</p>
<p>什么叫做「封装过的值」呢？数组就是对值的一种封装，Optional 也是对值的一种封装。如果你愿意，你也可以自己封装一些值，比如把网络请求的结果和网络异常封装在一起，做成一个 enum（如下所示）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Result&#60;T&#62; &#123;&#10;    case Success(T)&#10;    case Failure(ErrorType)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>一个值能否成为「封装过的值」，取决于这个值的类型所表示的集合，通过 <code>map</code> 函数，能否映射到一个新集合中。这个新集合，也要求能够继续使用 <code>map</code> 函数，再映射到另外一个集合。</p>
<p>我们拿数组和 Optional 类型来检查这个规则，就会发现是符合的：</p>
<ul>
<li>数组可以通过 <code>map</code> 函数，生成一个新的数组，新的数组可以继续使用 <code>map</code> 函数。</li>
<li>Optional 可以通过 <code>map</code> 函数，生成一个新的 Optional 变量，新的 Optional 变量可以继续使用 <code>map</code> 函数。</li>
</ul>
<p>所以，数组 和 Optional 都是 Functor。</p>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p>如果你能理解 <a href="https://en.wikipedia.org/wiki/Functor" target="_blank" rel="external">Functor</a>，那么 <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="external">Monad</a>) 就相对容易一些了。所谓的 Monad，和 Functor 一样，也是把一个函数应用于一个「封装过的值」上，得到一个新的「封装过的值」。不过差别在于:</p>
<ul>
<li>Functor 的函数定义是从「未封装的值」到「未封装的值」的</li>
<li>Monad   的函数定义是从「未封装的值」到「封装后的值」的。</li>
</ul>
<p>下面我举例解释一下：</p>
<p>刚刚我们说，数组 和 Optional 都是 Functor，因为它们支持用 <code>map</code> 函数做「封装过的值」所在集合的变换。那么，你注意到了吗？map 函数的定义中，输入的参数和返回的结果，都不是「封装过的值」，而是「未封装的值」。什么是「未封装的值」？</p>
<ul>
<li>对于数组来说，「未封装的值」是数组里面一个一个的元素，map 函数的闭包接受的是一个一个的元素，返回的也是一个一个的元素。</li>
<li>对于 Optional 来说，「未封装的值」是 Optional 解包出来的值，map 函数的闭包接受的是解包出来的值，返回的也是解包出来的值。</li>
</ul>
<p>下面是数组的示例代码，我故意加上了闭包的参数，我们再观察一下。我们可以发现，<code>map</code> 的闭包接受的是 Int 类型，返回的是 String 类型，都是一个一个的元素类型，而不是数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// map &#30340;&#38381;&#21253;&#25509;&#21463;&#30340;&#26159; Int &#31867;&#22411;&#65292;&#36820;&#22238;&#30340;&#26159; String &#31867;&#22411;&#65292;&#37117;&#26159;&#19968;&#20010;&#19968;&#20010;&#30340;&#20803;&#32032;&#31867;&#22411;&#65292;&#32780;&#19981;&#26159;&#25968;&#32452;&#12290;&#10;let arr = [1, 2, 4]&#10;let brr = arr.map &#123;&#10;    (element: Int) -&#62; String in&#10;    &#34;No.&#34; + String(element)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 Optional 的示例代码，我也故意加上了闭包的参数。我们可以发现，<code>map</code> 的闭包接受的是 Int 类型，返回的是 Int 类型，都是非 Optional 的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// map &#30340;&#38381;&#21253;&#25509;&#21463;&#30340;&#26159; Int &#31867;&#22411;&#65292;&#36820;&#22238;&#30340;&#26159; Int &#31867;&#22411;&#65292;&#37117;&#26159;&#38750; Optional &#30340;&#12290;&#10;let tq: Int? = 1&#10;tq.map &#123; (a: Int) -&#62; Int in&#10;    a * 2&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们刚刚说，对于 Monad 来说，它和 Functor 的差异实在太小，小到就只有闭包的参数类型不一样。数组实现了 <code>flatMap</code> ，它就是一种 Monad，下面我们就看看 <code>flatMap</code> 在数组中的函数定义，我们可以看出，闭包接受的是数组的元素，返回的是一个数组（封装后的值）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#38381;&#21253;&#25509;&#21463;&#30340;&#26159;&#25968;&#32452;&#30340;&#20803;&#32032;&#65292;&#36820;&#22238;&#30340;&#26159;&#19968;&#20010;&#25968;&#32452;&#65288;&#23553;&#35013;&#21518;&#30340;&#20540;&#65289;&#10;let arr = [1, 2, 3]&#10;let brr = arr.flatMap &#123;&#10;    (element:Int) -&#62; [Int] in&#10;    return [element * 2]&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 <code>flatMap</code> 在 Optional 中的定义，我们可以看出，闭包接受的是 Int 类型，返回的是一个 Optional（封装后的值）。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// &#38381;&#21253;&#25509;&#21463;&#30340;&#26159; Int &#31867;&#22411;&#65292;&#36820;&#22238;&#30340;&#26159;&#19968;&#20010; Optional&#65288;&#23553;&#35013;&#21518;&#30340;&#20540;&#65289;&#10;let tq: Int? = 1&#10;tq.flatMap &#123; (a: Int) -&#62; Int? in&#10;    if a % 2 == 0 &#123;&#10;        return a&#10;    &#125; else &#123;&#10;        return nil&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>所以本质上，<code>map</code> 和 <code>flatMap</code> 代表着一类行为，我们把这类行为叫做 Functor 和 Monad。它们的差异仅仅在于闭包函数的参数返回类型不一样。所以，我们才会把数组和 Optional 这两个差别很大的类型，都加上两个实现差别很大的函数，但是都取名叫 <code>map</code> 和 <code>flatMap</code>。</p>
<h3 id="u591A_u91CD_Optional"><a href="#u591A_u91CD_Optional" class="headerlink" title="多重 Optional"></a>多重 Optional</h3><p>我们在第一节烧脑文章中提到过多重 Optional，在使用 <code>map</code> 的时候不仔细，就会触发多重 Optional 的问题。比如下面这个代码，变量 <code>b</code> 因为是一个两层嵌套的 nil，所以 <code>if let</code> 失效了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tq: Int? = 1&#10;let b = tq.map &#123; (a: Int) -&#62; Int? in&#10;    if a % 2 == 0 &#123;&#10;        return a&#10;    &#125; else &#123;&#10;        return nil&#10;    &#125;&#10;&#125;&#10;if let _ = b &#123;&#10;    print(&#34;not nil&#34;)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法是把 <code>map</code> 换成 <code>flatMap</code> 即可。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>讨论完了，我们总结一下：</p>
<ul>
<li>数组和 Optional 都能支持 <code>map</code> 和 <code>flatMap</code> 函数。</li>
<li>数组的 <code>flatMap</code> 有两个重载的实现，一个实现等价于先 <code>map</code> 再 <code>flatten</code>，另一个实现用于去掉结果中的 nil。</li>
<li>通过阅读源码，我们更加深入理解了 <code>map</code> 和 <code>flatMap</code> 函数内部的机制。</li>
<li>我们讨论了 <code>map</code> 和 <code>flatMap</code> 的取名问题，最后得出：一个类型如果支持 <code>map</code>，则表示它是一个 <a href="https://en.wikipedia.org/wiki/Functor" target="_blank" rel="external">Functor</a>；一个类型如果支持 <code>flatMap</code>，则表示它是一个 <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="external">Monad</a>。</li>
<li>我们讨论了 <code>map</code> 中使用不当造成的多重 Optional 问题。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（三） - 高阶函数]]></title>
    <link href="http://blog.devtang.com/2016/02/27/swift-gym-3-higher-order-function/"/>
    <id>http://blog.devtang.com/2016/02/27/swift-gym-3-higher-order-function/</id>
    <published>2016-02-27T01:25:51.000Z</published>
    <updated>2016-02-27T15:28:05.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/swift-brain-gym-high-order-function" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第三节，练习前请做好准备运动，保持头脑清醒。</p>
<h2 id="u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6"><a href="#u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="准备运动：基础知识"></a>准备运动：基础知识</h2><p><img src="http://ww1.sinaimg.cn/mw690/65dc76a3gw1f0sz14hv65j20er08t0tz.jpg" alt=""></p>
<p>在上一节里面，我们其实已经涉及到了高阶函数了。在 <a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">Wikipedia</a> 中，是这么定义高阶函数（higher-order function）的，如果一个函数：</p>
<ul>
<li>接受一个或多个函数当作参数</li>
<li>把一个函数当作返回值</li>
</ul>
<p>那么这个函数就被称作高阶函数。下面是一个简单的排序的例子，在这个例子中，传进去的参数就是一个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numbers = [1, 4, 2, 3]&#10;let res = numbers.sort &#123;&#10;    $0 &#60; $1&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trailing_Closure_Syntax"><a href="#Trailing_Closure_Syntax" class="headerlink" title="Trailing Closure Syntax"></a>Trailing Closure Syntax</h3><p>上面的代码看着不像是函数作为参数存在，这是因为 Swift 的 Trailing Closure 特性。Swift 允许当函数的最后一个参数是闭包的时候，以紧跟 <code>{ }</code> 的形式，将最后一个闭包的内容附加在函数后面。</p>
<p>所以，以下两行代码是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#27491;&#24120;&#20889;&#27861;&#65292;&#20989;&#25968;&#26159;&#20316;&#20026; sort &#30340;&#21442;&#25968;&#10;arr.sort(&#123; $0 &#60; $1 &#125;)&#10;&#10;// Trailing Closure &#20889;&#27861;&#65292;&#26356;&#31616;&#27905;&#26126;&#20102;&#10;arr.sort &#123; $0 &#60; $1 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5E38_u89C1_u7528_u6CD5_u793A_u4F8B"><a href="#u5E38_u89C1_u7528_u6CD5_u793A_u4F8B" class="headerlink" title="常见用法示例"></a>常见用法示例</h2><p>高阶函数在 Swift 语言中有大量的使用场景，我们先来看一看常见的用法：</p>
<h3 id="u904D_u5386"><a href="#u904D_u5386" class="headerlink" title="遍历"></a>遍历</h3><p>我们可以用 <code>map</code> 方法来对数组元素进行某种规则的转换，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.map &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// brr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]</span><br></pre></td></tr></table></figure>
<h3 id="u6C42_u548C"><a href="#u6C42_u548C" class="headerlink" title="求和"></a>求和</h3><p>我们可以用 <code>reduce</code> 方法，来对数组元素进行某种规则的求和（不一定是加和）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.reduce(0) &#123;&#10;    (prevSum: Int, element: Int) in&#10;    return prevSum + element&#10;&#125;&#10;// brr = 7&#10;let crr = arr.reduce(&#34;&#34;) &#123;&#10;    if $0 == &#34;&#34; &#123;&#10;        return String($1)&#10;    &#125; else &#123;&#10;        return $0 + &#34; &#34; + String($1)&#10;    &#125;&#10;&#125;&#10;// crr = &#34;1 2 4&#34;</span><br></pre></td></tr></table></figure>
<h3 id="u7B5B_u9009"><a href="#u7B5B_u9009" class="headerlink" title="筛选"></a>筛选</h3><p>我们可以利用 <code>filter</code> 方法，来对数组元素进行某种规则的过滤，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.filter &#123;&#10;    $0 % 2 == 0&#10;&#125;&#10;// brr = [2, 4]</span><br></pre></td></tr></table></figure>
<h3 id="u904D_u5386-1"><a href="#u904D_u5386-1" class="headerlink" title="遍历"></a>遍历</h3><p>即使是以前最简单的遍历，我们也可以用高阶函数的写法，将遍历需要的操作，以函数参数的形式传入 <code>forEach</code> 方法中，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;arr.forEach &#123;&#10;    print($0)&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u70E7_u8111_u4F53_u64CD"><a href="#u70E7_u8111_u4F53_u64CD" class="headerlink" title="烧脑体操"></a>烧脑体操</h2><p>下面我们来看看高阶函数一些比较烧脑的细节。</p>
<h3 id="u7528_u9AD8_u9636_u51FD_u6570_u6765_u9690_u85CF_u79C1_u6709_u53D8_u91CF"><a href="#u7528_u9AD8_u9636_u51FD_u6570_u6765_u9690_u85CF_u79C1_u6709_u53D8_u91CF" class="headerlink" title="用高阶函数来隐藏私有变量"></a>用高阶函数来隐藏私有变量</h3><p>高阶函数使得代码逻辑可以用函数为主体来进行封装，下面我将详细解释一下这句话。</p>
<p>在面向对象的世界里，逻辑存在的基本单元是对象，每个对象代表着一个最小可复用模块。在对象的内部，由高内聚的成员变量和成员函数构成。这些函数相互调用，并且操作对象的内部成员变量，最终对外产生可预期的行为。</p>
<p>但是利用高阶函数，我们可以同样做到与对象类似的，高内聚的成员变量和成员函数，下面我就举一个具体的例子。</p>
<p>下面的代码中，我们用类的方式，实现了一个 <code>Clock</code> 类， <code>Clock</code> 类实现了一个 <code>getCount</code> 方法，每次调用的时候返回的值 <code>+1</code>。为了测试代码，我们定义了两个实例 c1 和 c2，它们都可以正常输出预期的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Clock &#123;&#10;    var count: Int = 0&#10;    func getCount() -&#62; Int &#123;&#10;        return ++count;&#10;    &#125;&#10;&#125;&#10;&#10;let c1 = Clock()&#10;c1.getCount() // &#24471;&#21040; 1&#10;c1.getCount() // &#24471;&#21040; 2&#10;let c2 = Clock()&#10;c2.getCount() // &#24471;&#21040; 1</span><br></pre></td></tr></table></figure>
<p>那么接下来，我们用高阶函数的方式，来做一下同样的事情。我们先看代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func getClock() -&#62; () -&#62; Int &#123;&#10;    var count: Int = 0&#10;    let getCount = &#123; () -&#62; Int in&#10;        ++count;&#10;    &#125;&#10;    return getCount&#10;&#125;&#10;&#10;let c1 = getClock()&#10;c1()  // &#24471;&#21040; 1&#10;c1()  // &#24471;&#21040; 2&#10;let c2 = getClock()&#10;c2()  // &#24471;&#21040; 1</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们这里定义了一个 <code>getClock</code> 函数，这个函数可以返回一个 <code>getCount</code> 函数。然后，不太一样的地方是，这个 <code>getCount</code> 函数持有了一个外部的变量 <code>count</code>。于是，这个函数也变得有了状态（或者你也可以说它有了 Side Effect）。每次调用这个函数的时候，返回的值都会变化。</p>
<p>另一方面，因为<code>count</code>变量是 <code>getClock</code> 这个高阶函数的内部变量，所以它并没有像全局变量一样使得封装性被打破。<code>getClock</code>函数仍然可以看作一个高内部的可复用模块，并且对外隐藏了实现细节。</p>
<p>所以，Swift 语言的高阶函数以及闭包可以 capture 外部变量的特性，使得代码逻辑可以以函数作为主体来进行封装，这将使得我们的代码组织更加灵活。</p>
<p>当然，如果滥用，这也会造成代码组织变得更加混乱。</p>
<h3 id="u9762_u8BD5_u9898"><a href="#u9762_u8BD5_u9898" class="headerlink" title="面试题"></a>面试题</h3><h4 id="u9898_u76EE_u4E00"><a href="#u9898_u76EE_u4E00" class="headerlink" title="题目一"></a>题目一</h4><p>另一个烧脑的故事是来自于一个朋友的面试题。在面试中，面试官要求他用数组的 <code>reduce</code> 方法实现 <code>map</code> 的功能。</p>
<p>这个题目实在是非常蛋疼，不过用来烧脑倒是不错，大家感兴趣的话可以先想想，再翻下面的参考答案。</p>
<h4 id="u9898_u76EE_u4E8C"><a href="#u9898_u76EE_u4E8C" class="headerlink" title="题目二"></a>题目二</h4><p>不过说回来，虽然题目一有些奇怪，但是它确实考查了对于高阶函数灵活使用以及对 <code>reduce</code> 方法的理解。大家还可以试试这些题目：</p>
<ul>
<li>问题一：用 <code>reduce</code> 方法找出数组中的最大值。</li>
<li>问题二：用 <code>reduce</code> 方法一次求出数组中奇数的和、以及偶数乘积。</li>
</ul>
<h4 id="u9898_u76EE_u4E09"><a href="#u9898_u76EE_u4E09" class="headerlink" title="题目三"></a>题目三</h4><p>高阶函数另一个魔力就是可以链式调用，大家可以尝试这么一道题目：求一个数组中偶数的平方和。</p>
<h3 id="u53C2_u8003_u7B54_u6848"><a href="#u53C2_u8003_u7B54_u6848" class="headerlink" title="参考答案"></a>参考答案</h3><h4 id="u9898_u76EE_u4E00-1"><a href="#u9898_u76EE_u4E00-1" class="headerlink" title="题目一"></a>题目一</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 3, 2]&#10;let res = arr.reduce([]) &#123;&#10;    (a: [Int], element: Int) -&#62; [Int] in&#10;    var t = Array(a)&#10;    t.append(element * 2)&#10;    return t&#10;&#125;&#10;// res = [2, 6, 4]</span><br></pre></td></tr></table></figure>
<h4 id="u9898_u76EE_u4E8C-1"><a href="#u9898_u76EE_u4E8C-1" class="headerlink" title="题目二"></a>题目二</h4><p>问题二的参考答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 3, 2, 4]&#10;&#10;let res: (Int, Int) = arr.reduce((0, 1)) &#123;&#10;    (a :(Int, Int), element: Int) -&#62; (Int, Int) in&#10;    if element % 2 == 0 &#123;&#10;        return (a.0, a.1 * element)&#10;    &#125; else &#123;&#10;        return (a.0 + element, a.1)&#10;    &#125;&#10;&#125;&#10;// res = (4, 8)</span><br></pre></td></tr></table></figure>
<h4 id="u9898_u76EE_u4E09-1"><a href="#u9898_u76EE_u4E09-1" class="headerlink" title="题目三"></a>题目三</h4><p>以下是参考答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 3, 2, 4]&#10;let res = arr.filter &#123;&#10;        $0 % 2 == 0&#10;    &#125;.map &#123;&#10;        $0 * $0&#10;    &#125;.reduce(0) &#123;&#10;        $0 + $1&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结一下本次烧脑锻炼到的脑细胞：</p>
<ul>
<li>学习了 Swift 语言中的一些使用高阶函数的示例，包括 <code>map</code>, <code>reduce</code>, <code>filter</code> 等。</li>
<li>学习了利用高阶函数来构造以函数为主体的功能模块。</li>
<li>练习了一些奇怪的面试题。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（二） - 函数的参数]]></title>
    <link href="http://blog.devtang.com/2016/02/27/swift-gym-2-function-argument/"/>
    <id>http://blog.devtang.com/2016/02/27/swift-gym-2-function-argument/</id>
    <published>2016-02-27T01:23:29.000Z</published>
    <updated>2016-02-27T01:33:21.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/swift-brain-gym-arguments" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第二节，练习前请做好准备运动，保持头脑清醒。</p>
<h2 id="u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6"><a href="#u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="准备运动：基础知识"></a>准备运动：基础知识</h2><p><img src="http://ww3.sinaimg.cn/mw690/65dc76a3gw1f0sz14p1u4j206w0a33zb.jpg" alt=""></p>
<h3 id="u9762_u5411_u5BF9_u8C61_u8BED_u8A00_u7684_u4E16_u754C_u89C2"><a href="#u9762_u5411_u5BF9_u8C61_u8BED_u8A00_u7684_u4E16_u754C_u89C2" class="headerlink" title="面向对象语言的世界观"></a>面向对象语言的世界观</h3><p>对于很多面向对象的编程语言来说，在思考问题时，总是把「对象」作为考虑问题的基本出发点。</p>
<p>面向对象的程序设计通过以下三大规则，构建出程序设计的基础，它们是：</p>
<ol>
<li>封装（Encapsulation），将一个相对独立的逻辑涉及的变量和函数放到一个类中，然后对外暴露少量接口，使其高内聚，低耦合。</li>
<li>继承（Inheritance），子类可以继承父类的变量和函数，并且可以修改或扩展父类的行为。</li>
<li>多态（Polymorphism），父类的指针可以指向子类的实例，在运行时程序语言支持找到子类对应的函数实现。</li>
</ol>
<p>在以上三大准则的基础上，再引入一些设计原则，比如：</p>
<ol>
<li>单一职责原则（Single Responsibility），每个类只应该做一件事情。</li>
<li>不要重复原则（Don’t Repeat Yourself），相同（或相似）的代码不应该重复两次。</li>
<li>好的组合优于继承（Better Composition over Inheritance），尽量使用组合而不是继承来设计。</li>
</ol>
<p>于是，程序世界就基于这些规则和原则，产生出了设计模式，进而能更加精准地指导我们的编程行为。这就像我们学习几何，先学习几条公理，然后以后的大量定理都通过公理证明而来。</p>
<p>举个例子，单例模式（Singleton Pattern）其实就是封装和单一职责原则的产物。代理模式（Delegate Pattern) 也是单一职责和封装中的面向接口设计的思想的产物。</p>
<p>但是，在面向对象语言的世界观里面，函数都是作为一个附属物存在的。函数通常附属于一个具体类的某个方法中。或许有一个函数它根本都不需要任何对象作为容器，为了这个世界的统一，我们还是会构造一个类，把这个函数放进去。比如，在小猿搜题中，我们就有一个叫 ImageUtils 的类，里面放了操作图像的各种各样的静态方法，有一些图象操作函数其实也不太通用，但是总得找一个类放不是。</p>
<p>在一些面向对象语言的世界中，如果把对象称作 OOP 的一等公民的话，那么函数就是二等公民。</p>
<h3 id="u51FD_u6570_u5F0F_u7F16_u7A0B"><a href="#u51FD_u6570_u5F0F_u7F16_u7A0B" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>在 Swift 的世界中，函数并不是二等公民。是的，Swift 引入了大量函数式编程的特性，使得我们能够把函数当作一等公民来对待。</p>
<p>一等公民有什么权利呢？那就是函数可以像对象一样，被赋值、被当作参数传递、参与计算或者当作结果被返回。</p>
<p>我们先来看一段函数被赋值的例子，在下例中，我们将一个函数赋值给一个名为 <code>myFunc</code> 的变量，然后调用它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myFunc = &#123; &#10;    () -&#62; String in&#10;    return &#34;Tang Qiao&#34;&#10;&#125;&#10;&#10;let value = myFunc()&#10;// value &#30340;&#20540;&#20026; &#34;Tang Qiao&#34;</span><br></pre></td></tr></table></figure>
<p>我们再来看一个函数被当作运算结果返回的例子。在这个例子中，我们希望构造一个「加法器」工厂，这个工厂能够接受一个参数 addValue，返回一个加法器函数，这个加法器函数能够将传递的参数加 addValue 之后返回。以下是实现的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func addFactory(addValue: Int) -&#62; (Int -&#62; Int) &#123;&#10;    func adder(value: Int) -&#62; Int &#123;&#10;        return addValue + value&#10;    &#125;&#10;    return adder&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>有了上面这个函数，我们就可以构造一个 <code>+2</code> 的函数，然后使用它，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add2 = addFactory(2) // &#26500;&#36896;&#19968;&#20010; +2 &#30340;&#20989;&#25968;&#10;let result = add2(3) // &#36816;&#31639;&#65292;&#20256;&#20837; 3&#65292;&#24471;&#21040; 5</span><br></pre></td></tr></table></figure>
<h2 id="u51FD_u6570_u7684_u53C2_u6570"><a href="#u51FD_u6570_u7684_u53C2_u6570" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>但是在本次「烧脑体操」中，全面介绍函数式编程明显不太现实，所以我们仅从函数的参数来深入学习一下，看看在 Swift 语言中，函数的参数能够有多复杂。</p>
<!--
这里多说一句题外话，有部分同学看了「烧脑体操」第一节后，留言说：本来简单的 Swift 语言，被你这么一说，弄得都不敢学了，你是不是在吓大家？还有一些人留言：你搞这么绕还不是为了装逼？

对此，我想回答说：我研究这些仅仅是为了避免在语言细节的地方掉坑里，如果你对此不感兴趣，有一个动作叫做「取消关注」，我写文章并没有收费，如果你不喜欢，取关即可，犯不着在后台留言恶心我吧？
-->
<h3 id="u53C2_u6570_u7684_u7701_u7565"><a href="#u53C2_u6570_u7684_u7701_u7565" class="headerlink" title="参数的省略"></a>参数的省略</h3><p>我们先来简单看看函数参数的省略吧，因为有类型推导，函数的参数在 Swift 中常常可以被省略掉，特别以匿名函数（闭包）的形式存在的时候。</p>
<p>我们来看一个数组排序的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    (a: Int, b: Int) -&#62; Bool in&#10;    return a &#60; b&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个函数返回类型可以通过推导出来，则返回类型可以省略。所以以上代码中的 <code>-&gt; Bool</code> 可以删掉，变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    (a: Int, b: Int) in&#10;    return a &#60; b&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个函数的参数类型可以推导出来，则参数的类型可以省略。所以以上代码中的 <code>: Int</code> 可以删掉，变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    (a, b) in&#10;    return a &#60; b&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数参数的个数可以推导出来，也可以不写参数。那怎么使用这些参数呢？可以用 <code>$0</code>, <code>$1</code> 这样的方式来引用参数。所以以上代码中的 <code>(a, b)</code> 可以删掉，因为这样的话，参数和返回值都省略了，所以<code>in</code>也可以省略了，变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    return $0 &#60; $1&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 还有一个规则，如果函数的 body 只有一行，则可以把 <code>return</code> 关键字省略了，所以以上代码可以进一步简化成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    $0 &#60; $1&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个简化规则更加暴力，因为 <code>&lt;</code> 符号也是一个函数，它接受的参数个数，类型和返回值与 sort 函数需要的一样，所以可以直接简化成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort( &#60; )</span><br></pre></td></tr></table></figure>
<p>拿这个的方法，同样可以把我们刚刚写的 <code>addFactory</code> 做简化，最后简化成如下的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#31616;&#21270;&#21069;&#10;func addFactory(addValue: Int) -&#62; (Int -&#62; Int) &#123;&#10;    func adder(value: Int) -&#62; Int &#123;&#10;        return addValue + value&#10;    &#125;&#10;    return adder&#10;&#125;&#10;// &#31616;&#21270;&#21518;&#10;func addFactory(addValue: Int) -&#62; (Int -&#62; Int) &#123;&#10;    return &#123; addValue + $0 &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u51FD_u6570_u53C2_u6570_u4E2D_u7684_u5176_u5B83_u5173_u952E_u5B57"><a href="#u51FD_u6570_u53C2_u6570_u4E2D_u7684_u5176_u5B83_u5173_u952E_u5B57" class="headerlink" title="函数参数中的其它关键字"></a>函数参数中的其它关键字</h3><p>有些时候，我们的函数接受的参数就是另外一个函数，例如 sort，map，所以我们在看代码的时候，需要具备熟悉这种写法的能力。</p>
<p>我们来看看数组的 map 函数的定义吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func map&#60;T&#62;(@noescape transform: (Self.Generator.Element) throws -&#62; T) rethrows -&#62; [T]</span><br></pre></td></tr></table></figure>
<p>这个函数定义中出现了几个我们刚刚没提到的关键词，我们先学习一下。</p>
<h4 id="@noescape"><a href="#@noescape" class="headerlink" title="@noescape"></a><code>@noescape</code></h4><p><code>@noescape</code>，这是一个从 Swift 1.2 引入的关键字，它是专门用于修饰函数闭包这种参数类型的，当出现这个参数时，它表示该闭包不会跳出这个函数调用的生命期：即函数调用完之后，这个闭包的生命期也结束了。以下是苹果的文档原文：</p>
<blockquote>
<p>A new @noescape attribute may be used on closure parameters to functions. This indicates that the parameter is only ever called (or passed as an @noescape parameter in a call), which means that it cannot outlive the lifetime of the call. This enables some minor performance optimizations, but more importantly disables the self. requirement in closure arguments.</p>
</blockquote>
<p>什么情况下一个闭包参数会跳出函数的生命期呢？很简单，我们在函数实现内，将一个闭包用 <code>dispatch_async</code> 嵌套，这样这个闭包就会在另外一个线程中存在，从而跳出了当前函数的生命期。这样做主要是可以帮助编译器做性能的优化。</p>
<p>如果你对此感兴趣，这里有一些更详细的介绍供你学习：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/28427436/noescape-attribute-in-swift-1-2/28428521#28428521" target="_blank" rel="external">https://stackoverflow.com/questions/28427436/noescape-attribute-in-swift-1-2/28428521#28428521</a></li>
<li><a href="http://nshint.io/blog/2015/10/23/noescape-attribute/" target="_blank" rel="external">http://nshint.io/blog/2015/10/23/noescape-attribute/</a></li>
</ul>
<h4 id="throws__u548C_rethrows"><a href="#throws__u548C_rethrows" class="headerlink" title="throws 和 rethrows"></a><code>throws</code> 和 <code>rethrows</code></h4><p><code>throws</code> 关键字表示：这个函数（闭包）可能抛出异常。而 <code>rethrows</code> 关键字表示：这个函数如果抛出异常，仅可能是因为传递给它的闭包的调用导致了异常。</p>
<p><code>throws</code> 关键字的存在大家都应该能理解，因为总有一些异常可能在设计的时候希望暴露给上层，<code>throws</code> 关键字的存在使得这种设计成为可能。</p>
<p>那么为什么会有 <code>rethrows</code> 关键字呢？在我看来，这是为了简化很多代码的书写。因为一旦一个函数会抛出异常，按 Swift 类型安全的写法，我们就需要使用 try 语法。但是如果很多地方都需要写 try 的话，会造成代码非常啰嗦。 <code>rethrows</code> 关键字使得一些情况下，如果你传进去的闭包不会抛出异常，那么你的调用代码就不需要写 try。</p>
<p>如果你对此感兴趣，这里有一些更详细的介绍供你学习：</p>
<ul>
<li><a href="http://robnapier.net/re-throws" target="_blank" rel="external">http://robnapier.net/re-throws</a></li>
</ul>
<h3 id="u51FD_u6570_u4F5C_u4E3A_u51FD_u6570_u7684_u53C2_u6570"><a href="#u51FD_u6570_u4F5C_u4E3A_u51FD_u6570_u7684_u53C2_u6570" class="headerlink" title="函数作为函数的参数"></a>函数作为函数的参数</h3><p>刚刚说到，函数作为一等公民，意味着函数可以像对象一样，被当作参数传递或者被当作值返回。对此，我们专门有一个名称来称呼它，叫做<a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">高阶函数（higher-order function）</a>。</p>
<p>在刚刚那个数组的 map 函数中，我们就看到了它接着另外一个函数作为参数，这个函数接受数组元素类型作为参数，返回一个新类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func map&#60;T&#62;(@noescape transform: (Self.Generator.Element) throws -&#62; T) rethrows -&#62; [T]</span><br></pre></td></tr></table></figure>
<p>有了 map 函数，我们就可以轻松做数组元素的变换了。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.map &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// brr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]</span><br></pre></td></tr></table></figure>
<h2 id="u70E7_u8111_u7684_u53C2_u6570"><a href="#u70E7_u8111_u7684_u53C2_u6570" class="headerlink" title="烧脑的参数"></a>烧脑的参数</h2><p>好了，现在进入参数烧脑游戏的正式环节。</p>
<p>我们需要构造一个工厂函数，这个函数接受两个函数作为参数，返回一个新的函数。新函数是两个函数参数的叠加作用效果。</p>
<p>举一个具体的例子，假如我们有一个 <code>+2</code> 的函数，有一个 <code>+3</code> 的函数，那用这个工厂函数，我们可以得到一个 <code>+5</code> 的函数。</p>
<p>又比如我们有一个 <code>*2</code> 的函数，有一个 <code>*5</code> 的函数，用这个工厂函数，我们就可以得到一个 <code>*10</code> 的函数。</p>
<p>那这个函数如何写呢？我们先看答案吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func funcBuild(f: Int -&#62; Int, _ g: Int -&#62; Int) &#10;    -&#62; Int -&#62; Int &#123;&#10;    return &#123;&#10;        f(g($0))&#10;    &#125;&#10;&#125;&#10;&#10;let f1 = funcBuild(&#123;$0 + 2&#125;, &#123;$0 + 3&#125;)&#10;f1(0) // &#24471;&#21040; 5&#10;let f2 = funcBuild(&#123;$0 * 2&#125;, &#123;$0 * 5&#125;)&#10;f2(1) // &#24471;&#21040; 10</span><br></pre></td></tr></table></figure>
<p>这个函数充分反映了函数作为一等公民的地位。但是，我们同时也看出来，函数作为参数存在时，对于程序的可读性带来了挑战。好在我们有 <code>typealias</code>，通过 <code>typealias</code>，我们可以将函数的类型写得更加易读，比如上面的代码，就可以修改成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typealias IntFunction = Int -&#62; Int&#10;&#10;func funcBuild(f: IntFunction, _ g: IntFunction)&#10;    -&#62; IntFunction &#123;&#10;    return &#123;&#10;        f(g($0))&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>现在看看代码，是不是清晰了很多？</p>
<h2 id="u53C2_u6570_u4E2D_u7684_u8303_u578B"><a href="#u53C2_u6570_u4E2D_u7684_u8303_u578B" class="headerlink" title="参数中的范型"></a>参数中的范型</h2><p>当函数中的参数再引入范型之后，函数的功能更加强大，但是可读性进一步下降。比如刚刚的例子，限制函数只能是 <code>Int -&gt; Int</code> 其实是没有必要的，我们将两个函数拼成一个函数，只需要保证一个函数的输出类型，与另一个函数的输入类型匹配即可。所以，刚刚的例子，可以进一步用范型改造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func funcBuild&#60;T, U, V&#62;(f: T -&#62; U, _ g: V -&#62; T)&#10;    -&#62; V -&#62; U &#123;&#10;        return &#123;&#10;            f(g($0))&#10;        &#125;&#10;&#125;&#10;let f3 = funcBuild(&#123; &#34;No.&#34; + String($0) &#125;, &#123;$0 * 2&#125;)&#10;f3(23) // &#32467;&#26524;&#26159; &#34;No.46&#34;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，我们保证函数 g 的输出类型是 T，函数 f 的输入类型是 T。这样，在例子中，我们将一个 <code>*2</code> 的函数与一个数字转字符串的函数拼接起来，构造出一个先乘 2，再转字符串的函数。</p>
<p>相应的例子还有很多，比如 WWDC 中就介绍过一个给函数增加缓存机制的代码，在该代码中，任意一个不带缓存功能的函数，经过改造，都可以变成一个带缓存功能的函数。代码如下，大家可以自行学习一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func memoize&#60;T: Hashable, U&#62;( body: (T)-&#62;U ) -&#62; (T-&#62;U) &#123;&#10;    var memo = Dictionary&#60;T, U&#62;()&#10;    return &#123; x in&#10;        if let q = memo[x] &#123; return q &#125;&#10;        let r = body(x)&#10;        memo[x] = r&#10;        return r&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结一下本次烧脑锻炼到的脑细胞：</p>
<ul>
<li>Swift 是一个结合面向对象编程和函数式编程特性的语言。</li>
<li>函数在 Swift 中是一等公民，可以被赋值、被当作参数传递、参与计算、当作结果被返回或被动态创建。</li>
<li>因为有类型推导，函数的参数有各种省略规则。</li>
<li>函数作为参数时，有 @noescape，throw 和 rethrow 关键字需要了解。</li>
<li>函数作为参数时，不易阅读。合理使用 typealias 可以使源码结构更清晰。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（一） - Optional 的嵌套]]></title>
    <link href="http://blog.devtang.com/2016/02/27/swift-gym-1-nested-optional/"/>
    <id>http://blog.devtang.com/2016/02/27/swift-gym-1-nested-optional/</id>
    <published>2016-02-27T01:21:32.000Z</published>
    <updated>2016-02-27T01:33:21.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/swift-brain-gym-optional" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第一节，练习前请做好准备运动，保持头脑清醒。</p>
<h2 id="u51C6_u5907_u8FD0_u52A8_uFF1AOptional__u7684_u4ECB_u7ECD"><a href="#u51C6_u5907_u8FD0_u52A8_uFF1AOptional__u7684_u4ECB_u7ECD" class="headerlink" title="准备运动：Optional 的介绍"></a>准备运动：Optional 的介绍</h2><p><img src="http://ww3.sinaimg.cn/mw690/65dc76a3gw1f0sz13edhpj209s061mxt.jpg" alt=""></p>
<p>王巍的《Swifter》(<a href="http://swifter.tips/buy" target="_blank" rel="external">http://swifter.tips/buy</a>)一书中，介绍了一个有用的命令：在 LLDB 中输入 <code>fr v -R foo</code>，可以查看 <code>foo</code> 这个变量的内存构成。我们稍后的分析将用到这个命令。</p>
<p>在 Swift 的世界里，一切皆对象，包括 Int Float 这些基本数据类型，所以我们可以这么写：<code>print(1.description)</code>。</p>
<p>而对象一般都是存储在指针中，Swift 也不例外，这就造成了一个问题，指针为空的情况需要处理。在 Objective-C 中，向一个 nil 的对象发消息是默认不产生任何效果的行为，但是在 Swift 中，这种行为被严格地禁止了。</p>
<p>Swift 是一个强类型语言，它希望在编译期做更多的安全检查，所以引入了类型推断。而类型推断上如果要做到足够的安全，避免空指针调用是一个最基本的要求。于是，Optional 这种类型出现了。Optional 在 Swift 语言中其实是一个枚举类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Optional&#60;Wrapped&#62; : _Reflectable, NilLiteralConvertible &#123;&#10;    case None&#10;    case Some(Wrapped)&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Optional__u7684_u5D4C_u5957"><a href="#Optional__u7684_u5D4C_u5957" class="headerlink" title="Optional 的嵌套"></a>Optional 的嵌套</h2><p>Optional 类型的变量，在使用时，大多需要用<code>if let</code>的方式来解包。如果你没有解包而直接使用，编辑器通过类型推断会提示你，所以看起来这套机制工作得很好。但是，如果 Optional 嵌套层次太多，就会造成一些麻烦，下面我们来看一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a: Int? = 1&#10;let b: Int?? = a&#10;let c: Int??? = b</span><br></pre></td></tr></table></figure>
<p>在这个机制中，1 这个 Int 值被层层 Optional 包裹，我们用刚刚提到的<code>fr v -R</code>，可以很好的看出来内部结构。如下图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) fr v -R a&#10;(Swift.Optional&#60;Swift.Int&#62;) a = Some &#123;&#10;  Some = &#123;&#10;    value = 1&#10;  &#125;&#10;&#125;&#10;&#10;(lldb) fr v -R b&#10;(Swift.Optional&#60;Swift.Optional&#60;Swift.Int&#62;&#62;) b = Some &#123;&#10;  Some = Some &#123;&#10;    Some = &#123;&#10;      value = 1&#10;    &#125;&#10;  &#125;&#10;&#125;&#10;&#10;(lldb) fr v -R c&#10;(Swift.Optional&#60;Swift.Optional&#60;Swift.Optional&#60;Swift.Int&#62;&#62;&#62;) c = Some &#123;&#10;  Some = Some &#123;&#10;    Some = Some &#123;&#10;      Some = &#123;&#10;        value = 1&#10;      &#125;&#10;    &#125;&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>从这个示例代码中，我们能看出来多层嵌套的 Optional 的具体内存结构。这个内存结构其实是一个类似二叉树一样的形状，如下图所示：</p>
<p><img src="http://ww3.sinaimg.cn/mw690/65dc76a3gw1f08i00trqpj20ji0ch3ze.jpg" alt=""></p>
<ul>
<li>第一层二叉树有两个可选的值，一个值是 .None，另一个值类型是 <code>Optional&lt;Optional&lt;Int&gt;&gt;</code>。</li>
<li>第二层二叉树有两个可选的值，一个值是 .None，另一个值类型是 <code>Optional&lt;Int&gt;</code>。</li>
<li>第三层二叉树有两个可选的值，一个值是 .None，另一个值类型是 <code>Int</code>。</li>
</ul>
<p>那么问题来了，看起来这个 Optional.None 可以出现在每一层，那么在每一层的效果一样吗？我做了如下实验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a: Int? = nil&#10;let b: Int?? = a&#10;let c: Int??? = b&#10;let d: Int??? = nil</span><br></pre></td></tr></table></figure>
<p>如果你在 playground 上看，它们的值都是 nil，但是它们的内存布局却不一样，特别是变量 c 和 变量 d：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) fr v -R a&#10;(Swift.Optional&#60;Swift.Int&#62;) a = None &#123;&#10;  Some = &#123;&#10;    value = 0&#10;  &#125;&#10;&#125;&#10;&#10;(lldb) fr v -R b&#10;(Swift.Optional&#60;Swift.Optional&#60;Swift.Int&#62;&#62;) b = Some &#123;&#10;  Some = None &#123;&#10;    Some = &#123;&#10;      value = 0&#10;    &#125;&#10;  &#125;&#10;&#125;&#10;&#10;(lldb) fr v -R c&#10;(Swift.Optional&#60;Swift.Optional&#60;Swift.Optional&#60;Swift.Int&#62;&#62;&#62;) c = Some &#123;&#10;  Some = Some &#123;&#10;    Some = None &#123;&#10;      Some = &#123;&#10;        value = 0&#10;      &#125;&#10;    &#125;&#10;  &#125;&#10;&#125;&#10;&#10;(lldb) fr v -R d&#10;(Swift.Optional&#60;Swift.Optional&#60;Swift.Optional&#60;Swift.Int&#62;&#62;&#62;) d = None &#123;&#10;  Some = Some &#123;&#10;    Some = Some &#123;&#10;      Some = &#123;&#10;        value = 0&#10;      &#125;&#10;    &#125;&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>变量 c 因为是多层嵌套的 nil，所以它在最外层的二叉树上的值，是一个 <code>Optional&lt;Optional&lt;Int&gt;&gt;</code>。</li>
<li>变量 d 因为是直接赋值成 nil，所以它在最外层的二叉树上的值，是一个 <code>Optional.None</code>。</li>
</ul>
<p>麻烦的事情来了，以上原因会造成用 if let 来判断变量 c 是否为 nil 失效了。如下代码最终会输出 <code>c is not none</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a: Int? = nil&#10;let b: Int?? = a&#10;let c: Int??? = b&#10;let d: Int??? = nil&#10;&#10;if let _ = c &#123;&#10;    print(&#34;c is not none&#34;)&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u89E3_u91CA"><a href="#u89E3_u91CA" class="headerlink" title="解释"></a>解释</h2><p>在我看来，这个问题的根源是：一个 Optional 类型的变量可以接受一个非 Optional 的值。拿上面的代码举例，a 的类型是 Int?，b 的类型是 Int??，但是 a 的值却可以赋值给 b。所以，变量 b（类型为 Int??），它可以接受以下几种类型的赋值：</p>
<ol>
<li>nil 类型</li>
<li>Int? 类型</li>
<li>Int?? 类型</li>
</ol>
<p>按理说，Swift 是强类型，等号左右两边的类型不完全一样，为什么能够赋值成功呢？我查了一下 Optional 的源码，原来是对于上面第 1，2 种类型不一样的情况，Optional 定义了构造函数来构造出一个 Int?? 类型的值，这样构造之后，等号左右两边就一样了。源码来自 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift</a>，我摘录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Optional&#60;Wrapped&#62; : _Reflectable, NilLiteralConvertible &#123;&#10;  case None&#10;  case Some(Wrapped)&#10;&#10;  @available(*, unavailable, renamed=&#34;Wrapped&#34;)&#10;  public typealias T = Wrapped&#10;&#10;  /// Construct a `nil` instance.&#10;  @_transparent&#10;  public init() &#123; self = .None &#125;&#10;&#10;  /// Construct a non-`nil` instance that stores `some`.&#10;  @_transparent&#10;  public init(_ some: Wrapped) &#123; self = .Some(some) &#125;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中，Optional 提供了两种构造函数，完成了刚刚提到的类型转换工作。</p>
<h2 id="u70E7_u8111_u4F53_u64CD"><a href="#u70E7_u8111_u4F53_u64CD" class="headerlink" title="烧脑体操"></a>烧脑体操</h2><p>好了，说了这么多，我们下面开始烧脑了，以下代码来自傅若愚（<a href="https://github.com/lingoer" target="_blank" rel="external">https://github.com/lingoer</a>）在不久前 Swift 大会（<a href="http://atswift.io/#speaker" target="_blank" rel="external">http://atswift.io/#speaker</a>）上的一段分享：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dict :[String:String?] = [:]&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;func justReturnNil() -&#62; String? &#123;&#10;    return nil&#10;&#125;&#10;dict[&#34;key&#34;] = justReturnNil()&#10;dict</span><br></pre></td></tr></table></figure>
<p>以下是代码执行结果：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hcnaidnj20vq06ugni.jpg" alt=""></p>
<p>我们可以看到，我们想通过给这个 Dictionary 设置一个 nil，来删除掉这个 key-value 对。但是从 playground 的执行结果上看，key 并没有被删掉。</p>
<p>为了测试到底设置什么样的值，才能正常地删掉这个 key-value 键值对，我做了如下实验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dict :[String:String?] = [:]&#10;// first try&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;dict[&#34;key&#34;] = Optional&#60;Optional&#60;String&#62;&#62;.None&#10;dict&#10;&#10;// second try&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;dict[&#34;key&#34;] = Optional&#60;String&#62;.None&#10;dict&#10;&#10;// third try&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;dict[&#34;key&#34;] = nil&#10;dict&#10;&#10;// forth try&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;let nilValue:String? = nil&#10;dict[&#34;key&#34;] = nilValue&#10;dict&#10;&#10;// fifth try&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;let nilValue2:String?? = nil&#10;dict[&#34;key&#34;] = nilValue2&#10;dict</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hcj57k0j20vk0lqjxf.jpg" alt=""></p>
<p>我们可以看到，以下三种方式可以成功删除 key-value 键值对：</p>
<ul>
<li><code>dict[&quot;key&quot;] = Optional&lt;Optional&lt;String&gt;&gt;.None</code></li>
<li><code>dict[&quot;key&quot;] = nil</code></li>
<li><code>let nilValue2:String?? = nil;  dict[&quot;key&quot;] = nilValue2</code></li>
</ul>
<p>所以，在这个烧脑之旅中，我们发现，一个 [String: String?] 的 Dictionary，可以接受以下类型的赋值：</p>
<ul>
<li>nil</li>
<li>String</li>
<li>String?</li>
<li>String??</li>
</ul>
<p>如果要删除这个 Dictionary 中的元素，必须传入 nil 或 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code> ，而如果传入 <code>Optional&lt;String&gt;.None</code>，则不能正常删除元素。</p>
<p>好吧，实验出现象了，那这种现象的原因是什么呢？</p>
<p>还好苹果把它的实现开源了，那我们来一起看看吧，源文件来自：<a href="https://github.com/apple/swift/blob/master/stdlib/public/core/HashedCollections.swift.gyb" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/HashedCollections.swift.gyb</a>，以下是关键代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public subscript(key: Key) -&#62; Value? &#123;&#10;  get &#123;&#10;    return _variantStorage.maybeGet(key)&#10;  &#125;&#10;  set(newValue) &#123;&#10;    if let x = newValue &#123;&#10;      // FIXME(performance): this loads and discards the old value.&#10;      _variantStorage.updateValue(x, forKey: key)&#10;    &#125;&#10;    else &#123;&#10;      // FIXME(performance): this loads and discards the old value.&#10;      removeValueForKey(key)&#10;    &#125;&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>所以，当 Dictionary 的 value 类型为 String 时，如果你要设置它的值，它接受的是一个 String? 类型的参数。而因为我们刚刚例子中的 value 类型为 String?，所以正常情况下它需要的是一个 String?? 类型的参数。在上面的失败的例子中，我们传递的是一个 String? 类型的值，具体值为 <code>Optional&lt;String&gt;.None</code>，于是在执行时就会按以下的步骤来进行：</p>
<ol>
<li>我们传递一个值为 <code>Optional&lt;String&gt;.None</code>，类型为 String? 的参数。</li>
<li>因为传的参数类型是 String?，而函数需要的是 String??，所以会执行 Optional 的构造函数，构造一个两层的 Optional。</li>
<li>这个两层 Optional 的值为 <code>Optional.Some(&lt;Optional&lt;String&gt;.None&gt;)</code></li>
<li>进入到 Dictionary 的实现时，会用 if let 进行是否为 nil 的判断，因为两层的 Optional，所以 if let 判断它不是 nil。</li>
<li>所以代码执行到 <code>_variantStorage.updateValue(x, forKey: key)</code>，把 Optional<string>.None 当成值，设置给了相应的 key。</string></li>
</ol>
<p>如果你没理解，可以再翻翻最初我们对多层嵌套 nil 变量的实验和分析。</p>
<p>我们再看看传递参数是 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code> 的情况，步骤如下：</p>
<ol>
<li>我们传递一个值为 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code>，类型为 String?? 的参数。</li>
<li>因为参数类型是 String??，函数需要的类型也是 String??，所以参数不经变换，直接进入函数调用中。</li>
<li>这个时候参数的值不变，还是 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code>。</li>
<li>进入到 Dictionary 的实现时，会用 if let 进行是否为 nil 的判断，<code>Optional&lt;Optional&lt;String&gt;&gt;.None</code> 用 if let 判断，得到它是 nil。</li>
<li>所以代码执行到 <code>removeValueForKey(key)</code>，Dictionary 删除了相应的 key-value 键值对。</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>好了，「烧脑体操」第一节就做完了，运动一下是不是感觉神清气爽？</p>
<p>总结一下本次烧脑锻炼到的脑细胞：</p>
<ul>
<li>Optional 可以多层嵌套。</li>
<li>因为 Optional 的构造函数支持，所以可以将一个类型为 T 的值，赋值给一个类型为 T? 的变量。</li>
<li>因为 Optional 的构造函数支持，所以可以将 nil 赋值给一个任意嵌套层数的 Optional 变量。</li>
<li>将 Optional 嵌套的内容是 nil 时，大家要小心 if let 操作失效问题。</li>
<li>多层 Optional 嵌套容易烧脑细胞，尽量避免在工程中使用或触发。</li>
<li>遇到问题可以翻翻苹果在 Github 开源的 <a href="https://github.com/apple/swift" target="_blank" rel="external">Swift 源码</a>。</li>
</ul>
<p>愿大家玩得开心！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从 Octopress 迁移到 Hexo]]></title>
    <link href="http://blog.devtang.com/2016/02/16/from-octopress-to-hexo/"/>
    <id>http://blog.devtang.com/2016/02/16/from-octopress-to-hexo/</id>
    <published>2016-02-16T11:05:46.000Z</published>
    <updated>2016-02-16T12:47:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5E8F_u8A00"><a href="#u5E8F_u8A00" class="headerlink" title="序言"></a>序言</h2><p>我的博客之前一直使用的是 <a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>，不过 Octopress 已经很久没有更新了。而且 Octopress 是基于 Ruby 的，生成博客文章的速度真的是非常非常慢，每次我使用 <code>rake preview</code> 命令时，我的 MacBook 的 CPU 就会狂转。最新的一次我试图在新 MBP 上搭建 Octopress 博客环境失败了，这让我打定主意更换掉它。</p>
<p>之后我调研了一下，最终决定迁移到 Hexo，主要的原因是：</p>
<ul>
<li>Hexo 的原理和 Octopress 一样，都是生成静态文件，这样可以方便地托管到 GitHub 和 GitCafe 上。</li>
<li>Hexo 是基于 Node 的，而 Node 的速度非常快。</li>
<li>Hexo 对 Octopress 的迁移很友好，图片引用方式完全一样，所以我的博客文章不需要做什么改动。</li>
</ul>
<p>迁移本来应该在春节前就做完的，不过我在选择 Hexo 的主题上犯难了，Hexo 自带的主题丑极了，而我试了将近 10 个主题，都不满意。最终，我发现了 <a href="http://swift.gg/" target="_blank" rel="external">SwiftGG</a> 使用的主题 <a href="https://github.com/wuchong/jacman" target="_blank" rel="external">Jacman</a>，于是决定就它了！</p>
<p>整个迁移过程大概如下：</p>
<h2 id="u5B89_u88C5_Hexo"><a href="#u5B89_u88C5_Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>首先使用如下命令安装 Hexo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h2 id="u521B_u5EFA_u4E00_u4E2A_u65B0_u7684_u535A_u5BA2"><a href="#u521B_u5EFA_u4E00_u4E2A_u65B0_u7684_u535A_u5BA2" class="headerlink" title="创建一个新的博客"></a>创建一个新的博客</h2><p>接着我们创建一个新的博客目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &#60;folder&#62;&#10;$ cd &#60;folder&#62;&#10;$ npm install</span><br></pre></td></tr></table></figure>
<p>以上命令完成后，会在目标目录生成以下的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; _config.yml&#10;&#9500;&#9472;&#9472; package.json&#10;&#9500;&#9472;&#9472; scaffolds&#10;&#9500;&#9472;&#9472; source&#10;|   &#9500;&#9472;&#9472; _drafts&#10;|   &#9492;&#9472;&#9472; _posts&#10;&#9492;&#9472;&#9472; themes</span><br></pre></td></tr></table></figure>
<p>相比 Octopress，Hexo 的目录结构更加简单：</p>
<ul>
<li>_config.yml 是博客的配置文件。</li>
<li>scaffolds 是博客文章模板。</li>
<li>source 是博客文章目录。</li>
<li>themes 存放主题风格文件。</li>
</ul>
<h2 id="u8FC1_u79FB_u548C_u914D_u7F6E"><a href="#u8FC1_u79FB_u548C_u914D_u7F6E" class="headerlink" title="迁移和配置"></a>迁移和配置</h2><p>迁移起来还是很方便，把以前 Octopress 的 <code>source/_post</code> 目录下的文章，拷贝到 Hexo 的同名目录下即可。</p>
<p>以前的图片目录，也可以直接拷贝到 <code>source/images</code> 目录下。</p>
<p>Google 统计相关的设置可以在 jacman 的 _config.yml 文件中配置。我以前用的评论系统太旧了，这次正好换成了<a href="http://tangqiaoboy.duoshuo.com/" target="_blank" rel="external">多说</a>，同样也是在 jacman 的配置文件中设置。</p>
<h2 id="u4FEE_u6539_u754C_u9762"><a href="#u4FEE_u6539_u754C_u9762" class="headerlink" title="修改界面"></a>修改界面</h2><p>选择 Hexo 的另一个原因就是它的结构很简单，比较方便我定制。我在迁移完博客文章后，对 jacman 主题进行了一些定制。删掉了底部的作者介绍，然后在右侧边栏加上了我的微信公众号介绍。如果你想看看我是如何定制的，可以直接查看我 Fork 出来的 jacman 项目上的 Commits 即可，项目地址在 <a href="https://github.com/tangqiaoboy/jacman" target="_blank" rel="external">这里</a>。</p>
<h2 id="u53D1_u5E03_u6587_u7AE0"><a href="#u53D1_u5E03_u6587_u7AE0" class="headerlink" title="发布文章"></a>发布文章</h2><p>Hexo 支持直接发布到 GitHub，不过我在配置好 <code>_config.yml</code> 文件后，执行 <code>Hexo deploy</code> 一直失败！Hexo 一直卡在生成页面过程中，没有任何报错，这使得我也不知道如何修复它。</p>
<p>最终，我自己写了一个小脚本来做发布工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! /bin/zsh&#10;&#10;hexo clean&#10;hexo generate&#10;cd public&#10;&#10;git init&#10;git add .&#10;git commit -m &#34;update at `date` &#34;&#10;&#10;git remote add origin git@github.com:tangqiaoboy/tangqiaoboy.github.com.git &#62;&#62; /dev/null 2&#62;&#38;1&#10;echo &#34;### Pushing to Github...&#34;&#10;git push origin master -f&#10;echo &#34;### Done&#34;&#10;&#10;git remote add gitcafe git@gitcafe.com:tangqiaoboy/tangqiaoboy.git &#62;&#62; /dev/null 2&#62;&#38;1&#10;echo &#34;### Pushing to GitCafe...&#34;&#10;git push gitcafe master:gitcafe-pages -f&#10;echo &#34;### Done&#34;</span><br></pre></td></tr></table></figure>
<p>如果你遇到了和我一样问题的话，把以上脚本稍做修改应该也能很好地工作。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>Octopress 已经过时，建议有时间的朋友都可以尝试替换掉它。Hexo 算不上完美，但还算是一个不错的替代方案。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5E8F_u8A00"><a href="#u5E8F_u8A00" class="headerlink" title="序言"></a>序言</h2><p>我的博客之前一直使用的是 <a href="http://octopress.org/" target=]]>
    </summary>
    
      <category term="blog" scheme="http://blog.devtang.com/tags/blog/"/>
    
      <category term="shell" scheme="http://blog.devtang.com/categories/shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人员、流程和产品上的思考 - 读《启示录》总结]]></title>
    <link href="http://blog.devtang.com/2016/02/16/inspired-summary/"/>
    <id>http://blog.devtang.com/2016/02/16/inspired-summary/</id>
    <published>2016-02-16T05:32:33.000Z</published>
    <updated>2016-02-16T10:32:21.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img12.360buyimg.com/n1/jfs/t640/134/203561693/178183/b1f2b244/54562358Nb9bef513.jpg" alt=""></p>
<p><a href="http://item.jd.com/10628082.html" target="_blank" rel="external">《启示录：打造用户喜爱的产品》</a> 出版于 2011 年，作为最早一批出版的关于产品经理图书，直到现在仍然非常畅销。它的作者是 eBay 前产品副总裁 Marty Cagan。</p>
<p>Marty Cagan 的这本书有点文集的感觉，从任何一章开始读，都不会感觉到突兀。很多文章最初应该是以博客的形式发表在 <a href="http://www.svpg.com/articles/" target="_blank" rel="external">http://www.svpg.com/articles/</a> 网站上的。整体上图书的文章分为三大部分：人员、流程和产品。以下是一些读书总结。</p>
<h2 id="u4EBA_u5458"><a href="#u4EBA_u5458" class="headerlink" title="人员"></a>人员</h2><p>图书的第一部分是「人员」，用了 10 个章节来阐述。前 5 章主要介绍互联网产品研发中的关键角色定义以及职责，后 5 个章节介绍了一些人员招聘和管理的心得。</p>
<p>Marty Cagan 认为互联网研发的角色包括：产品经理、用户体验设计师、项目管理人员、开发团队、运维团队、产品营销人员，并且他分别讲解了这些角色的职责和工作内容差别。</p>
<p>具体在执行上，其实有可能一人身兼多职，比如我们小猿搜题的产品经理同时需要负责做项目管理相关的推进和协调工作。也可能一个职位被拆分成多个细分的工作方向，比如用户体验设计师在网易公司就会拆分成负责交互效果和负责视觉效果的设计师。</p>
<p>书中我印象比较深刻的是对产品经理和项目经理的讨论。Marty Cagan 在书中是这么介绍的：</p>
<blockquote>
<p>产品经理产注的是定义有价值的产品。</p>
<p>项目经理关注如何执行计划以交付产品。</p>
</blockquote>
<p>书中提到了项目经理需要的能力包括：</p>
<ul>
<li>工作紧迫感</li>
<li>善于捕捉问题</li>
<li>思路清晰</li>
<li>用数据说话</li>
<li>果断</li>
<li>判断力</li>
<li>态度（不能找延期的借口）</li>
</ul>
<p>所以这里面涉及的技能差别巨大，那为什么我们在创业时选择让产品经理身兼项目管理工作呢？除了希望团队保持人员在数量上的敏捷之外，我们认为产品经理如果能够具备这样的能力，会使得他们能具有更有大局观。这个大局观说实际点，就是知道自己的产品方案在执行时会有多大具体的开发成本，在做妥协的时候，知道如何的产品调整会有助于开发团队更快地产出。</p>
<h2 id="u6D41_u7A0B"><a href="#u6D41_u7A0B" class="headerlink" title="流程"></a>流程</h2><p>这部分用了 20 个章节，介绍了做产品的各种流程和做事方法。</p>
<p>其中涉及的很多流程，已经被广泛接受，并成为事实上的标准做法。比如基于 Scrum 的敏捷软件开发方法，虽然有一些公司不完全采用 Scrum，但是其中的看板、站立会议等实践仍然被借鉴融入到了日常工作流程中。</p>
<p>作者推荐产品经理用「高保真」原型来代替产品文档。对于「高保真」原型，作者还在网站上提供了详细的示例：<a href="http://www.svpg.com/examples" target="_blank" rel="external">http://www.svpg.com/examples</a>，我看了之后感觉还是比较惊讶，因为这个 <a href="http://www.svpg.com/assets/Files/Prototype.zip" target="_blank" rel="external">原型</a> 的「高保真」程度已经到了让人看不出来是原型的程度。</p>
<p>就我了解到的大多数公司，都还是用 Axure 或 Omni Graffle 来制作产品文档，其远远谈不上「高保真」，我对所有产品都应该用「高保真」原型来制作存疑。</p>
<h2 id="u4EA7_u54C1"><a href="#u4EA7_u54C1" class="headerlink" title="产品"></a>产品</h2><p>这部分用了 9 个章节，介绍了一些做产品的心得。例如：</p>
<p>第 32 章让我们提防做一些小众需求的功能，主要是给那些做企业级应用的公司的建议。</p>
<p>第 34 章介绍了产品背后涉及的人性：贪婪、恐惧、欲望。这里面的道理谁都懂，不过要真正应用到产品中，还需要长久的思考。之前听一个朋友说，不管是德州扑克，还是炒股，都是一个「克服贪婪与恐惧的游戏」。道理谁都懂，但是能玩好德州扑克和炒股挣钱的人并不多。</p>
<p>第 35 章介绍的情感接纳曲线也是涉及人性的话题，他指出很多人的决策都是为了宣泄情绪，关注并利用到这一点之后，就可以做出广受欢迎的产品。书中举的是关于非理性消费的例子，比如环保主义者就会花很多钱买普锐斯（丰田公司的混合动力汽车），但是其实他们更多的是为情绪买单。作者认为非理性消费本质是对不满情绪的过度反应，是放大后的情感需求在作怪。</p>
<p>对于如何寻找这种需求，作者提出可以把自己想像成一个新生的人，一切东西都是新鲜的，然后感受产品对自己内心的细微影响。这种目标用户的代入感或许是一个产品经理的必修课程吧。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>图书最后用两章进行了一个总结，包括整理出一个「最佳实践经验」和「产品经理的反省清单」。我对此体会并不深，但是考虑到可能自己还没悟到，所以先摘录如下：</p>
<p>「最佳实践经验」有十条：</p>
<ul>
<li>1、产品管理的职责</li>
<li>2、用户体验</li>
<li>3、机会评估</li>
<li>4、特约客户</li>
<li>5、产品原则</li>
<li>6、人物角色</li>
<li>7、探索（定义）产品</li>
<li>8、使用原型</li>
<li>9、用户参与原型测试</li>
<li>10、根据数据进行改进</li>
</ul>
<p>「产品经理的反省清单」也有十条：</p>
<ul>
<li>1、产品能吸引目标消费用户的关注吗？</li>
<li>2、设计是否人性化，好操作？</li>
<li>3、能赢得过竞品么？</li>
<li>4、了解目标用户吗？</li>
<li>5、是否有别于其他的产品呢？</li>
<li>6、产品能正常运行么？</li>
<li>7、是否完整，销售是否能够完成。</li>
<li>9、特色是否与目标用户一致。</li>
<li>10、产品值钱吗？值多少钱？</li>
<li>11、了解团队其他成员的想法吗？</li>
</ul>
<p>作为最早一批出现的介绍产品经理工作的书籍，《启示录》非常适合入门，特别是适合有一些具体产品工作实践的同学阅读。本书不太好的地方就是内容组织的条理性太差，并且涉及的内容通常并没有很深入展开。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img12.360buyimg.com/n1/jfs/t640/134/203561693/178183/b1f2b244/54562358Nb9bef513.jpg" alt=""></p>
<p><a href="http://item]]>
    </summary>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过他人完成任务的艺术 - 读《领导梯队》]]></title>
    <link href="http://blog.devtang.com/2016/02/16/the-leadership-pipeline-summary/"/>
    <id>http://blog.devtang.com/2016/02/16/the-leadership-pipeline-summary/</id>
    <published>2016-02-16T05:24:31.000Z</published>
    <updated>2016-02-16T10:26:44.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img11.360buyimg.com/n1/jfs/t991/39/1365739528/216597/92223aa5/559a1e10N51068ad5.jpg" alt=""></p>
<p><a href="http://item.jd.com/10708646.html" target="_blank" rel="external">《领导梯队》</a> 是美团的 <a href="http://baike.baidu.com/item/%E9%99%88%E6%99%93%E4%BA%AE/17510291" target="_blank" rel="external">陈晓亮</a> 同学推荐给我的，看完了一段时间，但是一直没有整理读书笔记，这次趁着春节回顾了一下本书。</p>
<p>领导力就是通过他人去完成任务的学问。本书通过对六个典型的管理层级最经常出现的问题，从领导技能、时间管理能力、工作理念三个方面进行了分析，提出了改进建议。</p>
<p>本书对管理层级的划分非常宏大，看起来像是给一个上万人集团公司写的一样，书中甚至有一章是教你如何做 CEO，这可能与本书的作者拉姆·查兰长期从事管理方面的教学工作有关。而我因为刚刚从一个开发人员转型做管理工作，所以我主要阅读的图书的前两章，里面涉及了如何「从管理自我到管理他人」。</p>
<p>对于每一个领导阶段，书中都从如下三个方面进行了工作指导：</p>
<ol>
<li>领导技能：培养胜任新职务所需要的新能力，提升领导力。</li>
<li>时间管理：重新配置时间精力资源，决定如何高效工作。</li>
<li>工作理念：更新工作理念和价值观，让工作聚焦重点。</li>
</ol>
<p>而这三个方面，也是我常常困惑的地方。我常常问自己：</p>
<ol>
<li>作为一个技术转管理的人，我应该如何学习和提高？</li>
<li>我应该如何安排自己的日常工作时间？</li>
<li>有什么核心的方法论来指导自己？</li>
</ol>
<p>而这些问题，我试图从本书中得到答案，有一些找到了，也有一些没找到。</p>
<h2 id="u4ECE_u7BA1_u7406_u81EA_u6211_u5230_u7BA1_u7406_u4ED6_u4EBA"><a href="#u4ECE_u7BA1_u7406_u81EA_u6211_u5230_u7BA1_u7406_u4ED6_u4EBA" class="headerlink" title="从管理自我到管理他人"></a>从管理自我到管理他人</h2><p>我们大部分初入职场的人刚开始都是个人贡献者，随着能力的提高，有一些人在自己专业领域上做出了出色的成绩。而公司往往会给这些人增加更多的职责，这些职责很多时候都是涉及沟通、组织和管理的。所以，这些优秀的个人贡献者，开始迎接他们的第一次转型挑战，尝试学会从管理自我到管理他人。</p>
<p>书中也提到，优秀的个人贡献者和优秀的管理人员所需要的技能树并不一样。所以并不是每一个人都是能够完成这一转变。而就我所在的互联网行业来看，很多时候，优秀的个人贡献者也不一定需要做这个转变，也能在技术领域一路提升，成为技术专家。</p>
<p>例如阿里的 <a href="http://baike.baidu.com/view/15099717.htm" target="_blank" rel="external">多隆</a>，就是一位一直坚持在技术领域的专家，他做到了阿里的合伙人。我也见到一些朋友坚持在一线做技术，其薪资待遇高于那些做管理的人。所以这个职位转变更多需要是内心的喜欢和坚持。如果转型失败，后果很可能是自废武功—-既弱化了专业的职业技能，又是一个失败的管理者。</p>
<p>我们先来看看书中指出管理他人的技能树吧：</p>
<h3 id="u9886_u5BFC_u6280_u80FD"><a href="#u9886_u5BFC_u6280_u80FD" class="headerlink" title="领导技能"></a>领导技能</h3><p>书中指出管理他人首先需要的技能是「领导技能」，具体包括：</p>
<ul>
<li>制定计划（项目计划，预算计划和人员计划）</li>
<li>工作设计</li>
<li>人员选拔（其实就是招聘）</li>
<li>授权（工作安排）</li>
<li>绩效监督</li>
<li>教练辅导与反馈</li>
<li>绩效评估</li>
<li>奖励与激励</li>
<li>沟通与营造工作氛围</li>
<li>为部门发展建立上下左右的良好关系</li>
<li>获取资源</li>
</ul>
<p>与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下：</p>
<ul>
<li>技术或者业务能力</li>
<li>团队协作能力</li>
<li>为了个人利益和个人成员建立的人际关系</li>
<li>合理运用公司的工具、流程和规则</li>
</ul>
<p>书中将以上内容分为了三类：界定和布置工作、提高下属的胜任能力、建立人际关系。我觉得分得并不清晰，我按个人理解，用工作方式再次进行了分类：</p>
<ul>
<li>自己思考的工作：制定计划、工作设计、绩效评估</li>
<li>与人沟通的工作：授权、教练辅导与反馈、营造工作氛围、获取资源、奖励与激励</li>
<li>自己执行的工作：人员选拔、绩效监督</li>
</ul>
<p>所以我觉得一个好的一线管理人员，应该有思考和规划的能力、沟通能力、以及执行力。执行力在个人贡献者阶段其实也有锻炼，所以主要需要学习的是思考和规划的能力、沟通能力。</p>
<p>沟通能力似乎和演讲一样，就是一个多练习才能提高的技能。我平时会注意观察和总结自己的言语表达方式，以及观察别人的沟通方式，能感受到自己在一点点进步。</p>
<p>思考和规划的能力似乎也是一个需要花时间来积累的事情。好在很多时候规划并不是我来做的，所以我对此承担的压力并不大。</p>
<h3 id="u65F6_u95F4_u7BA1_u7406"><a href="#u65F6_u95F4_u7BA1_u7406" class="headerlink" title="时间管理"></a>时间管理</h3><p>时间管理方面的技能，具体包括：</p>
<ul>
<li>年度时间计划（时间安排、项目进度）</li>
<li>与下属沟通的专门时间（一是自己的需要，二是下属的需要）</li>
<li>为部门和团队工作设定时间方面的优先次序</li>
<li>与其他部门、客户和供应商沟通的时间</li>
</ul>
<p>与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下：</p>
<ul>
<li>遵守工作上下班时间</li>
<li>遵守工作的进度安排</li>
</ul>
<p>其实简单来说，以前是别人给自己安排工作，现在需要自己给自己安排工作了。每天的时间怎么分配，花在哪些事情上，一线经理需要开始思考了。</p>
<p>我当前主要的工作内容包括参与产品讨论，参与技术讨论，跟进项目上线，与运营同事沟通，与我的领导沟通，与主要具体负责人定期沟通。除此之外，还有团队的工作安排，一些面试工作。</p>
<p>我以前会主动承担一些开发任务，但是我发现这其实是不太合适的，因为我的时间沟通工作比较多，所以开发工作时间很多时候并不能保证进度。我以前也会过多地参与到项目进度推进中，现在发现也是不太合适的，这方面的工作我更多交给了相应的产品经理来完成。</p>
<p>但是，我对自己的时间安排也不尽满意。主要是我不太清楚我应该如何安排每天事情的优先级，以及当某一天没有固定安排的时候，我应该做什么事情。我有一些例行的事情可选，但是并没有安排好，例如：</p>
<ul>
<li>Check 一下和团队的人哪些人很久没有一对一沟通过，如果没有的话做一次。</li>
<li>关注 Pipe 上产品的各项指标，看是否有异常的、未被发现的数据。</li>
<li>关注用户反馈，看看用户都在说什么。</li>
<li>在 QQ 上找一些用户聊聊天。</li>
<li>关注自己的产品细节，反复使用。</li>
<li>关注竞争对手的功能改进。</li>
<li>看用户的原始数据（Frog，上传的图片）。</li>
<li>思考人员、流程和产品，各自有没有什么问题。</li>
</ul>
<p>这些问题在本书中没有涉及，我通过和我的领导郭常圳沟通，最终确定的结论是：我们把工作分为「被动工作时间」和「主动工作时间」。</p>
<ul>
<li>被动工作时间包括：定期的产品过稿、美术过稿、Scrum会议、邮件、在QQ上或当面主动来找我的事情。</li>
<li>主动工作时间包括：刚刚提到的看产品数据、看用户反馈，看原始数据等事情。</li>
</ul>
<p>郭常圳认为，我们应该把主动工作时间「例行化」，「例行化」是指每天抽出固定的时间来做这些事情，这样使得这些事情不被遗漏和忽视。在例行化的事情之外，我需要更多的留出「主动思考」时间，「主动思考」是最重要，并且是将这些输入转化成想法或决策的关键过程。</p>
<p>所以，我刚刚提到的那些事情，都应该变成每天例行做的事情。</p>
<h3 id="u5DE5_u4F5C_u7406_u5FF5"><a href="#u5DE5_u4F5C_u7406_u5FF5" class="headerlink" title="工作理念"></a>工作理念</h3><p>书中提到的工作理念的技能，具体包括：</p>
<ul>
<li>通过他人完成任务</li>
<li>下属员工的成功（就是自己的成功）</li>
<li>管理性工作和修养</li>
<li>部门的成功（就是自己的成功）</li>
<li>像一位真正的管理者</li>
<li>正直诚实</li>
</ul>
<p>与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下：</p>
<ul>
<li>通过个人能力完成任务</li>
<li>高质量的技术或专业化工作</li>
<li>遵循公司的价值观</li>
</ul>
<p>这一部分涉及成就感的转变，以前个人贡献者的成就感来源于自己的努力和成长。现在一线管理人员的成就感变成了下属的成功和团队的成功。不但如此，一线管理人员还需要在各方面对下属进行辅导，帮助他们工作得更舒服，更开心。</p>
<p>另外，我对正直诚实这条也感触很深。公司大了之后，很多文化就是来自于创始人以及一些核心员工。如果管理人员不能做到正直诚实，那么公司很可能变得充满了「政治斗争」，一但工作变成了维护自己利益以及小集团的利益，那么对公司的伤害是巨大的。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>本书的内容组织稍显混乱，虽然把领导技术、时间管理、工作理念作为每个阶段层级的主要改变内容，但是在具体阐述时，又会以另外一个角度展开。比如「 从管理自我到管理他人」一章的内容展开时，是按界定和布置工作、提高下属的胜任能力、建立人际关系作为内容小节阐述。而「从管理他人到管理经理人员」一章的内容，又是按「四个领导技能」展开。</p>
<p>本书很多章节总结性的内容散乱，最终以 QA 或故事的方式，列出一系列问题和回答来作为主要的章节内容，虽然很多内容读起来很有道理，但是使读者很难抽取出核心观点，也可能作者本身也没能总结出核心观点。</p>
<p>本书对于我的帮助是，我从中得到了不少指导性的规则，也帮助我梳理了自己的工作内容。虽然它没有解决我的所有问题，但是至少帮助我完成了对问题列表的整理和思考。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img11.360buyimg.com/n1/jfs/t991/39/1365739528/216597/92223aa5/559a1e10N51068ad5.jpg" alt=""></p>
<p><a href="http://item]]>
    </summary>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[和时间做朋友 - 读《奇特的一生》]]></title>
    <link href="http://blog.devtang.com/2016/02/16/make-friend-with-time/"/>
    <id>http://blog.devtang.com/2016/02/16/make-friend-with-time/</id>
    <published>2016-02-16T05:04:28.000Z</published>
    <updated>2016-02-18T13:14:02.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://camo.githubusercontent.com/9b0ba22b20c8464aefd022486269d4f3c8f3a5b8/687474703a2f2f696d6731302e333630627579696d672e636f6d2f6e312f6731352f4d30372f31312f30312f7242456857564a6e4a6167494141414141416e4f6362317365314141414564665141734b3934414363364a3231332e6a7067" alt=""></p>
<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>一切都不是我们的，而是别人的，只有时间是我们自己的财产。造物主交给我们，归我们所有的，只有这个不断流逝的、不稳定的东西。就连这个东西，谁只要愿意，都可以把它从我们手里剥夺走。</p>
<p>—— 古罗马哲学家：赛纳卡</p>
</blockquote>
<p>今天要介绍的是 <a href="http://item.jd.com/11331635.html" target="_blank" rel="external">《奇特的一生》</a> 这是一本关于时间的书，春节期间看到池建强在微信读书中推荐，于是就一口气读完了。该书讲述苏联科学家柳比歇夫将自己的一生用时间来计划，通过分析柳比歇夫「时间统计法」，作者认为这是让他生活得更好的秘密。</p>
<p>以下是我的读书感受。</p>
<a id="more"></a>
<h2 id="u548C_u65F6_u95F4_u505A_u670B_u53CB"><a href="#u548C_u65F6_u95F4_u505A_u670B_u53CB" class="headerlink" title="和时间做朋友"></a>和时间做朋友</h2><p>今年罗振宇的新年跨年演讲主题叫：「时间的朋友 2015」，听着名字就很酷，而李笑来老师的《把时间当做朋友》也是我非常喜欢的一本书。看吧，大家都喜欢谈时间。时间，是这个世界上人人都有的东西，但却又是最昂贵的东西。</p>
<p>为了节约时间，我们发明了汽车、火车、飞机代替了马车。我们发明了电活代替了电信。我们发明了电梯代替了楼梯。我们每天使用的微信，也代替了以前的短信。一切的发明，都为我们省下了大量时间，但是奇怪的是，我们越来越感到时间不够用。</p>
<p>你有这样的感受吗？晚上在电脑或手机面前看电影或者是刷微博，稍微不留神，就到了零晨 12 点了。但是我还记得小时候，家里偶尔会停电，那个时候点一盏蜡烛，大家围在蜡烛前面聊天，感觉聊了好久好久，来电后一看，才过了不到半个小时。</p>
<p>时间就是这样一个顽皮的小孩，当你认真看他的时候，他会像蜗牛一样慢慢地一秒一秒往前爬；当你忘记他的时候，他就会飞奔起来，等你发现的时候，你才发现人生在世，几十个年头也就一眨眼的功夫。</p>
<p>当今世界被移动互联网颠覆着，但时间的分配几乎同两千年以前的时代一模一样：「我们一生的时间，大部分用于错误及种种恶行；很大一部分虚抛浪掷，无所事事。我们整个一生，几乎都没有用来干应当干的事。」</p>
<p>今年我三十二岁了，有些时候会感觉很恐怖，搞互联网这个行业，有些时候晚上难免加班，熬夜之后身体明显会很不舒服，要过好几天才能缓过来，而以前大学在学校宿舍，打 Dota（一种多人联机对战游戏）玩到零晨 2，3 点也不觉得困。我希望我的「奔四」的这些年头，能够更有效，更有价值地度过。</p>
<p>所以，我们需要和时间做朋友，因为我们不希望一辈子就像眨眼一样就过去，而我们完全不记得曾经在这个世界上留下过什么。</p>
<h2 id="u65F6_u95F4_u7EDF_u8BA1_u6CD5"><a href="#u65F6_u95F4_u7EDF_u8BA1_u6CD5" class="headerlink" title="时间统计法"></a>时间统计法</h2><p><a href="http://item.jd.com/11331635.html" target="_blank" rel="external">《奇特的一生》</a> 在介绍了柳比歇夫的大量评价和成就之后，在第七章介绍了「时间统计法」。「时间统计法」实在太简单了，其实就是每做一件事情，记录下它花费的时间。然后，每周、每月、每年汇总和分类，看自己的时间是如何用掉的。</p>
<p>在时间统计法之上，本书也提出了一些注意细节，我总结如下。</p>
<h3 id="u5E94_u8BE5_u7EDF_u8BA1_u7EAF_u65F6_u95F4"><a href="#u5E94_u8BE5_u7EDF_u8BA1_u7EAF_u65F6_u95F4" class="headerlink" title="应该统计纯时间"></a>应该统计纯时间</h3><p>本书强调时间统计法应该计算纯时间：</p>
<blockquote>
<p>“工作中的任何间歇，我都要刨除。我计算的是纯时间，” 柳比歇夫写道，“纯时间要比毛时间少得多。所谓毛时间，就是你花在这项工作上的时间。”</p>
<p>常常有人说，他们一天工作十四五个小时。这样的人可能是有的。可是拿纯时间来说，我一天干不了那么多。我做学术工作的时间，最高纪录是 11 小时 30 分。</p>
<p>有七八个小时的纯工作时间，我就心满意足了。我最高纪录的一个月是 1937 年 7 月，我一个月工作了 316 小时，每日平均纯工作时间是 7 小时。如果把纯时间折算成毛时间，应该增加 25% 到 30%。我逐渐改进我的统计，最后形成了我现在使用的方法。</p>
</blockquote>
<h3 id="u5B66_u4F1A_u5229_u7528_u788E_u7247_u65F6_u95F4"><a href="#u5B66_u4F1A_u5229_u7528_u788E_u7247_u65F6_u95F4" class="headerlink" title="学会利用碎片时间"></a>学会利用碎片时间</h3><p>书中把碎片时间称作「时间下脚料」：</p>
<blockquote>
<p>他只是想方设法利用每一分钟，利用任何所谓的 “时间下脚料”：乘电车、坐火车、开会、排队……<br>还是在克里米亚，他已经注意到边走路边打毛衣的希腊女人。<br>每一次散步，他都用来捕捉昆虫。在那些废话连篇的会议上，他演算习题。</p>
</blockquote>
<h3 id="u5B66_u4F1A_u96C6_u4E2D_u6CE8_u610F_u529B"><a href="#u5B66_u4F1A_u96C6_u4E2D_u6CE8_u610F_u529B" class="headerlink" title="学会集中注意力"></a>学会集中注意力</h3><blockquote>
<p>应当学会不受周围环境的干扰，用在工作上的 3 个小时应当是真正做工作的 3 个小时，不想不相干的事，不听同事的谈话，不听铃声和笑声，也不听收音机……</p>
</blockquote>
<p>在这方面，我推荐大家使用番茄工作法，非常有效。</p>
<h3 id="u5B66_u4F1A_u603B_u7ED3"><a href="#u5B66_u4F1A_u603B_u7ED3" class="headerlink" title="学会总结"></a>学会总结</h3><p>任何的学习活动，都应该最终有总结，这样的学习才是真正的有价值的学习。我面试 iOS 开发的时候，喜欢问他们最近看了什么书，让他们讲一个最近看的「印象最深刻」的知识。大多数人都能回答出书名，但是想不起来书中讲了什么。</p>
<p>如果你看了一本书，但最终全部忘掉了，那就相当于没看。哦不对，应该更糟糕，因为你不但什么都没记住，还浪费了时间。</p>
<blockquote>
<p>柳比歇夫有种罕见的才能——随便哪本书的作者，凡有独特的见解，他都极善于汲取。有的书，一张纸就够；某些大部头书，需要几张纸来归纳。它们的精华同它们的厚度怎么也不相称：大量的插图、表格、附页、书皮。</p>
</blockquote>
<h3 id="u4E0D_u8981_u8BF4_u6CA1_u6709_u65F6_u95F4"><a href="#u4E0D_u8981_u8BF4_u6CA1_u6709_u65F6_u95F4" class="headerlink" title="不要说没有时间"></a>不要说没有时间</h3><p>人们常说，太忙了，没有时间做某某事。其实这是一个借口。如果你自己尝试做一下时间统计的话，你就会发现时间大把大把的有，只需要你有执行力。</p>
<p>而且，大部分情况下，稀缺的资源才会被珍惜。如果让你把工作辞掉，把时间留出来专门做一件事，你反倒很可能做不好。</p>
<p>书中是这么说的：</p>
<blockquote>
<p>我想以我的一个朋友来作为反面的例子。他曾经是一个很不错的科学家，后来又担任过一个很大的研究所的所长。马上我又想起我熟悉的一个作家类似的遭遇，随即又联想起另一个作家。职务确实剥夺了他们很多的时间，而且妨碍他们开展工作。但久而久之他们就习惯了这些客观情况的制约。<br>他们都幻想能摆脱，并经常说，到了那个时候，他们就要大干自己心爱的工作了，因为陷于各种繁杂应酬活动是很难写出书来，更不可能从事科学研究。<br>他们终于摆脱出来了。每个人都盼到了这么一天。但很快发现，他们谁也不能工作了。</p>
</blockquote>
<h2 id="u6211_u4EEC_u662F_u673A_u5668_u4EBA_u5417"><a href="#u6211_u4EEC_u662F_u673A_u5668_u4EBA_u5417" class="headerlink" title="我们是机器人吗"></a>我们是机器人吗</h2><p>书中的柳比歇夫严格记录了几十年自己的时间花费，让人看起来像机器人一样。我们是机器吗？我们为什么要把自己的生活弄得像机器一样严格而呆板？</p>
<p>对此，我的体会是，人生很多时候，需要我们把自己当做机器一样，执行自己预先的规划。比如对于我个人来说，坚持写微信公众号文章这件事情，到底有多大的意义？我不知道，但是我知道放弃一件事情非常容易，但坚持做一件事情，很可能会收获巨大。所以，这个名为「iOS 开发」的公众号我一写就是三年。有些时候不知道写些什么 iOS 开发的东西，我就写读书笔记，创业感悟。</p>
<p>现在我从技术转管理了，在时间计划上，我的领导常圳建议我把主动工作时间「例行化」。「例行化」是指每天抽出固定的时间来做固定事情，这些固定的事情包括：看产品数据、看用户反馈，看原始数据等，你觉得这些事情会有趣吗？其实不怎么有趣，但是这些事情对我的工作有很大的帮助，所以在这些事情上，我需要把自己变成「机器人」，不带有任何情绪地、认真地把它做好。</p>
<p>对于写书也是一样，我在写《iOS 开发进阶》的时候，刚开始兴奋，周末可以写一整天，然后就慢慢变得烦躁而疲倦了。我可以找相当多的借口放弃：创业太累、时间不够、稿费太少 …… 但是，我还是把自己当机器人一样，按照之前计划的章节安排，一章一章写。</p>
<p>我们不是机器人，但是我们内心足够强大，才能使得自己像机器人一样。</p>
<p>这其实也代表着心智的成熟。</p>
<h2 id="u4E00_u4E07_u5C0F_u65F6_u5B9A_u7406"><a href="#u4E00_u4E07_u5C0F_u65F6_u5B9A_u7406" class="headerlink" title="一万小时定理"></a>一万小时定理</h2><p>《异类》一书中揭示了成功的秘密：大量不管天赋多么高的人，都是经过 10000 小时的训练，才成为专家的。不管是钢琴家（书中以 6 岁就开始作曲的莫扎特为例），还是程序员（书中以 Java 语言的作者乔伊和微软的创始人比尔盖茨为例），他们都是由于环境的优势，早早地完成了 10000 小时训练，才成为人们眼中的天才的。</p>
<p>而本书 <a href="http://item.jd.com/11331635.html" target="_blank" rel="external">《奇特的一生》</a> 中介绍的时间统计法，其实就是一种实际可操作的「一万小时定理实践手册」。</p>
<p>通过对未来五年的规划，然后定出每年的年度目标，然后进一步进行拆解成月度目标，再结合时间统计法来计划每天的工作，并且检查自己工作完成情况，我们就会惊喜地发现，按这个进度我们很可能达成目标。</p>
<p>当然，<a href="http://item.jd.com/11331635.html" target="_blank" rel="external">《奇特的一生》</a> 中讲了另外一种情况：主人公柳比歇夫通过时间统计法，最终发现自己在 72 岁设立的写作目标并不实际，所以他最终调整了写作的内容，放弃了一部分章节，使得书稿能够最终完成。但这何尝不是一种合理的调整，他避免了柳比歇夫临死前才发现时间不够，后悔莫及的情况。</p>
<h2 id="Scrum__u7684_u8BA1_u5212_u548C_u56DE_u987E"><a href="#Scrum__u7684_u8BA1_u5212_u548C_u56DE_u987E" class="headerlink" title="Scrum 的计划和回顾"></a>Scrum 的计划和回顾</h2><p>看完了时间统计法，突然发现这个方法其实和 Scrum 有着非常惊人的相似度：</p>
<ul>
<li>制定长远目标，对应 Scrum 的 Milestone 的概念。</li>
<li>制定年度、月度目标，对应 Scrum 的每一个 Sprint。</li>
<li>每天的工作计划和时间统计，对应 Scrum 的每日站会。</li>
<li>定期的时间统计总结，对应 Scrum 的燃尽图和回顾会议。</li>
<li>短期和长期目标的达成，对应 Scrum 的评审会议。</li>
</ul>
<p>时间统计法以及它的一些指导思想，其实就类似一个人生的 Scrum 规则。</p>
<p>Scrum 强调组织的透明、检验和适应。时间统计法强调对自己的透明、检验和适应：</p>
<ul>
<li>对自己的透明，是指用时间统计法，了解自己的时间花费到底在哪里。</li>
<li>对自己检验，是指看自己长远目标的完成进度是否理想。</li>
<li>对自己的适应，是指定期总结自己的时间花费，看是否有改进的空间。</li>
</ul>
<h2 id="u7C7B_u7684_u81EA_u7701_u4E0E_u4EBA_u7684_u81EA_u6211_u56DE_u987E"><a href="#u7C7B_u7684_u81EA_u7701_u4E0E_u4EBA_u7684_u81EA_u6211_u56DE_u987E" class="headerlink" title="类的自省与人的自我回顾"></a>类的自省与人的自我回顾</h2><p>现代的高级语言，类和对象都会有「自省」的能力。自省是说，这个对象在运行时，能够了解自己。比如 Java 语言，可以通过反射，了解自己的类名、成员变量和成员函数。C++ 语言可以通过 RTTI 达到同样的效果。而我们熟悉的 Objective-C 的 Runtime 也非常强大，不但可以了解自己，还可以动态修改类的成员函数实现。</p>
<p>我之所以认为 Swift 语言还不完善，也是因为 Swift 语言在这方面的能力还比较弱，我感觉苹果在未来的版本中一定会增加这方面的特性。</p>
<p>「自省」的能力代表着一系列高级的编程技巧，Java 可以通过反射做到 IOC（反转控制），Objective-C 可以做到动态打补丁。而人呢，如果能够做到自我的回顾、总结和调整，那么也就能不断进步了。</p>
<p><a href="http://item.jd.com/11331635.html" target="_blank" rel="external">《奇特的一生》</a> 中的时间统计法是一种特别简单可操作的方法，使你具备「自省」的能力。</p>
<h2 id="u4E0D_u8981_u5D07_u62DC_u5929_u624D"><a href="#u4E0D_u8981_u5D07_u62DC_u5929_u624D" class="headerlink" title="不要崇拜天才"></a>不要崇拜天才</h2><p>作者在书中这么说：「我之所以对柳比歇夫产生兴趣，正由于他不是天才，因为天才是无法分析的，好在天才也不用去研究。天才只适合于让大家来赞美。」</p>
<p>这个世界基本上没有天才，我们也不需要崇拜天才，大部分成功的人都和你我一样，学习那些优秀的人做得好的地方，努力让自己提高一些。不要和天才比，要和自己比，这种价值观是我喜欢并坚持的。</p>
<h2 id="u76EE_u6807_u4E4B_u5916_uFF1A_u4E0D_u8981_u6210_u4E3A_u300C_u65F6_u95F4_u7684_u5974_u96B6_u300D"><a href="#u76EE_u6807_u4E4B_u5916_uFF1A_u4E0D_u8981_u6210_u4E3A_u300C_u65F6_u95F4_u7684_u5974_u96B6_u300D" class="headerlink" title="目标之外：不要成为「时间的奴隶」"></a>目标之外：不要成为「时间的奴隶」</h2><p>很难有一种理论体系能够解释所有现象，牛顿的物理学三大定理那么牛逼，也只能在宏观世界中适用。时间统计法也是一样，我们不能指望它解决我们所有的问题。</p>
<p>更进一步地，我们不能让我们成为「时间的奴隶」。这个世界并不是所有事情都能用时间来衡量价值，所以我们不能只关注长远目标，忘记了留意身边那些美好的瞬间。</p>
<p>所以，任何事情都有一个度，在你还没有学会好好利用时间的时候，你应该尝试用时间统计法来改进自己的时间规划；当你已经有很好的时间规划的时候，或许留一些随意时间，反倒是好的。</p>
<p>本书的主人公柳比歇夫就是这样一个人，他虽然是一个坚持做了几十年时间统计法的「强迫症患者」，但是他同样会花大量的时间回复书信，很多书信仅仅是向他求教一些专业知识。他从长远规划中安排出了这些时间，来帮助那些素不相识的朋友，这让我感受到了他的可爱。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这是一本非常有意思的书，讲了一个看起来细毫没有技术含量的生活方式：时间统计。但是，它让主人公柳比歇夫获得了人生的快乐和成就，希望我们大家都能够找到这样的快乐和成就。</p>
<p>愿大家猴年大吉！</p>
<!--

全书的章节构成是：

 * 第一章：算是引言，介绍为什么要写本书。
 * 第二章：别人对柳比歇夫的评价。
 * 第三章：介绍柳比歇夫的一生成就。
 * 第四章：介绍柳比歇夫时间帐本，引出将要介绍的时间统计法。
 * 第五章：讨论做时间统计的意义。
 * 第六章：长远目标是时间统计价值的基础。
 * 第七章：如何做时间统计（本书实际可操作的部分）。
 * 第八章：再次介绍了做时间统计意义。
 * 第九章：柳比歇夫的收获。
 * 第十章：柳比歇夫的自我评价。
 * 第十一章：井井有条的生活带来的好处。
 * 第十二章：柳比歇夫性格的代价。
 * 第十三张：柳比歇夫的自我批评。
 * 第十四章：比时间更宝贵的东西：目标，成长。
 * 第十五章：自我认知的成长。
 * 第十六章：超越自己。

-->
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://camo.githubusercontent.com/9b0ba22b20c8464aefd022486269d4f3c8f3a5b8/687474703a2f2f696d6731302e333630627579696d672e636f6d2f6e312f6731352f4d30372f31312f30312f7242456857564a6e4a6167494141414141416e4f6362317365314141414564665141734b3934414363364a3231332e6a7067" alt=""></p>
<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>一切都不是我们的，而是别人的，只有时间是我们自己的财产。造物主交给我们，归我们所有的，只有这个不断流逝的、不稳定的东西。就连这个东西，谁只要愿意，都可以把它从我们手里剥夺走。</p>
<p>—— 古罗马哲学家：赛纳卡</p>
</blockquote>
<p>今天要介绍的是 <a href="http://item.jd.com/11331635.html">《奇特的一生》</a> 这是一本关于时间的书，春节期间看到池建强在微信读书中推荐，于是就一口气读完了。该书讲述苏联科学家柳比歇夫将自己的一生用时间来计划，通过分析柳比歇夫「时间统计法」，作者认为这是让他生活得更好的秘密。</p>
<p>以下是我的读书感受。</p>]]>
    
    </summary>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[教你阅读图书的「方法论」- 评《如何阅读一本书》]]></title>
    <link href="http://blog.devtang.com/2016/01/17/how-to-read-a-book-summary/"/>
    <id>http://blog.devtang.com/2016/01/17/how-to-read-a-book-summary/</id>
    <published>2016-01-17T01:58:18.000Z</published>
    <updated>2016-02-16T10:26:44.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/how-to-read-a-book.jpg">
<h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><p>最近常圳给我推荐了 <a href="http://item.jd.com/11435655.html" target="_blank" rel="external">《如何阅读一本书》</a> 这本书。这本书最初出版于 1940 年，然后于 1970 年进行了增补改写。到现在已经面世 70 多年，在我写这篇笔记的时候，该书在京东上的 <a href="http://book.jd.com/booktop/0-0-0.html?category=3281-0-0-0-10001-1" target="_blank" rel="external">销售排名</a> 位于社会科学销量榜第 2 名，可见该书是多么畅销。</p>
<p>在花两周读完本书之后，我最大的收获是学会了如何更加科学地阅读。在本书中，作者将阅读分为四个层次，并且逐条讲解每一个层次的阅读方法，以及需要达到的目标。本书将阅读分为如下四个层次：</p>
<ol>
<li>基础阅读</li>
<li>检视阅读</li>
<li>分析阅读</li>
<li>主题阅读</li>
</ol>
<p>我一直对这 4 个偏学术的名词记不太清，我对这四个层次的理解如下：</p>
<ol>
<li>基础阅读，是指基本的识字和认识能力，能够知道每个字和句子表面的意思。这个确实也没什么好多说的，全书第 3 章花了一共 8 页简单介绍了一下。我想这一层次的内容主要可以使得全书的理论结构更加完整。</li>
<li>检视阅读，是指的快速获得图书重要信息的能力，其实就是略读。但是本书有价值的地方在于，他提供了一套略读的方法指导，使得你能够更科学地快速获得全书的概要信息。</li>
<li>分析阅读，其实就是精读，作者对于分析阅读提出了一系列问题，让我们通过回答这些问题，来辅助我们获得书本背后作者想传达的思想。</li>
<li><p>主题阅读，其实就是把含有相似内容的书籍综合起来一起读，从而对目标知识产生更全面的理解。这就像我们大学时要写某个具体领域的研究论文，然后就会用一些关键词在学校图书馆或期刊上搜索，然后把这些同一领域的图书或期刊都借出来系统学习。</p>
<p>所以，我认为本书的牛逼之处并不在于提出了阅读的 4 个层次，即使没有本书，我们在实际生活中也会自觉的在阅读中，根据自己的需要，采用不同的层次来阅读。本书之所以受欢迎，是因为它对于每个阅读层次，都有一套具体的、可执行的操作方法，有了这套「方法论」，大家可以按步就班地来做更加科学地阅读。</p>
</li>
</ol>
<p>我们常常会出现这样一个对话场景：</p>
<blockquote><p>A 说：「某某书你看过了吗？」<br>B 回答说：「看过了，挺不错的！」<br>A 问：「讲了什么？」<br>B 说：「呃。。。不记得了。」</p>
</blockquote>
<p>我想《如何阅读一本书》的价值就在于这儿吧，它让以上这种场景尽可能地避免了。我们来看看它的「方法论」到论是什么样的。</p>
<h3 id="u68C0_u89C6_u9605_u8BFB"><a href="#u68C0_u89C6_u9605_u8BFB" class="headerlink" title="检视阅读"></a>检视阅读</h3><p>基础阅读我就不介绍了。因为基本的识字和认识能力应该是每一个成年人都应该具有的。我们直接来看看检视阅读的方法。</p>
<p>检视阅读的第一阶段：系统的略读。具体的做法如下：</p>
<ol>
<li>先看书名页，然后如果有序就先看序。</li>
<li>研究目录页。</li>
<li>如果书中附有索引，也要检阅一下。</li>
<li>读一下出版者的介绍（如果有）。</li>
<li>开始挑几个看起来跟主题息息相关的篇章来看。</li>
<li>把书打开，随意浏览，念个一两段，有时候连续读几页，但不要太多。</li>
</ol>
<p>检视阅读的第二阶段：</p>
<ol>
<li>不要在不懂的地方停下来深究（查询或思索）。</li>
<li>注意阅读速度（文中还介绍了一些速读的技巧：如避免「半出声」的阅读，用手指快速移动来控制眼睛停留时间等）。</li>
</ol>
<h3 id="u5206_u6790_u9605_u8BFB"><a href="#u5206_u6790_u9605_u8BFB" class="headerlink" title="分析阅读"></a>分析阅读</h3><p>作者认为一个主动的阅读者，需要解决如下四个问题：</p>
<ol>
<li>这本书整体上在谈些什么？</li>
<li>作者细部说了什么，怎么说的？</li>
<li>这本书讲得是否有道理？是全部有道理，还是部分有道理？</li>
<li>这本书跟你有什么关系？</li>
</ol>
<p>为了解决以上问题，作者将分析阅读分成如下几个阶段。</p>
<p>第一阶段（解决问题 1），找出一本书在谈些什么的四个规则：</p>
<ol>
<li>依照书本的科类与主题作分类。</li>
<li>用最简短的句子说出整本书在谈些什么。</li>
<li>按照顺序或关系，列出全书的重要部分。</li>
<li>找出作者在问的问题，或作者想解决的问题。</li>
</ol>
<p>第二阶段（解决问题 2）：诊释一本书的内容规则</p>
<ol>
<li>诊释作者的关键字，与他达成共识。</li>
<li>由最重要的句子中，抓住作者的重要主旨。</li>
<li>知道作者的论述是什么，从内容中找出相关的句子，再重新架构出来。</li>
<li>确定作者已经解决了哪些问题，还有哪些是没解决的。再判断哪些是作者知道他没解决的问题。</li>
</ol>
<p>第三阶段（解决问题 3 和 4）：像是沟通知识一样地评论一本书的规则</p>
<ol>
<li><p>智慧礼节的一般规则：</p>
<ul>
<li>除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。</li>
<li>不要争强好胜，非辩到底不可。</li>
<li>在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。</li>
</ul>
</li>
<li><p>批评观点的特别标准：</p>
<ul>
<li>证明作者的知识不足。</li>
<li>证明作者的知识错误。</li>
<li>证明作者不合逻辑。</li>
<li>证明作者的分析与理由是不完整的。</li>
</ul>
</li>
</ol>
<p>在我看来，第三阶段指出的批评观点的标准，使得人们更加容易清楚自己的立场是如何而来的。作者是这样说的：「如何你不能用相关证据显示作者是知识不足、知识有误，或不合逻辑，你就不能反对他」。很多人面对一些结论的时候，表现出强烈的反对，但是如果你发现他不能按以上标准来反对的话，就说明他并不真正在反对，只是「不喜欢」这个结论，而这只是在表达一种情绪或者偏见。我们应该尽量避免陷入情绪中，或者至少应该在陷入情绪中时，知道自己当前只是在发泄，而不是在讨论问题。</p>
<h3 id="u4E3B_u9898_u9605_u8BFB"><a href="#u4E3B_u9898_u9605_u8BFB" class="headerlink" title="主题阅读"></a>主题阅读</h3><p>作者将主题阅读分为两个阶段。</p>
<p>第一阶段：准备：</p>
<ol>
<li>针对要研究的主题，列出书单。</li>
<li>浏览书单中的书，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。</li>
</ol>
<p>第二阶段：阅读：</p>
<ol>
<li>从书单中的书中，找出与主题最相关的章节。</li>
<li>根据主题创造出一套中立的词汇，带引作者与你达成共识。</li>
<li>建立一个中立的主旨，列出一连串的问题，使大多数的作者为解读这些问题提供了他们的回答。</li>
<li>界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。</li>
<li>分析这些讨论。</li>
</ol>
<p>主题阅读的理想上要保持客观，当你要解读作者的某个观点时，必须从他文章中引一段话来并列。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>《如何阅读一本书》是一本用「方法论」来指导阅读行为的图书。这本书将阅读分为四个阶段，每个阶段又细分为一些具体的执行方法。使用书中介绍的方法，可以使得我们更快、更有效地获取图书中的关键信息。</p>
<p>更宽泛地说，《如何阅读一本书》培养的是一种获取有效信息的手段和习惯，不管是阅读图书，还是阅读博客、邮件以及平时讨论问题，我们都可以利用书中提到的分析阅读的方法，来获得有效的信息。另外，当涉及争论时，书提到的批评别人观点的方法也非常客观，这会使得大家的争论会更加理智。</p>
<p>本书不太好的地方在于内容太过啰嗦，如果能够将内容再精简一半，我可能会更喜欢一些。另外，将「略读」和「精读」换个名字成「检视阅读」和「分析阅读」，也让我觉得有些太夸张了一些。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/how-to-read-a-book.jpg">
<h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><p>最近常圳给我推荐了]]>
    </summary>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MagicalRecord 作者 Saul Mora 的故事]]></title>
    <link href="http://blog.devtang.com/2016/01/12/saul-introdution/"/>
    <id>http://blog.devtang.com/2016/01/12/saul-introdution/</id>
    <published>2016-01-12T14:20:45.000Z</published>
    <updated>2016-02-16T10:26:44.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/saul-mora.jpg">
<p>这次 Swift 开发者大会上，我认识到了一位新朋友，他叫 Saul Mora（如上图），听到这个名字时我没有什么感觉，但是随后旁边的一个朋友介绍道：「他是 MagicRecord」的作者之一，我突然眼睛亮了。</p>
<p>不知道有多少人听过 MagicRecord，MagicRecord 是一个基于 Core Data 的库，可以让你更加方便地使用 Core Data。在我学习 Core Data 时，曾经抱怨过 Core Data 一些设计过于繁琐，使用不方便，那时就常常会听到人们说：「你应该使用 MagicRecord」。而 MagicalRecord 的 Github 首页上 <a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="external">https://github.com/magicalpanda/MagicalRecord</a> ，已经有了 8000 多的 Star 数。</p>
<p>在我进一步和 Saul Mora 聊天时，我才发现，他的作品远远不只是 MagicRecord。他还是著名的 iOS 网站 Ray Wenderlich 的图书《Core Data by Tutorials》作者，并且发表了很多文章在 Ray Wenderlich 上。另外，他也是一个有趣的人，他维护着他的名为 NSBrief 的 podcast：<a href="http://nsbrief.com" target="_blank" rel="external">http://nsbrief.com</a>，采访了很多 iOS 和 Mac 的开发者。</p>
<p>好了，现在关键来了，Saul Mora 在硅谷工作得有些腻了，而且他想学习中文，于是他现在来到了中国，打算在北京、上海或成都找一份 iOS 开发的工作。</p>
<p>我想，这对于很多公司来说，都是一个千载难逢的机会，来招募到一位全球顶尖的 iOS 开发者。所以，如果你对 Saul 感兴趣，可以将你的公司介绍、希望他过去做的事情、大概的待遇，以及任何你觉得可以吸引他的信息，发到他的邮箱：</p>
<p>Saul@casademora.com</p>
<p>对了，Saul 现在还在学习中文，所以他还不能很流利地用中文交流。所以如果邮件用英文写的话，会更有利于他考虑工作机会哟。</p>
<p>感谢 Saul 给开源社区的贡献，也祝福他在中国能够开始一段愉快的经历！</p>
<hr>

<p>以下是 Saul 写的自我介绍：</p>
<p>About Saul</p>
<p>Saul Mora is an American iOS developer. He has been involved with the iOS community for several years. He has helped start Cocoaheads and NSCoderNight meetups in Phoenix, Arizona and Denver, Colorado. </p>
<p>He is the author of MagicalRecord (<a href="http://magicalrecord.com" target="_blank" rel="external">http://magicalrecord.com</a>), the iOS framework for use with Core Data. Saul is a co-author of Core Data by Tutorials (<a href="http://www.raywenderlich.com/store/core-data-by-tutorials" target="_blank" rel="external">http://www.raywenderlich.com/store/core-data-by-tutorials</a>) published with Ray Wenderlich (<a href="http://raywenderlich.com" target="_blank" rel="external">http://raywenderlich.com</a>)</p>
<p>Over the past few years, Saul has produced the NSBrief podcast (<a href="http://nsbrief.com" target="_blank" rel="external">http://nsbrief.com</a>) to talk to many developers in the iOS and Mac development community. Saul has also shared his knowledge in person all over the world giving talks at many developer conferences in the USA and Europe. </p>
<p>Saul has spent the last year in Silicon Valley and has recently decided to move to China to pursue his goal to become fluent in the Chinese language. He is eager to meet iOS developers everywhere and share his knowledge and experience with all the developers in China.</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/saul-mora.jpg">
<p>这次 Swift 开发者大会上，我认识到了一位新朋友，他叫 Saul Mora（如上图），听到这个名字时我没有什么感觉，但是随后旁边的一个朋友介绍道：「他是 MagicRecord」的作者之一，我突然眼睛亮]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[首届 Swift 开发者大会见闻]]></title>
    <link href="http://blog.devtang.com/2016/01/10/atswift-conference-summary/"/>
    <id>http://blog.devtang.com/2016/01/10/atswift-conference-summary/</id>
    <published>2016-01-10T14:31:55.000Z</published>
    <updated>2016-02-29T13:19:13.000Z</updated>
    <content type="html"><![CDATA[<p>今天是中国 iOS 开发者的一次聚会，因为首届 Swift 开发者大会在北京成功举办了。这次会议的质量很高，大会的相关 keynote 和 视频，稍后都会在官网上公开，所以没能参会的同学可以关注官网（ <a href="http://atswift.io/" target="_blank" rel="external">http://atswift.io/</a> ）的内容更新。我作为大会的主席（其实基本没出什么力）全程参与了全天的大会，在此记录下一些参会的见闻。</p>
<p>先说说本次的大会的演讲内容吧。这次大会的 Keynote 可<a href="https://github.com/atConf/atswift-2016-resources" target="_blank" rel="external">在此下载</a>。</p>
<p>2016.02.29更新：中国首届swift开发者大会的视频已经放出：<a href="http://www.imooc.com/learn/600" target="_blank" rel="external">http://www.imooc.com/learn/600</a></p>
<h3 id="Chris"><a href="#Chris" class="headerlink" title="Chris"></a>Chris</h3><p>开场的是 objc.io 的创始人 Chris Eidhof。Chris 是大会演讲者中唯一没有准备 keynote 的人，但是演讲相当精彩。Chris 虽然没有 keynote，但是内容是精心准备过的，他先用 playground 简单介绍了一些 Swift 的内容后，就转到一个游戏 Demo 的重构工作中，整个重构工作包括几点：</p>
<ol>
<li>用 typealias 去掉 NSUserDefaults 的依赖。</li>
<li>用 protocol 来代替继承。</li>
<li>用 extension 来实现 protocol。</li>
<li>尽量用 struct。 </li>
<li>全程用 testcase 来验证重构过程。</li>
</ol>
<p>最终，我们看到了一个重构之后的游戏 Demo，相比以前的工程，重构后的项目代码更短，逻辑更清晰。</p>
<p>人们常说，Talk is cheap, show me the code。 Chris 用行动让我们看到如何写出更好的 Swift 代码。</p>
<h3 id="u5085_u82E5_u611A"><a href="#u5085_u82E5_u611A" class="headerlink" title="傅若愚"></a>傅若愚</h3><p>傅若愚来自 thoughtworks，和我一样是成都人。他这次的演讲主题是《越过 OC 与 Swift 间的鸿沟》，对于正在经历从 OC 到 Swift 转型的各位来说，非常实际。</p>
<p>他从一段代码来引出了大家的好奇，下面这段代码，居然会有两种输出结果，你猜出来是什么原因了吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">someArray = [1, 2, 3]&#10;var result = someArray.map(&#123;&#34;No. \($0)&#34;&#125;)</span><br></pre></td></tr></table></figure>
<p>接着傅若愚介绍了从 OC 转到 Swift 需要注意的地方：</p>
<ol>
<li>优先用 protocol 而不是继承</li>
<li>更多通过 annum, struct, extension 来达成目的。</li>
</ol>
<p>最后，他展示了一个利用函数式编程来重构代码的例子。</p>
<h3 id="Greg"><a href="#Greg" class="headerlink" title="Greg"></a>Greg</h3><p>Greg 是加拿大多伦多的一位 iOS 自由职业者，亚裔，看起来非常像中国人，但是其实他不会说中文。他在为著名 的 raywenderlich.com 撰写博客。本次他分享的是《Swift Style》。</p>
<p>在介绍了编写易读的代码的重要性之后，他从以下 3 方面介绍了他的 Swift 经验：</p>
<ol>
<li>Value types</li>
<li>Protocol</li>
<li>Safety</li>
</ol>
<p>提问环节的时候，Chris 当托似地问了一个非常有趣的问题：「你最近 1 年在写 Swift 代码上有何转变？」。</p>
<p>这个问题非常有意思，Greg 说他现在用了更多的 guard 关键词，然后 Greg 也说到，他写习惯 Swift 之后，因为养成了强类型检查的习惯，他偶尔回去写 oc 的时候会不停地 check 各种 nil。</p>
<h3 id="u674E_u6D01_u4FE1"><a href="#u674E_u6D01_u4FE1" class="headerlink" title="李洁信"></a>李洁信</h3><p>李洁信是下午第一场，非常犯困的时间。洁信稍微有一些紧张，内容是关于《Swift 中的协议编程》，他把这些内容都梳理得挺好的，讲得挺清楚。</p>
<h3 id="u738B_u5DCD"><a href="#u738B_u5DCD" class="headerlink" title="王巍"></a>王巍</h3><p>喵神王巍是下午第二场，王巍的主题是《如何打造一个让人愉快的框架》，喵神的准备非常充分，演讲过程中还各种卖萌，实在是非常可爱。喵神主要从以下几个方面介绍了框架的开发：</p>
<ol>
<li>静态库和框架的对比</li>
<li>包和依赖管理</li>
<li>创建框架</li>
<li>一些 Tips</li>
<li>发布框架</li>
<li>持续集成</li>
</ol>
<p>如果你希望基于 Swift 来开发一个 framework，非常值得看看喵神的分享。</p>
<h3 id="u5305_u6DB5_u537F"><a href="#u5305_u6DB5_u537F" class="headerlink" title="包涵卿"></a>包涵卿</h3><p>包涵卿讲的是《Swift 函数式编程实践》，这块其实是挺难讲的，前面的一些函数式编程的基础还好，比如柯里化之类，但是后面估计比较难理解，我不知道现场有多少人听懂了 Monad 的概念，不过这个确实是比较挑战的话题。</p>
<h3 id="u7FC1_u9633"><a href="#u7FC1_u9633" class="headerlink" title="翁阳"></a>翁阳</h3><p>这场话题茶歇回去之后听了一半，所以没怎么整理出来笔记。有些遗憾。</p>
<h3 id="u5468_u6977_u96EF"><a href="#u5468_u6977_u96EF" class="headerlink" title="周楷雯"></a>周楷雯</h3><p>周楷雯的分享里介绍了各种性能优化的技巧。可惜他当时手机变砖，有一些着急，讲得比较快，很多点感觉展开讲会更好一些。</p>
<h3 id="u540E_u8BB0"><a href="#u540E_u8BB0" class="headerlink" title="后记"></a>后记</h3><p>这次 Swift 大会中还做了一些有趣的调查，在此将数据分享给大家：</p>
<ol>
<li>这次有 3/4 的听众来自外地！</li>
<li>现场有 1/3 的听众已经开始将 Swift 应用于公司项目开发中。</li>
</ol>
<p>这次大会的组委会都很棒，包括梁杰、裕波、王臣汉、陈雨恒、李涛（还有一些我没能记住名字的同学）都对这次大会付出了大量心血。作为一个非赢利性的 Swift 大会，我觉得他们做到了内容的高质量，期待明年的第二届大会如期进行！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天是中国 iOS 开发者的一次聚会，因为首届 Swift 开发者大会在北京成功举办了。这次会议的质量很高，大会的相关 keynote 和 视频，稍后都会在官网上公开，所以没能参会的同学可以关注官网（ <a href="http://atswift.io/" target=]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ReactiveCocoa 讨论会]]></title>
    <link href="http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/"/>
    <id>http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/</id>
    <published>2016-01-03T07:22:13.000Z</published>
    <updated>2016-02-16T10:26:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>（其简称为 RAC）是由 <a href="https://github.com/blog/1107-reactivecocoa-for-a-better-world" target="_blank" rel="external">Github</a> 开源的一个应用于 iOS 和 OS X 开发的新框架。RAC 具有函数式编程和响应式编程的特性。它主要吸取了 .Net 的 <a href="http://msdn.microsoft.com/en-us/data/gg577609" target="_blank" rel="external">Reactive Extensions</a> 的设计和实现。</p>
<p>但是，相对于传统的 MVC 架构，ReactiveCocoa 的函数式编程方式的学习曲线陡峭，业界也没有丰富的图书资料，这使得大家对这种技术望而却步。这次，我邀请了一些行业内关注和使用 ReactiveCocoa 的内行，进行了一次关于 RAC 的讨论会，会上大家主要聊了 RAC 在使用中的各种问题，我们希望这次讨论会能够让重新全面审视这个开发框架。</p>
<h2 id="u8BA8_u8BBA_u6210_u5458"><a href="#u8BA8_u8BBA_u6210_u5458" class="headerlink" title="讨论成员"></a>讨论成员</h2><p>本次讨论会邀请到的讨论者来自美团，百度，蘑菇街等公司。讨论前为了先相互认识，我让大家自我介绍了一下，并且顺便简单介绍各自所在的团队人数以及使用 RAC 的时长，以下是大家的自我介绍：</p>
<ul>
<li><p>臧成威，来自美团，团队基本都在使用 RAC，从 14 年初开始使用 RAC。在美团搞过 RAC 的几期培训，有丰富的经验。</p>
</li>
<li><p>李忠 (limboy)，来自蘑菇街。李忠的博客（<a href="http://limboy.me/" target="_blank" rel="external">http://limboy.me/</a>）上有很多介绍 RAC 的高质量文章。（这次讨论会李忠当时有事没有参加，事后对相关问题留言表达了自己的看法）</p>
</li>
<li><p>唐晓轩 (txx)，来自礼物说，团队四个人，目前 “只有” 礼物说这一款产品。从年初开始使用 RAC，到现在正在安利 Android  团队使用 RXJava。</p>
</li>
<li><p>孙源 (sunnyxx)，来自百度，从 13 年年底开始接触 RAC，当时边学边用 RAC 写了一个完整的项目，那时候还没现在这么火（当时 Limboy 的文章看了好几遍），后来在项目中在一个完整模块中尝试使用过，因为大家对函数响应式编程了解程度差别很大，导致代码几乎无法维护，随后重构。现在也有时用到，但都用于某个特定的功能的便捷实现上，无 MVVM，基本不会跨类使用。</p>
</li>
<li><p>雷纯锋，来自广州支点网络科技股份有限公司，团队三个人使用 RAC ，从 12 年 6 月份开始使用 RAC ，公司项目一直使用的是 RAC。项目中一直也是用的 MVVM + RAC 的结构，另外我也有在维护一个 MVVM + RAC 的开源项目，叫 MVVMReactiveCocoa。</p>
</li>
<li><p>汤圣罡 (lexurs)，来自新味，2 个 iOS。RAC 经验两年。目前在用 Overcoat+Mantle+ReactiveCocoa 实现的网络层，某些逻辑多的页面也喜欢用 RAC 实现。因为想全部改成 Swift，正在投靠 RxSwift 和 PromiseKit 的过程中。</p>
</li>
<li><p>李雄略 (听榆大叔)，来自网家缘科技，分 2 个产品，每个产品 2 个 iOS 开发，从 14 年 3 月份开始使用 RAC，已在 3 个项目中使用 RAC。</p>
</li>
<li><p>蓝晨钰 (lancy)，来自猿题库，没有在公司项目使用过 RAC。个人喜欢 RAC，私底下写过 RAC 的小项目，读过 RAC 源码，但对 RAC 在大型项目中和团队合作中持谨慎态度，猿题库的架构是类 MVVM 架构，但没有引入 RAC。</p>
</li>
<li><p>唐巧（就是本文作者），来自猿题库，团队分 3 个产品，每个产品约 4 个 iOS 开发，没有在公司正式使用过 RAC，自己私下写过几百行 RAC 的代码，对于 RAC 是比较保守的一个人。</p>
</li>
</ul>
<p>好了，以下就是我们具体讨论的一些问题。</p>
<h3 id="u8BA8_u8BBA_uFF1A_u5982_u4F55_u5728_u56E2_u961F_u5185_u63A8_u5E7F_u5E76_u7528_u300C_u6B63_u786E_u7684_u59FF_u52BF_u300D_u4F7F_u7528_RAC_uFF1F"><a href="#u8BA8_u8BBA_uFF1A_u5982_u4F55_u5728_u56E2_u961F_u5185_u63A8_u5E7F_u5E76_u7528_u300C_u6B63_u786E_u7684_u59FF_u52BF_u300D_u4F7F_u7528_RAC_uFF1F" class="headerlink" title="讨论：如何在团队内推广并用「正确的姿势」使用 RAC？"></a>讨论：如何在团队内推广并用「正确的姿势」使用 RAC？</h3><p>大家提到在使用 RAC 的时候，出现的一些问题，例如：</p>
<ul>
<li>不是太精通 RAC 的同学往往写出来的非常难以维护</li>
<li>不知道新队友的 RAC 培养路径，Functional Programming -&gt; MVVM -&gt; ….</li>
</ul>
<p>对于难以维护的问题，臧成威的意见是：</p>
<blockquote>
<p>这个美团这边的解决方案主要是 review，review 可以保证项目中所有人的范式是相同的，大家对于不同的写法都会有充分的讨论，而我们的新手主要是参考旧代码的风格写出新代码，所以并没有发生难以维护这一现象。</p>
<p>但是前提是需要有很熟悉的人来带领，团队中熟悉 RAC 的人员基数得以保证。而且美团的 RAC 使用还是逐步放量的，从一开始的 UI 层使用，到底层逻辑层的使用，最后才到了 MVVM 的粘合层使用，这样避免了泛滥。</p>
<p>总结来说，对于 RAC 这样厚重的库，引入的时候的 review 是必要的，否则可控性太差，最后就难以收场了。</p>
</blockquote>
<p>总结起来就是：1、review + 有熟练的人带；2、逐步放开使用。</p>
<p>对于人才的培养，臧成威的意见是：</p>
<blockquote>
<p>RAC 的培养，从我这边三期的培训来看，课程的安排是这样的六节： 1. FRP 的思想概要 2. RAC 的 operations 介绍 3. 冷信号与热信号解惑 4. 生命周期指南 5. disposable 和多线程 6. 实战分享</p>
<p>其中先建立 FRP 的思想，虽然看起来是最远的，但是确实是后续使用和教学的基础。</p>
<p>一起培训大概有 30-50 人来听，课程一种持续三周，每周 2 节课、课程过后的 2 周，就可以发现代码中的 rac 使用明显提升</p>
<p>另外补充一点，关于新手学习，最不建议的就是在不了解 FRP 原理和一些基础概念的情况下，盲目的看源代码。我见过太多的同学，花费了很多的时间通览源码，但是根本没有用途。因为从思想到源代码是经历了很多雕琢的。里面有太多的 bugfix，太多的折中。</p>
<p>所以你看的时候，抛开了本质，一味的查看边界的处理，最后大都觉得痛苦，难用，难以掌握收场。</p>
<p>唐巧：RAC 确实和其它的开源库性质上差别比较大，思想方面需要学习的比较多。</p>
<p>是的，关键是思想。所以，一定要先从 “道” 上建立思想，然后从 “术” 上掌握使用，最后才是通览源码，掌握其原理。</p>
<p>第一节是道的课程，第二节是术的课程。这两节下来就知道能干什么了。</p>
</blockquote>
<p>雷纯锋意见也与臧成威一致。</p>
<p>唐晓轩介绍了一下他自己的学习过程：</p>
<blockquote>
<p>我是反着做的，先把 rac 当作 blocks kit 用 之后 看 racstream 的各种 operations，知道 rac 有哪些运算 其次 看 rac 的 uikit 扩展都是怎么实现的 最后才是函数式思维。</p>
</blockquote>
<p>我顺着臧成威的回答，问了一下通常使用 RAC 的规范是什么，臧成威回答道：</p>
<blockquote>
<p>大家可以参考这样的一条规范来做，首先通过 RACSignal#return RACSignal#createSignal 这类的创建一个 OOP 世界到 FRP 世界的一个转换，从而得到一个 Signal。</p>
<p>之后 signal 在不接触 OOP 的情况下进行数据的各类变换，注意 FP 的引用透明和变量不可变特性。</p>
<p>最后用 RAC 宏、RACSignal#subscribe、NSObject+liftSelect 这些操作把 FRP 的世界带回到 OOP 的世界里。</p>
</blockquote>
<p>臧成威还很体贴地画了一个示意图，非常给力：</p>
<img src="/images/fpr_oop_pattern.jpg">
<h3 id="u8BA8_u8BBA_uFF1A_u5927_u516C_u53F8_u7684_u5927_u578B__28_u81C3_u80BF_29_App__u662F_u5426_u9002_u5408_u4F7F_u7528_RAC_uFF1F"><a href="#u8BA8_u8BBA_uFF1A_u5927_u516C_u53F8_u7684_u5927_u578B__28_u81C3_u80BF_29_App__u662F_u5426_u9002_u5408_u4F7F_u7528_RAC_uFF1F" class="headerlink" title="讨论：大公司的大型 (臃肿) App 是否适合使用 RAC？"></a>讨论：大公司的大型 (臃肿) App 是否适合使用 RAC？</h3><p>由于第一个话题臧成威贡献最多内容，加上美团是大家所知道的使用 RAC 最多的大型 App，所以这个话题还是由臧成威首先回答，以下是他的发言。</p>
<blockquote>
<p>越大型的 app，说明内部的逻辑越复杂。而 RAC 从某几方面可以简化逻辑，使得代码从书写到执行都可以较为简化的完成功能</p>
<p>我大概总结了几个适用的场景。RAC 总结来说就是：数据随着时间而产生，所以能想到的三点比较适合用 RAC：</p>
<p>一、UI 操作，连续的动作与动画部分，例如某些控件跟随滚动。</p>
<p>二、网络库，因为数据是在一定时间后才返回回来，不是立刻就返回的。</p>
<p>三、刷新的业务逻辑，当触发点是多种的时候，业务往往会变得很复杂，用 delegate、notification、observe 混用，难以统一。这时用 RAC 可以保证上层的高度一致性，从而简化逻辑上分层。</p>
<p>只要有通知的业务逻辑，RAC 都方便有效化解。</p>
<p>雷纯锋：概括的说，应该就是统一所有异步事件吧。</p>
<p>不适用的场景，与时间无关的，需要积极求解的计算，例如视图的单次渲染。</p>
</blockquote>
<p>接着发言的是百度的孙源：</p>
<blockquote>
<p>我这是百度知道，体量比较小，可以随便玩。</p>
<p>我们现在就用它做点小功能，举个例子吧，聊天页面那个键盘弹出时 input bar 跟随滚动的功能，原来写需要接通知、写回调，现在在一个函数里面用 RAC 就比较方便。</p>
<p>像这种小功能，主要是方便开发，让 “干一个事儿的代码写在一个地方”。</p>
</blockquote>
<p>雷纯锋说他们的使用还是比较多：</p>
<blockquote>
<p>基本上异步的事件能用 RAC 的都用的 RAC。</p>
<p>不过代理方法用 RAC 的比较少，比如 UITableView 的代理方法一般都是直接写了。</p>
<p>用 RACSubject + RACComand 来简化和统一应用的错误处理逻辑，这个算比较经典的吧。</p>
<p>臧成威说：UI 交互上的点确实好多，比如下拉刷新、上拉导航条变透明。</p>
<p>实时响应用户的输入，控制按钮的可用性，这点用 RAC 来实现非常简单。</p>
</blockquote>
<p>李雄略说：</p>
<blockquote>
<p>我们主要用来处理界面上的数据显示，以及 UI 的交互操作上，不会用来写代理。</p>
</blockquote>
<p>对于这个话题，似乎大家的答案还是比较一致，即：大型 App 是适合使用 RAC 的。</p>
<h3 id="u8BA8_u8BBA_uFF1A_u90FD_u8BF4_u8C03_u8BD5_RAC__u5F88_u75DB_u82E6_uFF0C_u662F_u5426_u6709_u4E00_u4E9B_u8C03_u8BD5_u6280_u5DE7_u548C_u7ECF_u9A8C_u5206_u4EAB_uFF1F"><a href="#u8BA8_u8BBA_uFF1A_u90FD_u8BF4_u8C03_u8BD5_RAC__u5F88_u75DB_u82E6_uFF0C_u662F_u5426_u6709_u4E00_u4E9B_u8C03_u8BD5_u6280_u5DE7_u548C_u7ECF_u9A8C_u5206_u4EAB_uFF1F" class="headerlink" title="讨论：都说调试 RAC 很痛苦，是否有一些调试技巧和经验分享？"></a>讨论：都说调试 RAC 很痛苦，是否有一些调试技巧和经验分享？</h3><p>臧成威说：</p>
<blockquote>
<p>的确很痛苦，跟断点有的时候计算堆栈都要等几分钟。</p>
<p>关于调试，RAC 源码下有 instruments 的两个插件，方便大家使用。</p>
<p>signalEvents 这个可以看到流动的信号的发出情况，对于时序的问题可以比较好的解决。</p>
<p>diposable 可以检查信号的 disposable 是否正常</p>
</blockquote>
<img src="/images/rac-instrument.jpg">
<p>小伙伴们看了纷纷惊叹，表示以前没有用过这个神器。</p>
<p>雷纯锋接着分享：</p>
<blockquote>
<p>我的理解是一般给信号一个名字，然后通过下面的打印方法来进行调试。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// Logs all events that the receiver sends.&#10;- (RACSignal *)logAll;&#10;&#10;/// Logs each `next` that the receiver sends.&#10;- (RACSignal *)logNext;&#10;&#10;/// Logs any error that the receiver sends.&#10;- (RACSignal *)logError;&#10;&#10;/// Logs any `completed` event that the receiver sends.&#10;- (RACSignal *)logCompleted;</span><br></pre></td></tr></table></figure>
<p>李雄略说：</p>
<blockquote>
<p>我是用 log 方法来做的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DExecute((&#123;&#10;    setenv(&#34;RAC_DEBUG_SIGNAL_NAMES&#34;, &#34;RAC_DEBUG_SIGNAL_NAMES&#34;, 0);&#10;    [signalUserGeo setNameWithFormat:@&#34;signalUserGeo&#34;];&#10;    signalUserGeo = [signalUserGeo logAll];&#10;&#125;));</span><br></pre></td></tr></table></figure>
<p>李忠的补充：</p>
<blockquote>
<p>调试的话，如果是性能调试，主要是经验 +Instruments，经验类似于：少用 RACCommand、RACSequence 这样的，Instruments 可以用它的 Time Profile 来看。</p>
<p>如果是 Bug 调试，主要还是靠 Log，配合一些 Xcode 插件，比如 MCLog(可以很方便地过滤日志)，如果要还原堆栈的话，就加一个断点。</p>
</blockquote>
<p>接下来大家讨论起来：<br>&gt;</p>
<blockquote>
<p>臧成威：其实 instruments 也差不多，只是第一，不需要提前调用 logAll 这些；第二，可以利用 instruments 的筛选功能，不会看 log 看到眼花。</p>
<p>雷纯锋：实际调试起来好用吗？</p>
<p>臧成威：好用的，还可以看到发出 value 的堆栈。</p>
<p>雷纯锋：使用 instruments 来调试的频率大吗？或者说在什么情况下会去用 instruments 调试呢？</p>
<p>臧成威：一般调查问题的时候就它来查。比如某个信号接不到输出。</p>
<p>臧成威：或者输出的值里面有错误的，但是是经过 merge、zip 等好多操作混合出来的，不知道源头是神马。</p>
<p>雷纯锋：也就是说一般是在有问题，然后分析不出来的时候，才使用吗？</p>
<p>臧成威：是的，一般是调查问题的时候用的，不是开发的时候用的，因为打开是比较慢的。</p>
<p>李雄略：为了方便，我们保证一个 RACSignal 只会给订阅者 send 一种类型的 value，所以就手动给 signal 加了部分泛型支持：</p>
<p>@interface RACSignal<__covariant objecttype=""> : RACStream</__covariant></p>
<p>RACSignal<nsstring *=""> *signal = …</nsstring></p>
<p>孙源：用泛型，然后 map 之后呢</p>
<p>李雄略：map 无法支持</p>
<p>臧成威：RAC3 里面就有不错的泛型推导，但是是基于 swift 的。</p>
<p>臧成威：这个我也想过，但是语言不支持，基本上是搞不定的</p>
<p>孙源：调试这块也就是 log name 了。作者 guide 里面也是这么弄，用 Instrument 已经是高级技巧。</p>
<p>臧成威：加 log 比较不好的就是容易眼花，还有不好还原当时的堆栈。</p>
<p>孙源：我一般遇到问题，都是看代码脑补一遍过程，函数式就好在这里，基本上看着对了结果就没错。脑回路逻辑推导。</p>
<p>臧成威：是的，推导很有道理。我觉得 sunnyxx 说的是王道，所以培训，给大家建立思维很重要。</p>
<p>雷纯锋：恩，分析清楚整个运算过程是很重要的</p>
</blockquote>
<h3 id="u8BA8_u8BBA_uFF1ARAC__u76F8_u6BD4_RxSwift__u548C_PromiseKit__u6709_u54EA_u4E9B_u4F18_u7F3A_u70B9__3F"><a href="#u8BA8_u8BBA_uFF1ARAC__u76F8_u6BD4_RxSwift__u548C_PromiseKit__u6709_u54EA_u4E9B_u4F18_u7F3A_u70B9__3F" class="headerlink" title="讨论：RAC 相比 RxSwift 和 PromiseKit 有哪些优缺点 ?"></a>讨论：RAC 相比 RxSwift 和 PromiseKit 有哪些优缺点 ?</h3><p>臧成威继续分享：</p>
<blockquote>
<p>RAC vs RxSwift 的情况是这样：</p>
<p>从支持度来说，RAC 对 Cocoa 的支持更好。但是从标准性、性能来讲 RxSwift 更胜一筹。</p>
<p>因为毕竟是 Rx 团队的亲生项目。还有，OC 只有 RAC 支持，RxSwift 搞不定。</p>
<p>雷纯锋：需要在 Obj-C 下和 Swift 下，分别来比较吧？那 Obj-C 下，用 RAC 应该是没有疑问的了吧，那在 Swift 下呢？</p>
<p>Swift 场景下，由于 OC 做好的 bridge，所以 RAC3swift，仍然有不错的整合性。例如 notification、observer 这些。但是 RxSwift 与框架无关，所以这些功能需要自己补了。</p>
<p>但是 RxSwift 比较标准，和 RxJS、RxJava 所有定义统一，所以迁移过来很容易。但 RxJS 和 RxJava 的原始用户比较少，这点不大明显。</p>
<p>这是 Rx 和 RAC 的对比。</p>
<p>RAC3 swift 版有个特性，就是热信号传导，这点 RxSwift 没有。对于特定的场景来说，热信号传导更好。</p>
<p>PromiseKit 是一种异步库，思想和 FRP 不一样。</p>
<p>PromiseKit 应该和 js 的 promise 库差不多的意思吧，这个我是靠猜的。</p>
</blockquote>
<h3 id="u8BA8_u8BBA_uFF1ARAC__u5728_u5DE5_u7A0B_u4E2D_u4F7F_u7528_u8303_u56F4_u7684_u754C_u9650_uFF0C_u5F80_u5F80_u4E00_u5904_RAC__u5C31_u4F1A_u5F15_u8D77_u548C_u4ED6_u76F8_u5173_u6A21_u5757_u7684_RAC__u5316_uFF0C_u5982_u4F55_u786E_u5B9A_u754C_u9650_u5462_uFF1F"><a href="#u8BA8_u8BBA_uFF1ARAC__u5728_u5DE5_u7A0B_u4E2D_u4F7F_u7528_u8303_u56F4_u7684_u754C_u9650_uFF0C_u5F80_u5F80_u4E00_u5904_RAC__u5C31_u4F1A_u5F15_u8D77_u548C_u4ED6_u76F8_u5173_u6A21_u5757_u7684_RAC__u5316_uFF0C_u5982_u4F55_u786E_u5B9A_u754C_u9650_u5462_uFF1F" class="headerlink" title="讨论：RAC 在工程中使用范围的界限，往往一处 RAC 就会引起和他相关模块的 RAC 化，如何确定界限呢？"></a>讨论：RAC 在工程中使用范围的界限，往往一处 RAC 就会引起和他相关模块的 RAC 化，如何确定界限呢？</h3><p>臧成威：这个我觉得有点危言耸听了吧，对上对下是可以有效包装，逐步放量的。</p>
<p>臧成威：默认作为一种上下模块的通信协议，也不是很危险的事，所以我觉得没有太大的风险。上层拿到一个 RACSignal 就当做一个 BlockKit 的回调方式就可以。这样可以有效控制代码。</p>
<p>雷纯锋：这个我觉得要看模块之间用什么来通信吧。</p>
<p>李忠：这个我觉得还是跟使用场景有关。如果只是简单的对外暴露一个 property，外部直接 KVO 即可，甚至不用关心 RAC。但如果在一些比较复杂的场景使用 RAC 的话，很难做到对上层透明，除非内部的封装做得足够彻底。</p>
<p>李忠：比如网络请求，返回一个 <code>RACSignal</code>，然后外部 <code>subscribeNext</code> 之后，想要取消怎么办？这时只能保存一个 <code>RACDisposable</code> 变量，然后在适当的时机调用 <code>dispose</code> 方法；或者要等待 2 个请求一起完成，再做一些事情（当然可以通过 semaphore / dispatch_group 来做，但这样就丢了 RAC 的特性）等等。</p>
<p>李忠：所以还是要在项目初期就想清楚，如果团队成员对 RAC 都比较熟悉，那自然最好。如果其他人不太了解，甚至抵触，这时就要避免在复杂的场景下使用。</p>
<h3 id="u8BA8_u8BBA_uFF1A_u6709_u4EC0_u4E48_u5B66_u4E60_RAC__u597D_u7684_u8D44_u6599_u5417_uFF1F"><a href="#u8BA8_u8BBA_uFF1A_u6709_u4EC0_u4E48_u5B66_u4E60_RAC__u597D_u7684_u8D44_u6599_u5417_uFF1F" class="headerlink" title="讨论：有什么学习 RAC 好的资料吗？"></a>讨论：有什么学习 RAC 好的资料吗？</h3><p>臧成威：李忠的博客不错：<a href="http://limboy.me/" target="_blank" rel="external">http://limboy.me/</a></p>
<p>唐巧：之前雷纯峰特别推荐美团的几篇博客：<a href="http://tech.meituan.com/tag/ReactiveCocoa" target="_blank" rel="external">http://tech.meituan.com/tag/ReactiveCocoa</a></p>
<p>李忠：coursera 上有一门课是讲 Reactive Programming 的 ( <a href="https://www.coursera.org/course/reactive" target="_blank" rel="external">https://www.coursera.org/course/reactive</a> ) ，也会讲到 Functional Programming。</p>
<p>雷纯锋：我写的这篇是范围比较广一点。<a href="http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/</a> 《ReactiveCocoa v2.5 源码解析之架构总览》</p>
<p>另外要关于 Monad 的也有一篇，<a href="http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/</a> 《Functor、Applicative 和 Monad》</p>
<p>雷纯锋：raywenderlich 上的文章：<br><a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1</a>、<br><a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2</a>、<br><a href="http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1" target="_blank" rel="external">http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1</a>、<br><a href="http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2" target="_blank" rel="external">http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2</a>。</p>
<p>唐巧：我之前看过一本 《Functional Reactive Programming on iOS》，不过还是不够深入。</p>
<p>臧成威：话说，看懂 Haskell，理解 RAC 就不是难事了。</p>
<p>雷纯锋：是的，所以如果要理解 RAC 的思想的话，Haskell 可以学一下。<a href="http://learnyouahaskell.com/" target="_blank" rel="external">http://learnyouahaskell.com/</a></p>
<h3 id="RACSequence__u7684_u6027_u80FD_u95EE_u9898"><a href="#RACSequence__u7684_u6027_u80FD_u95EE_u9898" class="headerlink" title="RACSequence 的性能问题"></a>RACSequence 的性能问题</h3><p>讨论到最后大家还涉及到了 RACSequence 的性能问题。记录如下：</p>
<blockquote>
<p>臧成威：了解了概念后，看源码就很爽了，是 OC 语言的典范。</p>
<p>臧成威：不过看了 RACSequence 的实现，性能是无法使用的。</p>
<p>雷纯锋：无法使用？你们不用 RACSequence 吗？</p>
<p>臧成威：是的，Sequence 的性能很差。</p>
<p>臧成威：由于 OC 没有引用透明和尾递归优化。</p>
<p>雷纯锋：你们没有过吗？</p>
<p>臧成威：你试试 100 个长度的数组进行遍历排序，然后再变回来就明白了。</p>
<p>臧成威：现在都去掉了。</p>
<p>雷纯锋：它主要是用来实现懒计算吧。</p>
<p>雷纯锋：方便集合的转换吧，常规的遍历也不会使用它吧？</p>
<p>臧成威：就是说集合转换的性能太差了。</p>
<p>雷纯锋：恩，以后留意一下</p>
</blockquote>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>本次分享内容的主要贡献来自美团的臧成威同学，从美团的实践中我们也能看到，在有充足经验的人指导下，RAC 不但可以应用于大型项目，也可以工作得很舒服。</p>
<p>最后感谢参加这次讨论会的臧成威、李忠、唐晓轩、孙源、雷纯锋、汤圣罡、李雄略、蓝晨钰，希望他们的分享对大家有所帮助。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/ReactiveCocoa/ReactiveCo]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015 年个人总结]]></title>
    <link href="http://blog.devtang.com/2016/01/02/2015-summary/"/>
    <id>http://blog.devtang.com/2016/01/02/2015-summary/</id>
    <published>2016-01-02T11:08:13.000Z</published>
    <updated>2016-02-16T10:28:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5173_u4E8E_u521B_u4E1A"><a href="#u5173_u4E8E_u521B_u4E1A" class="headerlink" title="关于创业"></a>关于创业</h2><p>今年猿题库顺利拿到了 D 轮 6000 万美元的 <a href="http://36kr.com/p/531286.html" target="_blank" rel="external">融资</a>，估值 3.6 亿美元。而我负责的 <a href="http://www.yuansouti.com/" target="_blank" rel="external">小猿搜题</a>，也从年初的几十万用户，增长到了 5000 多万用户。</p>
<p>今年是小猿搜题的风光年，我们上了「天天向上」，在各种黄金档节目中打电视广告，整体用户数据增长惊人。研究组、市场运营、内容部门各种给力，使得产品技术工作进展得非常顺利。</p>
<p>下图是小猿搜题登上 AppStore 教育榜榜首的截图。</p>
<img src="/images/xyst_appstore_1.jpg">
<h2 id="u6211_u7684_u5DE5_u4F5C"><a href="#u6211_u7684_u5DE5_u4F5C" class="headerlink" title="我的工作"></a>我的工作</h2><p>对于我自己来说，2015 年的工作主要分成上半年和下半年两个阶段。</p>
<p>上半年，我一边负责小猿搜题的 iOS 开发工作，一边负责小猿搜题技术团队的组建和协调工作。小猿搜题当前大部分同事都是在上半年入职到这个团队的。</p>
<p>下半年，团队成员磨合得差不多了，团队里面 iOS 同事也成长起来了，我自己能够从 iOS 具体的开发工作中脱身，使得我更多地关注产品和团队了。</p>
<p>下半年自己的工作主要聚焦到了管理业务和管理团队上，每天组织协调和沟通的事情很多，除了 Scrum 的定期会议外，我还得参加产品的 Scrum 会议和产品过稿，还有美术的过稿。另外，我时不时也需要和运营的同事沟通协调。</p>
<p>有时候忙完一整天不知道时间是如何过去的，然后又看着自己 iOS 开发技能慢慢变弱，有一种焦虑感。于是我首先开始多读书，接着就是总结，试图调整自己。</p>
<p>数据分析的工作让我知道任何的改进都是应该基于数据的，这样更加理性。所以，我拿了一个小本子，记录自己每天的详细时间花费情况。于是就有了下图这样的一页一页的记录。</p>
<img src="/images/evernotes.jpg">
<p>这样大概记录了一周多，我基本上知道了自己的时间是如何花掉的了。然后，我开始归类自己的时间花费，看看主要花在了哪些地方。对于一些优先级不高的事情，我会注意调整它，不要让它把重要的事情给耽误了。</p>
<p>我也开始总结一个产品技术负责人的工作。在想得差不多了之后，我利用每周一早上和 CTO 的沟通机会进行讨论，最终，我完成了文章：<a href="/2015/12/18/from-dev-to-manager/">《涅槃重生:我的技术转管理之路》</a>，并且在北京架构师峰会上做了相应的技术转管理分享。</p>
<p>现在我不那么焦虑了，不过觉得自己还是需要多学习和提高。</p>
<h2 id="u56FE_u4E66_u51FA_u7248"><a href="#u56FE_u4E66_u51FA_u7248" class="headerlink" title="图书出版"></a>图书出版</h2><p><a href="http://item.jd.com/11598468.html" target="_blank" rel="external">《iOS 开发进阶》</a> 在 2015 年 1 月份顺利出版，然后首印 3000 册迅速卖掉了，出版社加印了 2000 册，然后过一周又卖光了，然后他们加印了 5000 册。之后又陆续有加印，最终到年底的时候，《iOS 开发进阶》销售了 17000 册，我听出版社老师说，这个成绩在技术图书里面是算相当好的。</p>
<img src="/images/ios_pro_17000.jpg">
<p>虽然称不上完美无缺，我个人对这本书的自评是问心无愧的。我用 Scrum 的管理方式来管理这本书的写作过程，我想在互联网时代，按时发布产品比什么都重要，所以，虽然有很多想继续完善的地方，我还是把它付印了。我也把写这本书的过程总结下来，完成了 <a href="/2015/01/11/how-to-finish-ios-pro-book/">《我是如何完成《iOS 开发进阶》的编写的》</a>，希望能给想出书的同行一些帮助。</p>
<p>由于我从一线 iOS 开发工作中脱离，《iOS 开发进阶》很可能不会再更新出第二版了，17000 册这个成绩，对于当时 30 岁的我来说，还算是一个不错的里程碑。这次写作让我感受到了出版的乐趣，其实我自己还在蕴量一些写作素材，或许以后会给大家一些新的分享。</p>
<h2 id="u5199_u4F5C"><a href="#u5199_u4F5C" class="headerlink" title="写作"></a>写作</h2><p>今年在博客上完成了 45 篇原创博客文章，差不多一周一篇的节奏。因为 iOS 开发做得少了，所以我的文章中涉及 iOS 开发技术细节的内容少了很多。</p>
<p>我仔细分析了一下今年的博客文章，内容涉及面很广。包括一些 iOS 开发方面的文章，如：</p>
<ul>
<li><a href="/2015/01/31/write-sdk-tips/">写 iOS SDK 注意事项</a></li>
<li><a href="/2015/03/15/ios-dev-controversy-1/">iOS 开发中的争议（一）</a></li>
<li><a href="/2015/03/22/ios-dev-controversy-2/">iOS 开发中的争议（二）</a></li>
<li><a href="/2015/11/02/mvc-and-mvvm/">被误解的 MVC 和被神化的 MVVM</a></li>
</ul>
<p>另外，我也向「娱乐记者」转变，采访了一些国内新出现的 iOS 大牛，以及报道一些行业新闻，比如</p>
<ul>
<li><a href="/2015/06/16/talk-about-swift-open-source/">谈谈苹果开源 Swift</a></li>
<li><a href="/2015/11/26/yykit-auther-interview/">专访 YYKit 作者 ibireme: 开源大牛是怎样炼成的</a></li>
</ul>
<p>我更不务正业地写起了硬件的评测：</p>
<ul>
<li><a href="/2015/06/28/apple-watch-usage-exp/">Apple Watch 使用体验</a></li>
</ul>
<p>当然，最离谱的就是我开始卖软件了，我和荔枝数码合作先后卖了 Reveal 和 Charles 两款 iOS 开发中需要的效率工具软件，也为此写了一些文章：</p>
<ul>
<li><a href="/2015/05/25/can-we-buy-time/">Reveal 中国特惠活动</a></li>
<li><a href="/2015/11/14/charles-introduction/">Charles 从入门到精通 (中国 5 折特惠)</a></li>
</ul>
<p>因为工作关系，我也开始总结自己的技术转管理收获，完成了：</p>
<ul>
<li><a href="/2015/10/25/one-on-one-summary/">浅析一对一沟通</a></li>
<li><a href="/2015/12/18/from-dev-to-manager/">涅槃重生:我的技术转管理之路</a></li>
</ul>
<p>在产品工作上面，总结了：</p>
<ul>
<li><a href="/2015/09/02/why-we-need-monitor-data/">数据的秘密（上）- 为什么要关注数据</a></li>
<li><a href="/2015/09/03/how-to-monitor-data/">数据的秘密（下）- 如何分析数据</a></li>
</ul>
<h2 id="u8BFB_u4E66"><a href="#u8BFB_u4E66" class="headerlink" title="读书"></a>读书</h2><p>另外，今年开始认真写读书笔记，完成了：</p>
<ul>
<li><a href="/2015/03/01/tipping-point/">《引爆点》读书心得</a></li>
<li><a href="/2015/04/04/from-0-to-1-book-summary/">《从 0 到 1 》读书笔记</a></li>
<li><a href="/2015/08/01/become-a-tech-leader-summary/">《成为技术领导者》读书心得</a></li>
<li><a href="/2015/08/02/the-story-of-success-book-summary/">《异类》读书心得</a></li>
<li><a href="/2015/08/22/reverse-book-summary/">《逆转》读书心得</a></li>
</ul>
<p>其实还看了一些别的书，包括《格鲁夫给经理人的第一课》、《增长黑客》、《领导梯队》等，但是都没有完成笔记，之后打算补上。</p>
<p>iOS 技术图书也看了不少，要说推荐，还是王巍的 <a href="https://selfstore.io/products/171" target="_blank" rel="external">《Swifter》</a> 和 Kevin 的 <a href="https://selfstore.io/products/367" target="_blank" rel="external">《Producter》</a> 。《Swifter》适合给新手入门用，《Producter》是一本跨界的书，适合 iOS 开发者用来开拓自己的眼界。</p>
<h2 id="u597D_u5947_u5FC3"><a href="#u597D_u5947_u5FC3" class="headerlink" title="好奇心"></a>好奇心</h2><p>2015 年我特别提醒自己要有好奇心，于是就做了很多有趣的事情。</p>
<p>比如，因为搬家和装修，我自己学习了换门锁、换马桶盖子、换马桶的上水管、组装板材家俱、在墙上钻孔这些技能，感觉还挺有意思的，有些时候就感觉在摆弄大号的积木玩具一样。</p>
<p>比如，因为对社群经济感兴趣，交了 1024 元加入了池建强和李笑来老师建的付费群。</p>
<p>比如，因为对 <a href="http://www.zaih.com/mentor/84802679/topic/29864843/" target="_blank" rel="external">「在行」</a> 这个 App 感兴趣，在上面接单，约见了五位朋友。</p>
<p>好奇心给我带来了极大的收获，比如池老师的那个付费群，我最终不但收获了不少有意思的分享，而且学习了当前社群的运作模式。在「在行」上接单不但收到了一些咨询费，更多的是认识了很多有趣的人，比如说罗飞。</p>
<p>如果要说好奇心给我带来的最大收获，那可能就是「iOS 开发」微信公众号的运营了。</p>
<p>从时间上看，我的「iOS 开发」微信公众号已经运营 3 年多了：</p>
<ul>
<li>2013 年 2 月 21 日，我开始在微信公众号里发表 iOS 开发相关内容。</li>
<li>2013 年 12 月累积发表了 140 条信息，累积了 5600 名粉丝。</li>
<li>2014 年 12 月累积了 1 万名粉丝。</li>
<li>2015 年 12 月累积了 3 万名粉丝。</li>
</ul>
<p>最主要的是，我原本没指望做这个事情有什么收获，但是从 2015 年起，开始有各种互联网企业找我投放广告。在这里感谢我的主要广告主：</p>
<ul>
<li><a href="https://www.upyun.com/zh/index.html" target="_blank" rel="external">UPYUN</a>：UPYUN 是国内领先的云服务提供商，专注于为开发者提供静态文件的云存储、云处理和 CDN 加速服务。</li>
<li><a href="http://100offer.com/" target="_blank" rel="external">100Offer</a>：用「拍卖」的方式来提供高端互联网人才招聘的网站。</li>
<li><a href="http://www.lagou.com/" target="_blank" rel="external">拉勾网</a>：最专业的互联网招聘平台，我自己就从上面招到了不少同事。</li>
<li><a href="http://www.infoq.com/cn" target="_blank" rel="external">InfoQ</a>：InfoQ 了提供中国最高质量的技术会议和技术文章，我自己也是 InfoQ 的社区编辑。现在 InfoQ 创始人 Kevin 把业务做得更广，成立了 <a href="http://www.geekbang.org/" target="_blank" rel="external">极客邦科技</a>，在极客邦科技之下，除了 InfoQ 之外，另外组建了高端技术人员社交网络 EGO、IT 职业学习平台 StuQ 和 企业培训服务 GIT。</li>
</ul>
<p>再次感谢你们，是你们让我这个自媒体有肉吃。</p>
<p>同时，我也要感谢我的读者，谢谢你们忍受偶尔出现的广告。我仔细算了一下，现在广告的频率是每月 2-3 次。你们放心，我会努力控制广告频率，如果控制不住，我就会涨价的！</p>
<h2 id="u672A_u6765_u7684_u8BA1_u5212"><a href="#u672A_u6765_u7684_u8BA1_u5212" class="headerlink" title="未来的计划"></a>未来的计划</h2><p>2016年，希望自己：</p>
<ul>
<li>每月至少完成一篇读书笔记。</li>
<li>每周坚持发至少一篇微信公众号文章。</li>
</ul>
<h2 id="u4E2A_u4EBA_Milestone"><a href="#u4E2A_u4EBA_Milestone" class="headerlink" title="个人 Milestone"></a>个人 Milestone</h2><ul>
<li>小猿搜题团队组建成功，并且获得 5000 万用户量。</li>
<li>「iOS 开发」微信公众号获得了 3 万粉丝，并开始有广告收入。</li>
</ul>
<!--

22 次

100 offer
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=444425913&idx=1&sn=edae69f061b7e963b626ff0564e0d55c#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=210036524&idx=1&sn=6ac23a8a4a518dac51bbf875da788df2#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209774617&idx=1&sn=f36182036013a89567bb150be29440d2#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209555090&idx=1&sn=64986a94516329f65be25166f7f05f39#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=204693407&idx=1&sn=53f7e05318aaad91e09ab8ff7043459b#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=204526037&idx=1&sn=f86643463659011430cd6bbf3538ca13#rd

lagou:
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=443546076&idx=1&sn=2fee1e70380a8c04e0b346a3fb36b3d9#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=440158123&idx=1&sn=9b0452fba8ab687b902cb3110846dbe4#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=400074920&idx=1&sn=cbfcdca750798cc16e92ff7997ed61fb#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209664745&idx=1&sn=eedfa5d8c5f7183997a22d06a4c3904e#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=208301774&idx=1&sn=adffaef537aff67f01db3992be796c89#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=206695843&idx=1&sn=2617a5966f347a98d6b9ef490f0292b4#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=205584984&idx=1&sn=584e2913718833020cfd990465e3afe5#rd



infoQ:
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=421410076&idx=1&sn=8a6671aa72abfadb03cfb8f224523838#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=405922788&idx=1&sn=e1f2a1e5b4ccddd2f0b31eefdafd56ae#wechat_redirect

pgyer:

http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=420641198&idx=1&sn=f43c61cb451db72d4145fbaad089b8ba#rd 

BugTags:

http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209938150&idx=1&sn=4ff4715b21d88a384c747e098fa9c1aa#rd

UPYUN:
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209728624&idx=1&sn=1ab063924d3d8863c7c66a9f820e34c7#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=208075893&idx=1&sn=09164a9954092d12ba2a5eb341cb857b#rd

丰厚资本:

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209397391&idx=1&sn=8e9ff6100379bd289a901c4aec400e8e#rd

借贷宝:
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209067756&idx=1&sn=396d17ec6f2aefc6547ae488719ff669#rd

理财工场:
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=208847424&idx=2&sn=d26831cf3d4f41639c8fbf37ba662c55#rd

-->
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5173_u4E8E_u521B_u4E1A"><a href="#u5173_u4E8E_u521B_u4E1A" class="headerlink" title="关于创业"></a>关于创业</h2><p>今年猿题库顺利拿到了 D 轮 6000 万美元的]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[培训机构出来的 iOS 学员怎么了？]]></title>
    <link href="http://blog.devtang.com/2015/12/24/resume-cheat-story/"/>
    <id>http://blog.devtang.com/2015/12/24/resume-cheat-story/</id>
    <published>2015-12-24T14:23:45.000Z</published>
    <updated>2016-02-18T13:13:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E8B_u4EF6_u56DE_u653E"><a href="#u4E8B_u4EF6_u56DE_u653E" class="headerlink" title="事件回放"></a>事件回放</h2><p>前几天在 iOS 开发群里看到有人贴了一个 v2ex 上的帖子（地址： <a href="https://www.v2ex.com/t/244437" target="_blank" rel="external">https://www.v2ex.com/t/244437</a> ） ，大概说收到了 1000 多份某培训机构出来的学员简历。这些简历让他发现了一些问题：</p>
<ul>
<li>面试表现比较差</li>
<li>大多有伪造工作经历的行为</li>
</ul>
<p>以下是他的文章原文：</p>
<blockquote>
<p>公司坐标：杭州。 </p>
<p>由于公司业务发展，需要新招一位 iOS 开发工程师，这周 HR 平均每天给我安排了三场面试。 </p>
<p>一周过去了，这些面试者给我的印象都很糟糕，并且……很蹊跷，今天找 HR 了解了一下。 </p>
<p>结果出现了令我震惊的事情， HR 在「智联」「 51job 」「拉勾」三个渠道发布了招聘，半个月收到了超过一千份 iOS &gt; 简历，而同时招聘的其他技术岗位却很少有人投递简历。 </p>
<p>分析了一下这些简历的特征： </p>
<p>1.户籍绝大多数是某地（非地图炮，仅是数据统计） </p>
<p>2.几乎全部刚从外地来杭州 </p>
<p>3.几乎全部上家公司是外包公司 </p>
<p>4.很多人上家公司不一样，但简历中写的项目却是一样的 </p>
<p>5.简历上宣称的工作年限都是 1 年左右 </p>
<p>其实上面这几条，我都可以「理解」 </p>
<p>但是，这个数量着实让人震惊。 </p>
<p>我有一些推测，怕被喷，先不说了。 </p>
<p>你们怎么看?</p>
</blockquote>
<p>有人把这个问题贴到知乎上，引来了一些知情者的回复，见 <a href="https://www.zhihu.com/question/38703692" target="_blank" rel="external">https://www.zhihu.com/question/38703692</a> 。</p>
<p>原来这些都是培训机构出来的学员，然后为了获得一次面试，就编造了工作公司和经历，并且隐藏了自己的培训经历。</p>
<p>今天就想和大家聊聊这个沉重的话题。</p>
<h2 id="u8BDA_u4FE1_u7684_u6076_u6027_u5FAA_u73AF"><a href="#u8BDA_u4FE1_u7684_u6076_u6027_u5FAA_u73AF" class="headerlink" title="诚信的恶性循环"></a>诚信的恶性循环</h2><p>首先我们说说简历造假吧。在我看来，简历造假还是时常遇到的。我认识礼物说的 CTO，我们 iOS 群里常常有朋友面试时遇到说自己在礼物说工作过的候选人，为什么呢？还不是网上有一堆高仿礼物说的 APP，自己下载下来看看，然后就可以假装是自己做的了。</p>
<p>为什么很多候选人选择造假呢？除了简历不够好之外，造假很多时候确实有用。对于很多小公司来说，面试官自己也不懂如何面试 iOS 开发，那么就特别容易被忽悠。</p>
<p>但是，一个公司里面有 iOS 开发者，然后再稍微懂一些面试技巧的话，简历造假是很容易发现的。关于怎么在面试中鉴别造假，我们在下一节聊。</p>
<p>我们先聊聊看造假会造成什么危机呢？对于面试公司来说，如果他发现面试的效率特别低，或者招进来的人干活不行时，他会怎么办呢？</p>
<p>我觉得他会很直接地开地图炮，把一类人直接刷掉，不再给面试机会。这类人是哪些人？简历雷同的、培训机构培训出来的人。</p>
<p>这样公平吗？对候选人肯定不公平，但是公司招人也需要讲效率的，面试候选人其实成本特别高。</p>
<p>所以造假这个行为，最终伤害的是候选人本人，以及培训机构的信誉。</p>
<h2 id="u5982_u4F55_u5728_u9762_u8BD5_u4E2D_u9274_u522B_u9020_u5047"><a href="#u5982_u4F55_u5728_u9762_u8BD5_u4E2D_u9274_u522B_u9020_u5047" class="headerlink" title="如何在面试中鉴别造假"></a>如何在面试中鉴别造假</h2><p>其实挺简单的，首先面试的时候不要设置固定问题，然后根据候选人的回答情况来深入问细节。</p>
<p>就比如说一个候选人说他做过礼物说，那就有很多可以深入问的，比如问他：</p>
<ul>
<li>礼物说有几个 iOS 开发</li>
<li>大家是如何分工的</li>
<li>你负责的那块最主要的难点在哪里</li>
<li>团队整个协作的过程</li>
<li>在开发的时候有没有遇到需求变更</li>
<li>功能上线后大概的数据是什么样的</li>
<li>你觉得哪些地方还需要改进</li>
<li>你们主要的竞争对手是谁，他们在哪些技术方面比你们做得好</li>
</ul>
<p>一个谎话要编容易，难的是每一个细节都编得面面俱到，所以深入细节问，很容易就会露馅。</p>
<h2 id="u6211_u662F_u57F9_u8BAD_u673A_u6784_u5B66_u5458_u600E_u4E48_u529E"><a href="#u6211_u662F_u57F9_u8BAD_u673A_u6784_u5B66_u5458_u600E_u4E48_u529E" class="headerlink" title="我是培训机构学员怎么办"></a>我是培训机构学员怎么办</h2><p>简单地说，公司招一个人最终级的目的还是把活干好。如果一个培训机构的学员，没有实际的工作能力，单凭几个月的培训就想一劳永逸地找一份好工作，这是不现实的。</p>
<p>互联网技术日新月异，iOS 开发每年技术都在更新，如果指望所有知识都是从培训机构那儿获得，那么早晚都会被淘汰。</p>
<p>所以，即使你当前是培训机构出来的学员，也必须培养自己实际解决问题的能力和自学能力。这样才能一点点地增强自己的实力。</p>
<p>另外说一个残酷的现实，公司一般不会给你大块的上班时间用来学习新知识的。所以大多数学习充电过程只能是在下班后或周末。</p>
<h2 id="u6211_u4EEC_u5E94_u8BE5_u600E_u4E48_u770B_u5F85_u57F9_u8BAD_u673A_u6784_u5B66_u5458"><a href="#u6211_u4EEC_u5E94_u8BE5_u600E_u4E48_u770B_u5F85_u57F9_u8BAD_u673A_u6784_u5B66_u5458" class="headerlink" title="我们应该怎么看待培训机构学员"></a>我们应该怎么看待培训机构学员</h2><p>我自己就招过一个培训机构出来的学员，她还是一个女生，现在工作得挺棒的。她是非计算机专业毕业的，参加培训机构学了 3 个月就来我们公司面试。她能通过面试，很大程度上是因为她不止参加了培训班的课，而且自己在网上学习了计算机数据结构和算法的基础知识，而且是看的国外的课程。</p>
<p>当时面试时我完全没有考查她 iOS 知识，因为她承认只参加了 3 个月的培训。所以我考查了一下她自学数据结构和算法的情况。结果让我觉得她是一个自学能力还不错的女生，所以我就把她招了进来。</p>
<p>刚进来带她做 iOS 费了一些精力，但是很快她就可以上手自己做事情了。现在，我已经完全把小猿搜题的 iOS 端交给她来负责。我想她就是一个培训机构出来学员的成功案例。</p>
<p>我们并不鄙视培训机构的学生，但是我们不认同那些没有自学能力，认为参加 3 个月培训就可以拿高薪的「投机者」。这个行业虽然高薪，但是也很辛苦，如果没有兴趣和毅力，是没办法做好的。</p>
<h2 id="u641E_iOS__u5F00_u53D1_u5230_u5E95_u9700_u8981_u4EC0_u4E48_u6838_u5FC3_u80FD_u529B"><a href="#u641E_iOS__u5F00_u53D1_u5230_u5E95_u9700_u8981_u4EC0_u4E48_u6838_u5FC3_u80FD_u529B" class="headerlink" title="搞 iOS 开发到底需要什么核心能力"></a>搞 iOS 开发到底需要什么核心能力</h2><p>大家看了我上次<a href="/2015/11/26/yykit-auther-interview/">采访的 YYKit 作者的文章</a> 后，或许就能明白，其实一个人核心的能力就是学习能力。有强大的学习能力，那么就可以像 YYKit 作者那样，才接触 iOS 开发一年多就可以开源出大量优秀的作品。</p>
<p>基本上，一个人在一个领域坚持投入大量的时间，很难做得不好。所以你是一个培训机构的学员，苦于找不到工作。与其简历造假拿到面试机会，倒不如再多花花精力，自己多专研一些代码，写一些 App，不要那么急功近利，我想结果都会好很多。</p>
<p>愿培训机构出来的 iOS 学员都能找一份好工作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E8B_u4EF6_u56DE_u653E"><a href="#u4E8B_u4EF6_u56DE_u653E" class="headerlink" title="事件回放"></a>事件回放</h2><p>前几天在 iOS 开发群里看到有人贴了一个 v2]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[涅槃重生:我的技术转管理之路]]></title>
    <link href="http://blog.devtang.com/2015/12/18/from-dev-to-manager/"/>
    <id>http://blog.devtang.com/2015/12/18/from-dev-to-manager/</id>
    <published>2015-12-18T13:32:00.000Z</published>
    <updated>2016-02-27T15:16:19.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/from-dev-to-manager-1.jpg">
<h2 id="u4E00_u4E2A_u7A0B_u5E8F_u5458_u7684_u7406_u60F3"><a href="#u4E00_u4E2A_u7A0B_u5E8F_u5458_u7684_u7406_u60F3" class="headerlink" title="一个程序员的理想"></a>一个程序员的理想</h2><p>我从高中就开始接触计算机并开始编程，我非常喜欢编程，我一直以为我会写一辈子代码。</p>
<p>我从毕业就一直做技术，开始一年是做 Java 语言的服务器开发，开发过网易邮箱和微博的后台，后来转而做 iOS 开发。</p>
<p>因为喜欢，我几乎把我所有的非工作时间也投入到技术中去。当然，并非是把工作带回家，而是专研技术或者从事技术写作。</p>
<p>于是这几年，我积累了超过 150 篇原创技术文章，在 iOS 技术圈子里面也小有名气，也出版了一本《iOS 开发进阶》的书，微博和微信公众号的粉丝数也都超过了 3 万。</p>
<p>我做得很开心。</p>
<p>我一直以为，我会是一个好码农，我会一直在技术上深入下去。</p>
<p>但是，改变有些时候就是来得那么突然。</p>
<h2 id="u6D85_u69C3_u91CD_u751F"><a href="#u6D85_u69C3_u91CD_u751F" class="headerlink" title="涅槃重生"></a>涅槃重生</h2><p>我还记得那一天，2014 年 7 月 17 日，我当时受到邀请，在广州的微信分享 iOS 开发技术。当天晚上，我接到郭常圳（我们的 CTO）的电话，知道要做小猿搜题这个项目，并且这个项目「由我负责」。</p>
<p>于是，我开始了技术转管理之路。</p>
<p>通过从以前的项目组中抽调人手，小猿搜题这个产品技术团队很快组建出来了。我在开发 iOS 版的小猿搜题客户端的同时，也开始了我的管理工作。</p>
<p>现在经过了一年半，我们不但组建成了一支充满战斗力的团队，成收获了不小的成绩：</p>
<ul>
<li>小猿搜题产品一年时间获得了 5000 万的用户。</li>
<li>我们团队在开发上做到了每周一次迭代，两周一次版本发布。</li>
</ul>
<h2 id="u6280_u672F_u7BA1_u7406_u7684_u603B_u7ED3"><a href="#u6280_u672F_u7BA1_u7406_u7684_u603B_u7ED3" class="headerlink" title="技术管理的总结"></a>技术管理的总结</h2><p>在我的工作中，我慢慢总结出在创业公司中做技术管理工作的「方法论」。我把我的技术管理工作分成以下几个部分：管理业务，管理团队，管理技术。</p>
<h3 id="u7BA1_u7406_u4E1A_u52A1"><a href="#u7BA1_u7406_u4E1A_u52A1" class="headerlink" title="管理业务"></a>管理业务</h3><p>做为互联网公司，我们奉行简单直接的沟通，所以我很多时候并不需要涉及人员的管理工作，更多的时候是业务的管理工作。业务的管理工作主要是围绕着一个具体要做的技术开发功能点展开。具体包括：</p>
<ul>
<li>任务分解和分配</li>
<li>制定大概的开发排期</li>
<li>每天了解开发进度</li>
<li>讨论和跟进各种具体的技术问题</li>
<li>协调一些产品需求变更</li>
<li>响应一些市场同事的需求</li>
<li>跟进相关功能上线</li>
</ul>
<p>在这方面，我们主要是采用 <a href="https://www.scrum.org/" target="_blank" rel="external">Scrum</a> 的开发方式，见<a href="/2014/09/13/scrum-introduction/">《适合码农工作时玩的游戏：Scrum》</a>。</p>
<p>我们在整个迭代（Sprint）过程中引入四个会议：计划会议，每日站会，评审会议和回顾会议。通过事先简单的计划，再加上这四个会议中的详细讨论，我基本能够做到：</p>
<ul>
<li>通过计划会议：比较合理的安排开发排期、分配任务。</li>
<li>通过每日站会：每天了解开发进度，会后讨论和跟进各种具体的技术问题</li>
</ul>
<p>对于产品需求变更和市场同事需求的响应，我主要利用自己在 Sprint 执行过程中的时间来展开。我会根据当前需求的大小和紧迫程度，来决定是否插入到当前的 Sprint 中。如果插入到当前的 Sprint 工作量太大，我会适当做一些 Sprint 内容的调整。</p>
<p>跟进相关功能的上线主要是开发快要结束的时期，我会和产品同事一起试用最新的功能，了解 Bug 修复的进度，上线的风险情况。在大部分出现风险的情况下，我们都希望用适度加班的方式解决，所以我们上线当晚有时候会工作得比较晚。在无论如何都搞不定的情况下，我们可能会调整上线时间。</p>
<p>在业务涉及跨部门合作的时候，相关的进度管理会更麻烦一些。因为各部门自己的进度安排不一致，所以就会存在「等着联调」的情况。另外联调时出现问题也容易出现没人主动出来解决的情况。这些都需要负责人更频繁地沟通和推进，以保证按时上线。</p>
<p>在每周的工作中，我的管理业务的工作大概花费是 2 天左右。</p>
<h3 id="u7BA1_u7406_u56E2_u961F"><a href="#u7BA1_u7406_u56E2_u961F" class="headerlink" title="管理团队"></a>管理团队</h3><p>刚刚也说到，互联网公司不怎么需要管人，那么管理团队主要是做什么事情呢？我认为主要是两件事情：招人和带人，所谓的搭班子和带队伍。</p>
<h4 id="u62DB_u4EBA"><a href="#u62DB_u4EBA" class="headerlink" title="招人"></a>招人</h4><p>招聘这事情实在太重要了，所以必须要团队负责人参与。人才的招聘除了从公开的渠道收取简历、从猎头或同事那里得到推荐以外，还包括定向的找一些自己熟悉的前同事或某个领域的知名大牛，这些工作都是非常花费时间的。</p>
<p>在招人上，我们主要用到了找前同事，内部推荐发伯乐奖，以及进行技术分享和开源代码来获得社区影响力的方式。</p>
<p>值得一提的是，我们对于开源社区的贡献也得到了肯定，我们的基础架构组负责人陈恒因为多次为 Hbase 贡献代码，所以成为了 Hbase 的 Committer，而全中国拥有 Hbase 的 Committer 的公司在此之前只有三家，而且中国的 Hbase 的 Committer 不到 10 人。</p>
<p>在每周的工作中，招聘大概会占用我半天到一天的时间。</p>
<h4 id="u5E26_u4EBA"><a href="#u5E26_u4EBA" class="headerlink" title="带人"></a>带人</h4><p>人才招进来了，能否顺利融入团队，团队负责人以及这个人的导师（mentor）非常重要。需要做的事情包括：</p>
<ul>
<li>平时多交流沟通。</li>
<li>在新人遇到问题时，热心地解答。</li>
<li>引导新人熟悉公司的工作方式。</li>
</ul>
<p>一对一沟通来源于 Intel 公司，在最近很火的一本书 <a href="http://item.jd.com/11645500.html" target="_blank" rel="external">《创业维艰》</a> 中里面也提到过。《创业维艰》的作者本·霍洛维茨是被誉为「硅谷最牛的 50 个天使投资人」之一，先后在初期投资了 Facebook、Twitter、Groupon、Skype。</p>
<p>他在书中对一对一沟通介绍到，一对一沟通最主要的意义是：可以使得信息从下而上地传递。从而获得在其它渠道不易获得的信息，保证透明。</p>
<p>适合一对一沟通的内容有很多，包括：</p>
<ol>
<li>不成熟的看法</li>
<li>迫在眉睫的问题</li>
<li>精彩的想法</li>
<li>倾诉焦虑</li>
<li>抱怨</li>
</ol>
<p>这些内容都不适合在别的场景中出现，比如：不成熟的看法，如果在部门的正常会议或邮件中提出，会让人觉得未经过深思熟虑。又比如一些焦虑或抱怨，如果通过一些渠道宣泄给其他同事，其实也是不好的。一对一沟通让这些内容有了一个不错的出口。</p>
<p>5 年前我刚毕业加入网易有道的时候，我的老大，也是我现在创业公司的 CTO 郭常圳就开始和我做一对一沟通。我非常享受每次沟通的过程。现在我也开始和别人做一对一沟通，我也开始关注一对一沟通的技巧。我们认为最大的技巧是：作为管理者，要多听少说，让员工成为沟通的中心。郭常圳有一个特别「老土」的办法，就是：不主动说话。通过这种方式，强迫让员工选择他们想聊的话题。</p>
<p>在《创业维艰》一书中，也介绍了一些适合用来引导的问题：</p>
<ul>
<li>当前产品还有哪些可以提高的地方？</li>
<li>我们部门的最大问题是什么，为什么？</li>
<li>如果有，你觉得工作中有哪一点令你感觉不舒服？</li>
<li>你觉得谁的工作最优秀，为什么？</li>
<li>我们的产品哪方面不尽如人意？</li>
<li>我们错失的最大机遇是什么？</li>
<li>哪些是我们应该做而没有做的？</li>
<li>你自己希望未来在哪些方面能有提高？</li>
<li>有什么我能为你做的事情？</li>
</ul>
<p>我大概保持每个月和每个组内同事都有一次一对一沟通，有很多时候，我是通过「请他们吃饭」来完成的。一对一沟通需要一个舒适的环境，所以在咖啡厅或饭桌上，可能都比在办公室的效果要好一些。</p>
<p>一对一沟通的另一个核心要素是要坦诚，这就像 Scrum 指南中用「游戏规则」来描述内容一样，如果管理者做不到坦诚，那么同事就不会把这当作是一次有效的沟通机会。坦诚的沟通方式是：所有问题都真诚的回答，不掩饰问题，也不回避问题。如果沟通双方能够做到坦诚，即使是一个棘手的问题，那么双方也会从「解决问题」的角度，尽量寻找可能的办法。</p>
<p>除此之外，定期组织一些团队活动，让团队每个人之间建立友谊，也是我努力在做的。这在很多大公司是 HR 部门做的事情，在我们创业公司里面，也变成团队负责人的工作之一了。</p>
<h3 id="u4EC0_u4E48_u662F_u9886_u5BFC_u529B"><a href="#u4EC0_u4E48_u662F_u9886_u5BFC_u529B" class="headerlink" title="什么是领导力"></a>什么是领导力</h3><img src="/images/become-a-tech-leader-book.jpg">
<p>关于管理团队，我也特别喜欢《成为技术领导者》一书中的观点，关于本书，更多的请见<a href="/2015/08/01/become-a-tech-leader-summary/">《成为技术领导者》读书心得》</a>。书中是这么说的：</p>
<blockquote>
<p>所谓领导力，就是创造这样一个环境，每个人都能在其中发挥出更多的能力。</p>
</blockquote>
<p>我想：在强调平等、创新、自由的互联网公司里面，这可能就是领导力最好的定义吧。</p>
<h2 id="u7BA1_u7406_u6280_u672F"><a href="#u7BA1_u7406_u6280_u672F" class="headerlink" title="管理技术"></a>管理技术</h2><p>作为一个技术负责人，产品在技术上的架构是否合理？随着用户量的增长，现有架构能否胜任？当运营活动发生时，突发的流量会有多少，服务器是否能够承受住压力？未来技术上的架构应该如何演进？除了服务器端，客户端应该在哪些技术方案上投入研究力量？这些都是技术负责人需要考虑和决策的。</p>
<p>我同时做过服务器端和移动端的开发工作，不过由于最近几年都是做移动端的开发，所以服务器端的架构技术细节我其实并不是专家。所以我在这方面做得算不上很好。可能是运气好吧，有几次服务器的压力问题，我们都及时发现并且解决了，但是时间都挺紧迫的。现在，我会花时间把服务器端的架构图画出来，然后一块一块考虑，看看有没有更优的方案，并且和服务器端的同学讨论。</p>
<p>在客户端上，我只是对 iOS 开发比较熟悉，对 Android 了解得并不深入。所以我会让技术同学自己提一些技术改进方案，我参与 Review，我想他如果能说得有理有据，还是可以授权他在技术上深入的。</p>
<p>其实每个平台的技术管理可能都需要更多的「授权」，因为具体做事情的人，会比技术管理者更清楚地了解细节。而对细节的深入了解，才是改进技术架构的方案来源。所以，尽量招靠谱的人，那么在管理技术上的工作就只需要遵守「尽量授权」的原则来就可以了。</p>
<p>管理技术还包括公司技术氛围的建立，我主要在以下这些方面下了一些工夫：</p>
<ul>
<li>推进技术 wiki 的使用</li>
<li>推进 iOS 端每周一次的技术分享</li>
<li>推进 Code Review 以及代码质量</li>
</ul>
<p>Wiki 是一个非常好用的知识管理工具，前提是每个同事都参与贡献内容。所以作为一个管理者需要用言行来指导新同事学会用 Wiki。我会主动将重要内容记录在 wiki 上，对于一些同事发的邮件内容，我也会要求他整理到 wiki 上。</p>
<p>iOS 端的技术分享也是需要管理者推进的。我之前在网易有道的时候，这方面的活动基本上是大家自愿的方式来进行。这其实对分享者要求很高，一般的人很难达到这种意识，所以当时有道 iOS 端的技术分享很少。因此，我还是认为「半强制」的分享方式更适合当前团队。</p>
<p>「半强制」的分享规则需要大家认同，在一个相对轻松的环境下达成一致，为此我专门组织了一次交流会，大家相互认识一下，一顿吃喝之后，再约定分享规则。现在看起来，大家其实有很多想分享的内容，在 Wiki 上，很多一两个月才轮到他的人，都已经把分享的主题确定了。</p>
<p>Code Review 也是一个需要推动的事情，我们使用 Git 和 Gerrit，做到了所有的提交必须 review 通过之后，才能 merge 进代码仓库。另外我们也在 wiki 上规定了详细的代码风格要求。Code Review 如果做得好，不但可以在代码风格上达成一致，还能让新同事从中学习到一些良好的编程习惯，一些潜在的 Bug 也可能在 Code Review 中被发现，实在是值得坚持的事情。</p>
<h2 id="u4EA7_u54C1_u8D1F_u8D23_u4EBA"><a href="#u4EA7_u54C1_u8D1F_u8D23_u4EBA" class="headerlink" title="产品负责人"></a>产品负责人</h2><p>除了技术负责人的管理业务，管理团队，管理技术工作外，我另外还是小猿搜题的产品负责人，所以我还承担着技术负责人之外的一些工作。这些工作最主要的就是对产品的管理工作。</p>
<p>产品工作看似简单，实则复杂，而我作为一个工作多年的程序员，在这方面的经验非常少。所以我在参与产品讨论时，一开始都比较惶恐。后来我慢慢发现，产品经理的思维还是有章可循，便开始总结和学习，我看了不少产品经理的书，而郭常圳的多次指导也对我的帮忙意义巨大。其实做产品的原则就那么多，重要的还是多思考和体会，把那些原则融入自己的理解。</p>
<p>「场景化思维」是我学到的第一点，我还记得郭常圳带着我们学习乔布斯推出第一代 iPhone 时的演讲，乔布斯非常会讲故事，在用户具体的场景中介绍自己的产品。好的产品经理会将自己「代入」目标用户的使用场景中，解决用户的主要痛点和问题。做为技术人员，我常常陷入产品逻辑完备的泥潭中，但是「场景化思维」使得我能够重新跳出细节，关注主要功能设计是否合理。</p>
<p>「关注数据」是我学到的第二点，产品经理在打磨细节方面，如果能够关注产品数据，那么就很容易找到改进的方向，并且在后期验证自己的想法。关于这个，详细的请看：<a href="/2015/09/02/why-we-need-monitor-data/">数据的秘密（上）- 为什么要关注数据</a> 和 <a href="/2015/09/03/how-to-monitor-data/">数据的秘密（下）- 如何分析数据</a>。</p>
<p>我曾经犹豫自己是否应该学习写产品稿，郭常圳说不用，他说你只需要多看产品经理的产品稿，多思考和比较，慢慢就会有产品的感觉。我发现这一点还是管用的。以前用一个新的 App，作为开发者，我会关注它的功能在技术上如何实现，而我现在，不光会关注技术实现，还会想它的产品设计思路。打开了这扇窗户后，我就能在日常生活的每一天里，通过思考来提升自己的产品能力。</p>
<p>作为产品负责人，我主要的工作是参与产品稿的评审和美术稿的评审，同时会参与决定未来要做的功能，将其安排到产品工作中。另外，我也会关注产品的各项指标数据，保证重要的产品数据都是看过的。</p>
<p>我每周花在产品评审和美术评审大概是半天到一天，每周花在关注产品各项指标数据上的时间大概是半天到一天。</p>
<h2 id="u6211_u505A_u5F97_u4E0D_u597D_u7684_u5730_u65B9"><a href="#u6211_u505A_u5F97_u4E0D_u597D_u7684_u5730_u65B9" class="headerlink" title="我做得不好的地方"></a>我做得不好的地方</h2><p>做为一个技术转管理的新人，我觉得我的工作还是有挺多问题。</p>
<p>首先，我刚开始还是太迷恋技术了，有一些开发工作我仍然主动参与。但是实践之后发现，因为我的事情太多太杂，使得我很难保证自己承担的开发工作的进度。所以我现在学会主动把任务交给别人做，如果一件事情不是必须我才能做的，我就交给别人。所以现在技术上，我只参与 iOS 端的 Code Review 工作了。我将更多的精力，放在一些不得不由我做的沟通和项目推进方面的工作上。</p>
<p>接着，我有很长一段时间没能很好地安排好产品计划和研发的进度。好的产品计划应该要领先开发一个以上的迭代周期，这样在技术开发当前版本时，下一个版本功能就在设计和评审当中，使得大家的工作都不受影响。而小猿搜题的产品计划有一阵一直没能很舒服地领先技术，这让很多时候开发同事并不舒服。</p>
<p>解决的办法是我们让产品文档的完成时间点也尽量精准，对于一个大的产品功能设计，我们会定好初版（我们内部叫做 1 版本）、详细版（我们内部叫 5 版本）、完善版（我们内部叫 9 版本）的时间点。产品经理需要努力在时间点内保证产出，这样其实反倒使得大家会关注产品设计的主要问题，在细节上不过分纠结。</p>
<p>最后，我在招聘上的成绩也比较一般，没有能够为团队招来很多有经验的人，所以小猿搜题现有团队还是新人居多。新人的好处是容易和团队文化保持一致，但是在经验上，还是需要更多的锻炼。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>小猿搜题从 2014 年 7 月 17 日立项，到 10 月上线，再到元旦正式对外推广，到现在在不到一年的推广时间内，已经积累了超过 5000 万的用户。而我，也随着小猿搜题，从一个纯技术的 iOS 程序员，成长成为它的产品技术负责人，虽然也犯了一些错误，我感觉自己的进步还是很快的。</p>
<p>我也希望我的故事能够激励其他的技术同行，能够勇敢地接受新的挑战。在快速变化的移动互联网时代，快速迭代演进的不止有 App，也包括我们自己，愿大家都能活得精彩！</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/from-dev-to-manager-1.jpg">
<h2 id="u4E00_u4E2A_u7A0B_u5E8F_u5458_u7684_u7406_u60F3"><a href="#u4E00_u4E2A_u7A0B_u5E8F_u54]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[专访 YYKit 作者 ibireme: 开源大牛是怎样炼成的]]></title>
    <link href="http://blog.devtang.com/2015/11/26/yykit-auther-interview/"/>
    <id>http://blog.devtang.com/2015/11/26/yykit-auther-interview/</id>
    <published>2015-11-26T12:47:13.000Z</published>
    <updated>2016-02-27T15:17:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h3><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/news/2015/11/ibireme-interview" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h3 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h3><p>第一次听到 <a href="http://weibo.com/239801242" target="_blank" rel="external">ibireme</a> 这个名字，是看到他在 <a href="http://weibo.com/2477831984/D2ujxj5Vx?type=comment#_rnd1448528368875" target="_blank" rel="external">微博上分享</a> 了 <a href="https://github.com/ibireme/YYText" target="_blank" rel="external">YYText</a> 开源库。当时我第一眼见到 YYText 的功能示意 GIF 图时（下图所示），就被它丰富的功能吸引了。YYText 应该是我见到过的功能最强大的基于 CoreText 的排版框架了。</p>
<p><img src="https://camo.githubusercontent.com/fb454f77c109e6ac671e8fdb3220ade92238715b/68747470733a2f2f7261772e6769746875622e636f6d2f69626972656d652f5959546578742f6d61737465722f417474726962757465732f59595465787420457874656e6465642f5959546578744174746163686d656e742e676966" alt="YYText示意图"></p>
<p>令人惊讶的是，YYText 虽然代码量很大（超过一万行），但它只是 ibireme 的作品之一。ibireme 利用业余时间完成了 <a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYKit</a> 工具库，包括：</p>
<ul>
<li><a href="https://github.com/ibireme/YYModel" target="_blank" rel="external">YYModel</a> — 高性能的 iOS JSON 模型框架。</li>
<li><a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a> — 高性能的 iOS 缓存框架。</li>
<li><a href="https://github.com/ibireme/YYImage" target="_blank" rel="external">YYImage</a> — 功能强大的 iOS 图像框架。</li>
<li><a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="external">YYWebImage</a> — 高性能的 iOS 异步图像加载框架。</li>
<li><a href="https://github.com/ibireme/YYText" target="_blank" rel="external">YYText</a> — 功能强大的 iOS 富文本框架。</li>
<li><a href="https://github.com/ibireme/YYKeyboardManager" target="_blank" rel="external">YYKeyboardManager</a> — iOS 键盘监听管理工具。</li>
<li><a href="https://github.com/ibireme/YYDispatchQueuePool" target="_blank" rel="external">YYDispatchQueuePool</a> — iOS 全局并发队列管理工具。</li>
<li><a href="https://github.com/ibireme/YYAsyncLayer" target="_blank" rel="external">YYAsyncLayer</a> — iOS 异步绘制与显示的工具。</li>
<li><a href="https://github.com/ibireme/YYCategories" target="_blank" rel="external">YYCategories</a> — 功能丰富的 Category 类型工具库。</li>
</ul>
<p>我和一些朋友挑选了一些其中的组件代码阅读，大家都认为质量非常高，大家对它的评语是这样的：</p>
<blockquote>
<p>打算自己撸一个 JSON 转 model 的，专门看了 YYModel 的代码，果然屌。</p>
<p>YYKit 超级好用。 </p>
<p>对比一下，感觉自己一年都没写代码。</p>
<p>怎么会有如此完美的工程师？真想抽一周时间宅在家里把 YYKit 的源码重敲一遍。</p>
</blockquote>
<p>之后我抽空学习了一下 ibireme 的博客（<a href="http://blog.ibireme.com/" target="_blank" rel="external">http://blog.ibireme.com/</a>），上面有多篇介绍他对于 iOS 开发中各种问题的研究，例如他在开发 YYModel 时，<a href="http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/" target="_blank" rel="external">调研和评测</a> 了包括 Mantle 和 MJExtension 在内的多款开源库。这种专业认真的做事态度让我非常佩服，也让我对 YYModel 的质量充满信心。</p>
<p>然后，我有幸得到了 ibireme 的 QQ 和微信号，所以和他交流了多次。这时我才知道 ibireme 是一个 90 后，在优酷从事 iOS 开发工作。而这些所有的开源库，都是他在业余时间完成的。</p>
<p>我想大家很可能对 ibireme 的学习和成长的经历感兴趣，而且 ibireme 的故事很可能会激励更多有激情的 iOS 开发新人，利用业余时间学习、Coding 和分享，最终让国内的 iOS 开发技术氛围更好。所以，我向 ibireme 发出了采访邀请，ibireme 欣然接受了。于是，让我们来一起揭开这位神秘人物的面纱吧。</p>
<h3 id="u91C7_u8BBF"><a href="#u91C7_u8BBF" class="headerlink" title="采访"></a>采访</h3><blockquote>
<p>唐巧：你好 ibireme，能否先向读者简单介绍一下自己？</p>
</blockquote>
<p>ibireme：大家好，我叫郭曜源，是一个 iOS 开发者，现居北京，就职于优酷土豆。喜欢代码，爱好设计与音乐。</p>
<blockquote>
<p>唐巧：我发现 YYKit 是在这个月初上传到 github 上的，但是它的代码量非常大，能否介绍一下每个部分大概花了你多长时间？</p>
</blockquote>
<p>ibireme：Category 等工具类大部分都是这一两年工作和业余时间攒下来的。文本和图片相关的那几个项目是今年年初开始写起的，陆陆续续写了半年多。YYModel 花的时间最少，只有大概两个周末。</p>
<blockquote>
<p>唐巧：为什么选择一次性开源这么多代码，而不是一个一个开源呢？</p>
</blockquote>
<p>ibireme：最初这些代码我都是写在一个工程里，代码量比较多，相互之间也有很多依赖。准备发布时，我觉得这样很不方便别人使用，这才按功能拆开成一个个小的组件，然后一起发布的。</p>
<blockquote>
<p>唐巧：这些开源库在国内外都收到了大量的好评，这个有没有超出你的预期？</p>
</blockquote>
<p>ibireme：发布前我有预期会收到不少关注，但是发布后收到的好评还是大大超出我的预料。最令我惊讶的是 Facebook 和 Uber 等国外的工程师也关注到这个项目，并且还以此向我发出了工作邀请，这让我非常激动。</p>
<blockquote>
<p>唐巧：你对 YYKit 后续的发展上有什么计划吗？</p>
</blockquote>
<p>ibireme：现在只是计划进行一些正常的维护工作，保证稳定性。未来如果有合适的东西，我也会尝试加到里面的，但应该不会有太大改变了。</p>
<blockquote>
<p>唐巧：YYKit 是你的业余作品，我很好奇你是如何保证工作之余还有这么高产的？</p>
</blockquote>
<p>ibireme：最近一年我工作不太忙，很少加班，空闲时间比较多。另外我比较宅，平时喜欢待在家里做一些喜欢的事情。说起来，应该是充足的时间加上个人兴趣让我完成了这些项目吧。</p>
<blockquote>
<p>唐巧：你如何看待 Swift 语言，有没有计划过用 Swift 重写你的 YYKit？</p>
</blockquote>
<p>ibireme：相对于 Objective-C 来说，我觉得 Swift 无疑是更优秀、更现代的语言。目前我对 Swift 研究并不多，工作中也没有用到，但未来我会把时间更多投入到 Swift 中去。YYKit 中不少东西更适合于 C/Objective-C，所以我没有计划用 Swift 重写整个项目。我可能会用 Swift 写一些新的东西，以充分发挥 Swift 的特性。</p>
<blockquote>
<p>唐巧：你在 iOS 开发上是如何快速成长起来的？有没有什么心得可以分享给 iOS 开发新手？</p>
</blockquote>
<p>ibireme：我接触 iOS 开发的时间很早，但是一直都是在工作之余靠着兴趣自学的。14 年我还在人人网时，部门内部有个新项目需要 iOS 开发，我才得以有机会在工作中使用 iOS 相关的技术。全职转为 iOS 开发后，我花费了大量的时间阅读和学习各种开源的代码、研究其中的实现原理、尝试自己实现相关技术、尝试在工作中使用，这使得我在 iOS 开发技术上进步很快。对于 iOS 开发来说，我觉得自学能力是很重要的。主动去研究一些优秀的开源项目、多在工作中实践和学习，这样就能逐步提升个人技术水平了。</p>
<blockquote>
<p>唐巧：你觉得哪些开发者对你影响最大？</p>
</blockquote>
<p>ibireme：可能平时我更喜欢看代码，对于开发者我倒是了解的不多吧。如果要选一位的话，我会选 Linus Torvalds。他的一句话我很喜欢：”Talk is cheap, show me the code”。</p>
<blockquote>
<p>唐巧：在技术领域，你对未来有什么学习规划吗？</p>
</blockquote>
<p>ibireme：在 iOS 方面，我可能会针对 Swift、音频处理和合成等方面投入更多精力。另外我第一份工作是 Java 后台开发，工作时前后端、数据库相关的东西也都接触过，所以如果有时间的话我也会继续学习这些技术，即使不用在工作上，也能开拓眼界吧。</p>
<h3 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h3><p>刚刚 ibireme 在介绍自己学习方法的时候，提到了两点我认为非常关键，一个就是大量地阅读优秀项目的源代码，另一个就是自己动手实践来尝试。</p>
<p>我在很久以前，分享过我认为 iOS 开发者可以提高自己能力的各种方法，见 <a href="/2014/07/27/ios-levelup-tips/">《iOS 开发如何提高》</a>，里面也提到阅读开源代码和多写代码。我感觉 ibireme 将这一点做到了极致，因此他在短短一年多的时间，就能够成长成为在业界有影响力的开源项目作者。</p>
<p>我们处在一个信息爆炸的时代，每一天都有大量的 iOS 开发文章出现，我们对这些文章如饥似渴，但是很多时候又浅尝辄止。像 ibireme 这样，专心阅读几个开源项目，然后自己动手真正实践，或许才是正确的学习方式。</p>
<p>希望 ibireme 的故事能够激励那些渴望成长成为牛人的 iOS 开发新人，也希望在中国能够出现更多像 YYKit 这样的优秀的开源项目，与大家共勉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h3><p>本文为 InfoQ 中文站特供稿件，首发地址为：]]>
    </summary>
    
      <category term="Interview" scheme="http://blog.devtang.com/tags/Interview/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac 应用出现「已损坏」问题，苹果到底犯了什么傻逼错误？]]></title>
    <link href="http://blog.devtang.com/2015/11/21/apps-damaged-bug/"/>
    <id>http://blog.devtang.com/2015/11/21/apps-damaged-bug/</id>
    <published>2015-11-21T14:22:42.000Z</published>
    <updated>2016-02-16T10:26:44.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/apps-damaged-issue.jpg">
<h2 id="u4E8B_u4EF6_u56DE_u987E"><a href="#u4E8B_u4EF6_u56DE_u987E" class="headerlink" title="事件回顾"></a>事件回顾</h2><p>据国外多名网友反映，从 11 月 13 号开始，打开一些 Mac App Store 中下载的软件时，会出现 “已损坏”（Damaged）的提示。受此问题影响的软件较多，包括广为人知的 1Password、Dash、Byword 和 Tweetbot 等。Tweetbot 开发者 Paul Haddad 在 Twitter 上表示这个问题看起来与认证证书到期有关，并猜想目前证书使用 SHA256 加密，或许会和 OS X 老版本不兼容。</p>
<h2 id="u95EE_u9898_u539F_u56E0"><a href="#u95EE_u9898_u539F_u56E0" class="headerlink" title="问题原因"></a>问题原因</h2><p>微博上的 <a href="http://weibo.com/u/1713195262" target="_blank" rel="external">@webfrogs</a> 分享的<a href="http://m.imore.com/heres-whats-happening-mac-app-store-and-damaged-apps" target="_blank" rel="external">这篇文章</a>中详细解答了这个问题产生的原因。我仔细读了一下，给大家分享一下。</p>
<p>每一个 Mac AppStore 下载的软件都有一个证书，证明该软件是合法购买并且没有被篡改的。在以前，该证书是通过 SHA-1 来进行散列验证的，<a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F" target="_blank" rel="external">SHA-1</a> 是一种类似 MD5 的散列算法，比 MD5 更安全，但是计算起来更耗费 CPU 。</p>
<p>最近，苹果更改了证书的算法，使用 SHA-2 来进行散列验证的。这本来应该是对用户透明的，但是，苹果的质量部门却没有发现这个大 Bug。于是影响了大范围的用户。</p>
<p>具体影响的过程是：</p>
<ol>
<li>首先，过期的证书在缓存中没有被清除，系统会要求用户重启来清除证书或重新获得新证书。</li>
<li>然后，一些应用明显地使用的是旧版的 OpenSSL 来验证购买凭证，然后你猜怎么着？旧版的 OpenSSL 不！支！持！SHA-2 算法！</li>
</ol>
<p>由此我们就可以知道应该如何解决该问题了：</p>
<p>方案一：类似 XcodeGhost 事件那样，可以将那些使用旧版 OpenSSL 应用被苹果下架，要求它们升级到最新版的 OpenSSL，但是这个至少需要几天时间。</p>
<p>方案二：苹果将算法退回到 SHA-1。</p>
<p>于是，在愤怒的用户面前，苹果想了想，还是怂了，将算法退回（Roll back）到了 SHA-1。当然，想必他也会要求以后的应用必须使用新的 OpenSSL 库，然后确保没问题后再升级加密算法。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结起来就是：苹果傻逼了，搞了一个大 bug，然后自己回退代码了。这次事故苹果的质量保证部门应该犯有不可推卸的责任。</p>
<p>另外，我居然没受影响，原因是我没有升级 OS X 到最新版，所以逃过了一劫。不过我的一些搞 iOS 开发的小伙们可惨了，好多人挨个把软件重新下载了一遍。</p>
<p>乔布斯离世之后，苹果的软件质量变得越来越不稳定，加上创业太累，这让我这个不喜欢折腾的人越发喜欢等大家测试稳定之后再升级，希望这是我的错觉吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/apps-damaged-issue.jpg">
<h2 id="u4E8B_u4EF6_u56DE_u987E"><a href="#u4E8B_u4EF6_u56DE_u987E" class="headerlink" title="事件回]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Charles 从入门到精通]]></title>
    <link href="http://blog.devtang.com/2015/11/14/charles-introduction/"/>
    <id>http://blog.devtang.com/2015/11/14/charles-introduction/</id>
    <published>2015-11-14T04:00:47.000Z</published>
    <updated>2016-02-16T10:28:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h2><p>本文的内容主要包括：</p>
<ul>
<li>Charles 的简介</li>
<li>如何安装 Charles</li>
<li>将 Charles 设置成系统代理</li>
<li>Charles 主界面介绍</li>
<li>过滤网络请求</li>
<li>截取 iPhone 上的网络封包</li>
<li>截取 Https 通讯信息</li>
<li>模拟慢速网络</li>
<li>修改网络请求内容</li>
<li>给服务器做压力测试</li>
<li>修改服务器返回内容</li>
<li>总结</li>
</ul>
<!--
## Charles 中国特惠

Charles 正版[五折优惠活动](http://item.taobao.com/item.htm?&id=524230901640)（限时：2015 年 11 月 14 日 - 30 日），仅限中国区购买，[点击购买](http://item.taobao.com/item.htm?&id=524230901640)。在活动期结束后，价格将从 169 元上涨到 199 元。
-->
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><img src="/images/charles-logo.png">
<p><a href="http://www.charlesproxy.com/" target="_blank" rel="external">Charles</a> 是在 Mac 下常用的网络封包截取工具，在做<br>移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。</p>
<p>Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p>
<p>除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。</p>
<p>Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。</p>
<p>Charles 主要的功能包括：</p>
<ol>
<li>截取 Http 和 Https 网络封包。</li>
<li>支持重发网络请求，方便后端调试。</li>
<li>支持修改网络请求参数。</li>
<li>支持网络请求的截获并动态修改。</li>
<li>支持模拟慢速网络。</li>
</ol>
<h2 id="u5B89_u88C5_Charles"><a href="#u5B89_u88C5_Charles" class="headerlink" title="安装 Charles"></a>安装 Charles</h2><p>去 Charles 的官方网站（<a href="http://www.charlesproxy.com" target="_blank" rel="external">http://www.charlesproxy.com</a>）下载最新版的 Charles 安装包，是一个 dmg 后缀的文件。打开后将 Charles 拖到 Application 目录下即完成安装。</p>
<h2 id="u5C06_Charles__u8BBE_u7F6E_u6210_u7CFB_u7EDF_u4EE3_u7406"><a href="#u5C06_Charles__u8BBE_u7F6E_u6210_u7CFB_u7EDF_u4EE3_u7406" class="headerlink" title="将 Charles 设置成系统代理"></a>将 Charles 设置成系统代理</h2><p>之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。</p>
<p>启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” -&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示：</p>
<img src="/images/charles-pro-3.png">
<p>之后，你就可以看到源源不断的网络请求出现在 Charles 的界面中。</p>
<p>需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 <code>127.0.0.1:8888</code> 也可达到相同效果。</p>
<h2 id="Charles__u4E3B_u754C_u9762_u4ECB_u7ECD"><a href="#Charles__u4E3B_u754C_u9762_u4ECB_u7ECD" class="headerlink" title="Charles 主界面介绍"></a>Charles 主界面介绍</h2><img src="/images/charles-pro-4.png">
<p>Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。 </p>
<ol>
<li>Structure 视图将网络请求按访问的域名分类。</li>
<li>Sequence 视图将网络请求按访问的时间排序。</li>
</ol>
<p>大家可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 Filter 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。</p>
<p>对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。</p>
<h2 id="u8FC7_u6EE4_u7F51_u7EDC_u8BF7_u6C42"><a href="#u8FC7_u6EE4_u7F51_u7EDC_u8BF7_u6C42" class="headerlink" title="过滤网络请求"></a>过滤网络请求</h2><p>通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，以下几种办法：</p>
<p>方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：<code>http://yuantiku.com</code> , 那么只需要在 Filter 栏中填入 yuantiku 即可。</p>
<p>方法二：在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：</p>
<img src="/images/charles-filter-setting.jpg">
<p>通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。</p>
<p>方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示：</p>
<img src="/images/charles-focus.png">
<p>这种方式可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。</p>
<h2 id="u622A_u53D6_iPhone__u4E0A_u7684_u7F51_u7EDC_u5C01_u5305"><a href="#u622A_u53D6_iPhone__u4E0A_u7684_u7F51_u7EDC_u5C01_u5305" class="headerlink" title="截取 iPhone 上的网络封包"></a>截取 iPhone 上的网络封包</h2><p>Charles 通常用来截取本地上的网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。</p>
<h3 id="Charles__u4E0A_u7684_u8BBE_u7F6E"><a href="#Charles__u4E0A_u7684_u8BBE_u7F6E" class="headerlink" title="Charles 上的设置"></a>Charles 上的设置</h3><p>要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示:</p>
<img src="/images/charles-proxy-setting.jpg">
<h3 id="iPhone__u4E0A_u7684_u8BBE_u7F6E"><a href="#iPhone__u4E0A_u7684_u8BBE_u7F6E" class="headerlink" title="iPhone 上的设置"></a>iPhone 上的设置</h3><p>首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示：</p>
<img src="/images/charles-local-ip.png">
<p>在 iPhone 的 “ 设置 “-&gt;” 无线局域网 “ 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图所示：</p>
<img src="/images/charles-iphone-setting.jpg">
<p>设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单（如下图所示），点击 “Allow” 即可完成设置。</p>
<img src="/images/charles-proxy-confirm.jpg">
<h2 id="u622A_u53D6_Https__u901A_u8BAF_u4FE1_u606F"><a href="#u622A_u53D6_Https__u901A_u8BAF_u4FE1_u606F" class="headerlink" title="截取 Https 通讯信息"></a>截取 Https 通讯信息</h2><h3 id="u5B89_u88C5_u8BC1_u4E66"><a href="#u5B89_u88C5_u8BC1_u4E66" class="headerlink" title="安装证书"></a>安装证书</h3><p>如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。</p>
<p>首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图所示：</p>
<img src="/images/charles-pro-1.png">
<p>需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 SSL proxy，如下图所示：</p>
<img src="/images/charles-ssl-add-host.jpg">
<p>这样，对于该 Host 的所有 SSL 请求可以被截取到了。</p>
<h3 id="u622A_u53D6_u79FB_u52A8_u8BBE_u5907_u4E2D_u7684_Https__u901A_u8BAF_u4FE1_u606F"><a href="#u622A_u53D6_u79FB_u52A8_u8BBE_u5907_u4E2D_u7684_Https__u901A_u8BAF_u4FE1_u606F" class="headerlink" title="截取移动设备中的 Https 通讯信息"></a>截取移动设备中的 Https 通讯信息</h3><p>如果我们需要在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。如下图所示：</p>
<img src="/images/charles-pro-2.png">
<p>按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：<a href="http://charlesproxy.com/getssl" target="_blank" rel="external">http://charlesproxy.com/getssl</a>，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。</p>
<h2 id="u6A21_u62DF_u6162_u901F_u7F51_u7EDC"><a href="#u6A21_u62DF_u6162_u901F_u7F51_u7EDC" class="headerlink" title="模拟慢速网络"></a>模拟慢速网络</h2><p>在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。</p>
<p>在 Charles 的菜单上，选择 “Proxy”-&gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示：</p>
<img src="/images/charles-throttle-setting.jpg">
<p>如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。</p>
<h2 id="u4FEE_u6539_u7F51_u7EDC_u8BF7_u6C42_u5185_u5BB9"><a href="#u4FEE_u6539_u7F51_u7EDC_u8BF7_u6C42_u5185_u5BB9" class="headerlink" title="修改网络请求内容"></a>修改网络请求内容</h2><p>有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下所示：</p>
<img src="/images/charles-edit.png">
<p>我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图所示）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如下图所示：</p>
<img src="/images/charles-execute.png">
<h2 id="u7ED9_u670D_u52A1_u5668_u505A_u538B_u529B_u6D4B_u8BD5"><a href="#u7ED9_u670D_u52A1_u5668_u505A_u538B_u529B_u6D4B_u8BD5" class="headerlink" title="给服务器做压力测试"></a>给服务器做压力测试</h2><p>我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。</p>
<p>我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示：</p>
<img src="/images/charles-repeat-1.png">
<p>接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。</p>
<img src="/images/charles-repeat-2.png">
<p>悄悄说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也拿 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据，上次不小心还把一个钓鱼网站的数据库打挂了，嗯，请叫我雷锋。</p>
<h2 id="u4FEE_u6539_u670D_u52A1_u5668_u8FD4_u56DE_u5185_u5BB9"><a href="#u4FEE_u6539_u670D_u52A1_u5668_u8FD4_u56DE_u5185_u5BB9" class="headerlink" title="修改服务器返回内容"></a>修改服务器返回内容</h2><p>有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。</p>
<p>根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是：</p>
<ol>
<li>Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。</li>
<li>Rewrite 功能适合对网络请求进行一些正则替换。</li>
<li>Breakpoints 功能适合做一些临时性的修改。</li>
</ol>
<h3 id="Map__u529F_u80FD"><a href="#Map__u529F_u80FD" class="headerlink" title="Map 功能"></a>Map 功能</h3><p>Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。</p>
<p>在 Charles 的菜单中，选择 “Tools”-&gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。</p>
<img src="/images/charles-map.png">
<p>对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 <code>ytk1.yuanku.ws</code>（测试服务器）的请求重定向到了 <code>www.yuantiku.com</code>（线上服务器）。</p>
<img src="/images/charles-map-remote.png">
<p>对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图所示），然后稍加修改，成为我们的目标映射文件。</p>
<img src="/images/charles-save-response.png">
<p>下图是一个示例，我将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。</p>
<img src="/images/charles-map-local.png">
<h3 id="Rewrite__u529F_u80FD"><a href="#Rewrite__u529F_u80FD" class="headerlink" title="Rewrite 功能"></a>Rewrite 功能</h3><p>Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。</p>
<p>例如，我们的客户端有一个 API 请求是获得用户昵称，而我当前的昵称是 “tangqiaoboy”，如下所示：</p>
<img src="/images/charles-rewrite-1.jpeg">
<p>我们想试着直接修改网络返回值，将 tangqiaoboy 换成成 iosboy。于是我们启用 Rewrite 功能，然后设置如下的规则：</p>
<img src="/images/charles-rewrite-2.png">
<p>完成设置之后，我们就可以从 Charles 中看到，之后的 API 获得的昵称被自动 Rewrite 成了 iosboy，如下图所示：</p>
<img src="/images/charles-rewrite-3.png">
<h3 id="Breakpoints__u529F_u80FD"><a href="#Breakpoints__u529F_u80FD" class="headerlink" title="Breakpoints 功能"></a>Breakpoints 功能</h3><p>上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。</p>
<p>Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。</p>
<p>下图是我们临时修改获取用户信息的 API，将用户的昵称进行了更改，修改完成后点击 “Execute” 则可以让网络请求继续进行。</p>
<img src="/images/charles-breakpoint.png">
<p>需要注意的是，使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>通过 Charles 软件，我们可以很方便地在日常开发中，截取和调试网络请求内容，分析封包协议以及模拟慢速网络。用好 Charles 可以极大的方便我们对于带有网络请求的 App 的开发和调试。</p>
<p>愿本文帮助大家成为 Charles 的专家，祝大家玩得开心～</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h2><p>本文的内容主要包括：</p>
<ul>
<li>Charles 的简介</li>
<li>如何安装 Ch]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
</feed>
