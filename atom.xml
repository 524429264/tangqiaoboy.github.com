<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[唐巧的技术博客]]></title>
  <subtitle><![CDATA[记录下自己学习的点滴]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2016-02-27T15:28:05.000Z</updated>
  <id>http://blog.devtang.com/</id>
  
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（三） - 高阶函数]]></title>
    <link href="http://blog.devtang.com/2016/02/27/swift-gym-3-higher-order-function/"/>
    <id>http://blog.devtang.com/2016/02/27/swift-gym-3-higher-order-function/</id>
    <published>2016-02-27T01:25:51.000Z</published>
    <updated>2016-02-27T15:28:05.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/swift-brain-gym-high-order-function" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第三节，练习前请做好准备运动，保持头脑清醒。</p>
<h2 id="u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6"><a href="#u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="准备运动：基础知识"></a>准备运动：基础知识</h2><p><img src="http://ww1.sinaimg.cn/mw690/65dc76a3gw1f0sz14hv65j20er08t0tz.jpg" alt=""></p>
<p>在上一节里面，我们其实已经涉及到了高阶函数了。在 <a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">Wikipedia</a> 中，是这么定义高阶函数（higher-order function）的，如果一个函数：</p>
<ul>
<li>接受一个或多个函数当作参数</li>
<li>把一个函数当作返回值</li>
</ul>
<p>那么这个函数就被称作高阶函数。下面是一个简单的排序的例子，在这个例子中，传进去的参数就是一个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numbers = [1, 4, 2, 3]&#10;let res = numbers.sort &#123;&#10;    $0 &#60; $1&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trailing_Closure_Syntax"><a href="#Trailing_Closure_Syntax" class="headerlink" title="Trailing Closure Syntax"></a>Trailing Closure Syntax</h3><p>上面的代码看着不像是函数作为参数存在，这是因为 Swift 的 Trailing Closure 特性。Swift 允许当函数的最后一个参数是闭包的时候，以紧跟 <code>{ }</code> 的形式，将最后一个闭包的内容附加在函数后面。</p>
<p>所以，以下两行代码是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#27491;&#24120;&#20889;&#27861;&#65292;&#20989;&#25968;&#26159;&#20316;&#20026; sort &#30340;&#21442;&#25968;&#10;arr.sort(&#123; $0 &#60; $1 &#125;)&#10;&#10;// Trailing Closure &#20889;&#27861;&#65292;&#26356;&#31616;&#27905;&#26126;&#20102;&#10;arr.sort &#123; $0 &#60; $1 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5E38_u89C1_u7528_u6CD5_u793A_u4F8B"><a href="#u5E38_u89C1_u7528_u6CD5_u793A_u4F8B" class="headerlink" title="常见用法示例"></a>常见用法示例</h2><p>高阶函数在 Swift 语言中有大量的使用场景，我们先来看一看常见的用法：</p>
<h3 id="u904D_u5386"><a href="#u904D_u5386" class="headerlink" title="遍历"></a>遍历</h3><p>我们可以用 <code>map</code> 方法来对数组元素进行某种规则的转换，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.map &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// brr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]</span><br></pre></td></tr></table></figure>
<h3 id="u6C42_u548C"><a href="#u6C42_u548C" class="headerlink" title="求和"></a>求和</h3><p>我们可以用 <code>reduce</code> 方法，来对数组元素进行某种规则的求和（不一定是加和）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.reduce(0) &#123;&#10;    (prevSum: Int, element: Int) in&#10;    return prevSum + element&#10;&#125;&#10;// brr = 7&#10;let crr = arr.reduce(&#34;&#34;) &#123;&#10;    if $0 == &#34;&#34; &#123;&#10;        return String($1)&#10;    &#125; else &#123;&#10;        return $0 + &#34; &#34; + String($1)&#10;    &#125;&#10;&#125;&#10;// crr = &#34;1 2 4&#34;</span><br></pre></td></tr></table></figure>
<h3 id="u7B5B_u9009"><a href="#u7B5B_u9009" class="headerlink" title="筛选"></a>筛选</h3><p>我们可以利用 <code>filter</code> 方法，来对数组元素进行某种规则的过滤，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.filter &#123;&#10;    $0 % 2 == 0&#10;&#125;&#10;// brr = [2, 4]</span><br></pre></td></tr></table></figure>
<h3 id="u904D_u5386-1"><a href="#u904D_u5386-1" class="headerlink" title="遍历"></a>遍历</h3><p>即使是以前最简单的遍历，我们也可以用高阶函数的写法，将遍历需要的操作，以函数参数的形式传入 <code>forEach</code> 方法中，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;arr.forEach &#123;&#10;    print($0)&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u70E7_u8111_u4F53_u64CD"><a href="#u70E7_u8111_u4F53_u64CD" class="headerlink" title="烧脑体操"></a>烧脑体操</h2><p>下面我们来看看高阶函数一些比较烧脑的细节。</p>
<h3 id="u7528_u9AD8_u9636_u51FD_u6570_u6765_u9690_u85CF_u79C1_u6709_u53D8_u91CF"><a href="#u7528_u9AD8_u9636_u51FD_u6570_u6765_u9690_u85CF_u79C1_u6709_u53D8_u91CF" class="headerlink" title="用高阶函数来隐藏私有变量"></a>用高阶函数来隐藏私有变量</h3><p>高阶函数使得代码逻辑可以用函数为主体来进行封装，下面我将详细解释一下这句话。</p>
<p>在面向对象的世界里，逻辑存在的基本单元是对象，每个对象代表着一个最小可复用模块。在对象的内部，由高内聚的成员变量和成员函数构成。这些函数相互调用，并且操作对象的内部成员变量，最终对外产生可预期的行为。</p>
<p>但是利用高阶函数，我们可以同样做到与对象类似的，高内聚的成员变量和成员函数，下面我就举一个具体的例子。</p>
<p>下面的代码中，我们用类的方式，实现了一个 <code>Clock</code> 类， <code>Clock</code> 类实现了一个 <code>getCount</code> 方法，每次调用的时候返回的值 <code>+1</code>。为了测试代码，我们定义了两个实例 c1 和 c2，它们都可以正常输出预期的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Clock &#123;&#10;    var count: Int = 0&#10;    func getCount() -&#62; Int &#123;&#10;        return ++count;&#10;    &#125;&#10;&#125;&#10;&#10;let c1 = Clock()&#10;c1.getCount() // &#24471;&#21040; 1&#10;c1.getCount() // &#24471;&#21040; 2&#10;let c2 = Clock()&#10;c2.getCount() // &#24471;&#21040; 1</span><br></pre></td></tr></table></figure>
<p>那么接下来，我们用高阶函数的方式，来做一下同样的事情。我们先看代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func getClock() -&#62; () -&#62; Int &#123;&#10;    var count: Int = 0&#10;    let getCount = &#123; () -&#62; Int in&#10;        ++count;&#10;    &#125;&#10;    return getCount&#10;&#125;&#10;&#10;let c1 = getClock()&#10;c1()  // &#24471;&#21040; 1&#10;c1()  // &#24471;&#21040; 2&#10;let c2 = getClock()&#10;c2()  // &#24471;&#21040; 1</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们这里定义了一个 <code>getClock</code> 函数，这个函数可以返回一个 <code>getCount</code> 函数。然后，不太一样的地方是，这个 <code>getCount</code> 函数持有了一个外部的变量 <code>count</code>。于是，这个函数也变得有了状态（或者你也可以说它有了 Side Effect）。每次调用这个函数的时候，返回的值都会变化。</p>
<p>另一方面，因为<code>count</code>变量是 <code>getClock</code> 这个高阶函数的内部变量，所以它并没有像全局变量一样使得封装性被打破。<code>getClock</code>函数仍然可以看作一个高内部的可复用模块，并且对外隐藏了实现细节。</p>
<p>所以，Swift 语言的高阶函数以及闭包可以 capture 外部变量的特性，使得代码逻辑可以以函数作为主体来进行封装，这将使得我们的代码组织更加灵活。</p>
<p>当然，如果滥用，这也会造成代码组织变得更加混乱。</p>
<h3 id="u9762_u8BD5_u9898"><a href="#u9762_u8BD5_u9898" class="headerlink" title="面试题"></a>面试题</h3><h4 id="u9898_u76EE_u4E00"><a href="#u9898_u76EE_u4E00" class="headerlink" title="题目一"></a>题目一</h4><p>另一个烧脑的故事是来自于一个朋友的面试题。在面试中，面试官要求他用数组的 <code>reduce</code> 方法实现 <code>map</code> 的功能。</p>
<p>这个题目实在是非常蛋疼，不过用来烧脑倒是不错，大家感兴趣的话可以先想想，再翻下面的参考答案。</p>
<h4 id="u9898_u76EE_u4E8C"><a href="#u9898_u76EE_u4E8C" class="headerlink" title="题目二"></a>题目二</h4><p>不过说回来，虽然题目一有些奇怪，但是它确实考查了对于高阶函数灵活使用以及对 <code>reduce</code> 方法的理解。大家还可以试试这些题目：</p>
<ul>
<li>问题一：用 <code>reduce</code> 方法找出数组中的最大值。</li>
<li>问题二：用 <code>reduce</code> 方法一次求出数组中奇数的和、以及偶数乘积。</li>
</ul>
<h4 id="u9898_u76EE_u4E09"><a href="#u9898_u76EE_u4E09" class="headerlink" title="题目三"></a>题目三</h4><p>高阶函数另一个魔力就是可以链式调用，大家可以尝试这么一道题目：求一个数组中偶数的平方和。</p>
<h3 id="u53C2_u8003_u7B54_u6848"><a href="#u53C2_u8003_u7B54_u6848" class="headerlink" title="参考答案"></a>参考答案</h3><h4 id="u9898_u76EE_u4E00-1"><a href="#u9898_u76EE_u4E00-1" class="headerlink" title="题目一"></a>题目一</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 3, 2]&#10;let res = arr.reduce([]) &#123;&#10;    (a: [Int], element: Int) -&#62; [Int] in&#10;    var t = Array(a)&#10;    t.append(element * 2)&#10;    return t&#10;&#125;&#10;// res = [2, 6, 4]</span><br></pre></td></tr></table></figure>
<h4 id="u9898_u76EE_u4E8C-1"><a href="#u9898_u76EE_u4E8C-1" class="headerlink" title="题目二"></a>题目二</h4><p>问题二的参考答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 3, 2, 4]&#10;&#10;let res: (Int, Int) = arr.reduce((0, 1)) &#123;&#10;    (a :(Int, Int), element: Int) -&#62; (Int, Int) in&#10;    if element % 2 == 0 &#123;&#10;        return (a.0, a.1 * element)&#10;    &#125; else &#123;&#10;        return (a.0 + element, a.1)&#10;    &#125;&#10;&#125;&#10;// res = (4, 8)</span><br></pre></td></tr></table></figure>
<h4 id="u9898_u76EE_u4E09-1"><a href="#u9898_u76EE_u4E09-1" class="headerlink" title="题目三"></a>题目三</h4><p>以下是参考答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 3, 2, 4]&#10;let res = arr.filter &#123;&#10;        $0 % 2 == 0&#10;    &#125;.map &#123;&#10;        $0 * $0&#10;    &#125;.reduce(0) &#123;&#10;        $0 + $1&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结一下本次烧脑锻炼到的脑细胞：</p>
<ul>
<li>学习了 Swift 语言中的一些使用高阶函数的示例，包括 <code>map</code>, <code>reduce</code>, <code>filter</code> 等。</li>
<li>学习了利用高阶函数来构造以函数为主体的功能模块。</li>
<li>练习了一些奇怪的面试题。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（二） - 函数的参数]]></title>
    <link href="http://blog.devtang.com/2016/02/27/swift-gym-2-function-argument/"/>
    <id>http://blog.devtang.com/2016/02/27/swift-gym-2-function-argument/</id>
    <published>2016-02-27T01:23:29.000Z</published>
    <updated>2016-02-27T01:33:21.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/swift-brain-gym-arguments" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第二节，练习前请做好准备运动，保持头脑清醒。</p>
<h2 id="u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6"><a href="#u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="准备运动：基础知识"></a>准备运动：基础知识</h2><p><img src="http://ww3.sinaimg.cn/mw690/65dc76a3gw1f0sz14p1u4j206w0a33zb.jpg" alt=""></p>
<h3 id="u9762_u5411_u5BF9_u8C61_u8BED_u8A00_u7684_u4E16_u754C_u89C2"><a href="#u9762_u5411_u5BF9_u8C61_u8BED_u8A00_u7684_u4E16_u754C_u89C2" class="headerlink" title="面向对象语言的世界观"></a>面向对象语言的世界观</h3><p>对于很多面向对象的编程语言来说，在思考问题时，总是把「对象」作为考虑问题的基本出发点。</p>
<p>面向对象的程序设计通过以下三大规则，构建出程序设计的基础，它们是：</p>
<ol>
<li>封装（Encapsulation），将一个相对独立的逻辑涉及的变量和函数放到一个类中，然后对外暴露少量接口，使其高内聚，低耦合。</li>
<li>继承（Inheritance），子类可以继承父类的变量和函数，并且可以修改或扩展父类的行为。</li>
<li>多态（Polymorphism），父类的指针可以指向子类的实例，在运行时程序语言支持找到子类对应的函数实现。</li>
</ol>
<p>在以上三大准则的基础上，再引入一些设计原则，比如：</p>
<ol>
<li>单一职责原则（Single Responsibility），每个类只应该做一件事情。</li>
<li>不要重复原则（Don’t Repeat Yourself），相同（或相似）的代码不应该重复两次。</li>
<li>好的组合优于继承（Better Composition over Inheritance），尽量使用组合而不是继承来设计。</li>
</ol>
<p>于是，程序世界就基于这些规则和原则，产生出了设计模式，进而能更加精准地指导我们的编程行为。这就像我们学习几何，先学习几条公理，然后以后的大量定理都通过公理证明而来。</p>
<p>举个例子，单例模式（Singleton Pattern）其实就是封装和单一职责原则的产物。代理模式（Delegate Pattern) 也是单一职责和封装中的面向接口设计的思想的产物。</p>
<p>但是，在面向对象语言的世界观里面，函数都是作为一个附属物存在的。函数通常附属于一个具体类的某个方法中。或许有一个函数它根本都不需要任何对象作为容器，为了这个世界的统一，我们还是会构造一个类，把这个函数放进去。比如，在小猿搜题中，我们就有一个叫 ImageUtils 的类，里面放了操作图像的各种各样的静态方法，有一些图象操作函数其实也不太通用，但是总得找一个类放不是。</p>
<p>在一些面向对象语言的世界中，如果把对象称作 OOP 的一等公民的话，那么函数就是二等公民。</p>
<h3 id="u51FD_u6570_u5F0F_u7F16_u7A0B"><a href="#u51FD_u6570_u5F0F_u7F16_u7A0B" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>在 Swift 的世界中，函数并不是二等公民。是的，Swift 引入了大量函数式编程的特性，使得我们能够把函数当作一等公民来对待。</p>
<p>一等公民有什么权利呢？那就是函数可以像对象一样，被赋值、被当作参数传递、参与计算或者当作结果被返回。</p>
<p>我们先来看一段函数被赋值的例子，在下例中，我们将一个函数赋值给一个名为 <code>myFunc</code> 的变量，然后调用它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myFunc = &#123; &#10;    () -&#62; String in&#10;    return &#34;Tang Qiao&#34;&#10;&#125;&#10;&#10;let value = myFunc()&#10;// value &#30340;&#20540;&#20026; &#34;Tang Qiao&#34;</span><br></pre></td></tr></table></figure>
<p>我们再来看一个函数被当作运算结果返回的例子。在这个例子中，我们希望构造一个「加法器」工厂，这个工厂能够接受一个参数 addValue，返回一个加法器函数，这个加法器函数能够将传递的参数加 addValue 之后返回。以下是实现的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func addFactory(addValue: Int) -&#62; (Int -&#62; Int) &#123;&#10;    func adder(value: Int) -&#62; Int &#123;&#10;        return addValue + value&#10;    &#125;&#10;    return adder&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>有了上面这个函数，我们就可以构造一个 <code>+2</code> 的函数，然后使用它，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add2 = addFactory(2) // &#26500;&#36896;&#19968;&#20010; +2 &#30340;&#20989;&#25968;&#10;let result = add2(3) // &#36816;&#31639;&#65292;&#20256;&#20837; 3&#65292;&#24471;&#21040; 5</span><br></pre></td></tr></table></figure>
<h2 id="u51FD_u6570_u7684_u53C2_u6570"><a href="#u51FD_u6570_u7684_u53C2_u6570" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>但是在本次「烧脑体操」中，全面介绍函数式编程明显不太现实，所以我们仅从函数的参数来深入学习一下，看看在 Swift 语言中，函数的参数能够有多复杂。</p>
<!--
这里多说一句题外话，有部分同学看了「烧脑体操」第一节后，留言说：本来简单的 Swift 语言，被你这么一说，弄得都不敢学了，你是不是在吓大家？还有一些人留言：你搞这么绕还不是为了装逼？

对此，我想回答说：我研究这些仅仅是为了避免在语言细节的地方掉坑里，如果你对此不感兴趣，有一个动作叫做「取消关注」，我写文章并没有收费，如果你不喜欢，取关即可，犯不着在后台留言恶心我吧？
-->
<h3 id="u53C2_u6570_u7684_u7701_u7565"><a href="#u53C2_u6570_u7684_u7701_u7565" class="headerlink" title="参数的省略"></a>参数的省略</h3><p>我们先来简单看看函数参数的省略吧，因为有类型推导，函数的参数在 Swift 中常常可以被省略掉，特别以匿名函数（闭包）的形式存在的时候。</p>
<p>我们来看一个数组排序的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    (a: Int, b: Int) -&#62; Bool in&#10;    return a &#60; b&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个函数返回类型可以通过推导出来，则返回类型可以省略。所以以上代码中的 <code>-&gt; Bool</code> 可以删掉，变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    (a: Int, b: Int) in&#10;    return a &#60; b&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个函数的参数类型可以推导出来，则参数的类型可以省略。所以以上代码中的 <code>: Int</code> 可以删掉，变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    (a, b) in&#10;    return a &#60; b&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数参数的个数可以推导出来，也可以不写参数。那怎么使用这些参数呢？可以用 <code>$0</code>, <code>$1</code> 这样的方式来引用参数。所以以上代码中的 <code>(a, b)</code> 可以删掉，因为这样的话，参数和返回值都省略了，所以<code>in</code>也可以省略了，变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    return $0 &#60; $1&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 还有一个规则，如果函数的 body 只有一行，则可以把 <code>return</code> 关键字省略了，所以以上代码可以进一步简化成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    $0 &#60; $1&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个简化规则更加暴力，因为 <code>&lt;</code> 符号也是一个函数，它接受的参数个数，类型和返回值与 sort 函数需要的一样，所以可以直接简化成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort( &#60; )</span><br></pre></td></tr></table></figure>
<p>拿这个的方法，同样可以把我们刚刚写的 <code>addFactory</code> 做简化，最后简化成如下的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#31616;&#21270;&#21069;&#10;func addFactory(addValue: Int) -&#62; (Int -&#62; Int) &#123;&#10;    func adder(value: Int) -&#62; Int &#123;&#10;        return addValue + value&#10;    &#125;&#10;    return adder&#10;&#125;&#10;// &#31616;&#21270;&#21518;&#10;func addFactory(addValue: Int) -&#62; (Int -&#62; Int) &#123;&#10;    return &#123; addValue + $0 &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u51FD_u6570_u53C2_u6570_u4E2D_u7684_u5176_u5B83_u5173_u952E_u5B57"><a href="#u51FD_u6570_u53C2_u6570_u4E2D_u7684_u5176_u5B83_u5173_u952E_u5B57" class="headerlink" title="函数参数中的其它关键字"></a>函数参数中的其它关键字</h3><p>有些时候，我们的函数接受的参数就是另外一个函数，例如 sort，map，所以我们在看代码的时候，需要具备熟悉这种写法的能力。</p>
<p>我们来看看数组的 map 函数的定义吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func map&#60;T&#62;(@noescape transform: (Self.Generator.Element) throws -&#62; T) rethrows -&#62; [T]</span><br></pre></td></tr></table></figure>
<p>这个函数定义中出现了几个我们刚刚没提到的关键词，我们先学习一下。</p>
<h4 id="@noescape"><a href="#@noescape" class="headerlink" title="@noescape"></a><code>@noescape</code></h4><p><code>@noescape</code>，这是一个从 Swift 1.2 引入的关键字，它是专门用于修饰函数闭包这种参数类型的，当出现这个参数时，它表示该闭包不会跳出这个函数调用的生命期：即函数调用完之后，这个闭包的生命期也结束了。以下是苹果的文档原文：</p>
<blockquote>
<p>A new @noescape attribute may be used on closure parameters to functions. This indicates that the parameter is only ever called (or passed as an @noescape parameter in a call), which means that it cannot outlive the lifetime of the call. This enables some minor performance optimizations, but more importantly disables the self. requirement in closure arguments.</p>
</blockquote>
<p>什么情况下一个闭包参数会跳出函数的生命期呢？很简单，我们在函数实现内，将一个闭包用 <code>dispatch_async</code> 嵌套，这样这个闭包就会在另外一个线程中存在，从而跳出了当前函数的生命期。这样做主要是可以帮助编译器做性能的优化。</p>
<p>如果你对此感兴趣，这里有一些更详细的介绍供你学习：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/28427436/noescape-attribute-in-swift-1-2/28428521#28428521" target="_blank" rel="external">https://stackoverflow.com/questions/28427436/noescape-attribute-in-swift-1-2/28428521#28428521</a></li>
<li><a href="http://nshint.io/blog/2015/10/23/noescape-attribute/" target="_blank" rel="external">http://nshint.io/blog/2015/10/23/noescape-attribute/</a></li>
</ul>
<h4 id="throws__u548C_rethrows"><a href="#throws__u548C_rethrows" class="headerlink" title="throws 和 rethrows"></a><code>throws</code> 和 <code>rethrows</code></h4><p><code>throws</code> 关键字表示：这个函数（闭包）可能抛出异常。而 <code>rethrows</code> 关键字表示：这个函数如果抛出异常，仅可能是因为传递给它的闭包的调用导致了异常。</p>
<p><code>throws</code> 关键字的存在大家都应该能理解，因为总有一些异常可能在设计的时候希望暴露给上层，<code>throws</code> 关键字的存在使得这种设计成为可能。</p>
<p>那么为什么会有 <code>rethrows</code> 关键字呢？在我看来，这是为了简化很多代码的书写。因为一旦一个函数会抛出异常，按 Swift 类型安全的写法，我们就需要使用 try 语法。但是如果很多地方都需要写 try 的话，会造成代码非常啰嗦。 <code>rethrows</code> 关键字使得一些情况下，如果你传进去的闭包不会抛出异常，那么你的调用代码就不需要写 try。</p>
<p>如果你对此感兴趣，这里有一些更详细的介绍供你学习：</p>
<ul>
<li><a href="http://robnapier.net/re-throws" target="_blank" rel="external">http://robnapier.net/re-throws</a></li>
</ul>
<h3 id="u51FD_u6570_u4F5C_u4E3A_u51FD_u6570_u7684_u53C2_u6570"><a href="#u51FD_u6570_u4F5C_u4E3A_u51FD_u6570_u7684_u53C2_u6570" class="headerlink" title="函数作为函数的参数"></a>函数作为函数的参数</h3><p>刚刚说到，函数作为一等公民，意味着函数可以像对象一样，被当作参数传递或者被当作值返回。对此，我们专门有一个名称来称呼它，叫做<a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">高阶函数（higher-order function）</a>。</p>
<p>在刚刚那个数组的 map 函数中，我们就看到了它接着另外一个函数作为参数，这个函数接受数组元素类型作为参数，返回一个新类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func map&#60;T&#62;(@noescape transform: (Self.Generator.Element) throws -&#62; T) rethrows -&#62; [T]</span><br></pre></td></tr></table></figure>
<p>有了 map 函数，我们就可以轻松做数组元素的变换了。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.map &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// brr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]</span><br></pre></td></tr></table></figure>
<h2 id="u70E7_u8111_u7684_u53C2_u6570"><a href="#u70E7_u8111_u7684_u53C2_u6570" class="headerlink" title="烧脑的参数"></a>烧脑的参数</h2><p>好了，现在进入参数烧脑游戏的正式环节。</p>
<p>我们需要构造一个工厂函数，这个函数接受两个函数作为参数，返回一个新的函数。新函数是两个函数参数的叠加作用效果。</p>
<p>举一个具体的例子，假如我们有一个 <code>+2</code> 的函数，有一个 <code>+3</code> 的函数，那用这个工厂函数，我们可以得到一个 <code>+5</code> 的函数。</p>
<p>又比如我们有一个 <code>*2</code> 的函数，有一个 <code>*5</code> 的函数，用这个工厂函数，我们就可以得到一个 <code>*10</code> 的函数。</p>
<p>那这个函数如何写呢？我们先看答案吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func funcBuild(f: Int -&#62; Int, _ g: Int -&#62; Int) &#10;    -&#62; Int -&#62; Int &#123;&#10;    return &#123;&#10;        f(g($0))&#10;    &#125;&#10;&#125;&#10;&#10;let f1 = funcBuild(&#123;$0 + 2&#125;, &#123;$0 + 3&#125;)&#10;f1(0) // &#24471;&#21040; 5&#10;let f2 = funcBuild(&#123;$0 * 2&#125;, &#123;$0 * 5&#125;)&#10;f2(1) // &#24471;&#21040; 10</span><br></pre></td></tr></table></figure>
<p>这个函数充分反映了函数作为一等公民的地位。但是，我们同时也看出来，函数作为参数存在时，对于程序的可读性带来了挑战。好在我们有 <code>typealias</code>，通过 <code>typealias</code>，我们可以将函数的类型写得更加易读，比如上面的代码，就可以修改成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typealias IntFunction = Int -&#62; Int&#10;&#10;func funcBuild(f: IntFunction, _ g: IntFunction)&#10;    -&#62; IntFunction &#123;&#10;    return &#123;&#10;        f(g($0))&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>现在看看代码，是不是清晰了很多？</p>
<h2 id="u53C2_u6570_u4E2D_u7684_u8303_u578B"><a href="#u53C2_u6570_u4E2D_u7684_u8303_u578B" class="headerlink" title="参数中的范型"></a>参数中的范型</h2><p>当函数中的参数再引入范型之后，函数的功能更加强大，但是可读性进一步下降。比如刚刚的例子，限制函数只能是 <code>Int -&gt; Int</code> 其实是没有必要的，我们将两个函数拼成一个函数，只需要保证一个函数的输出类型，与另一个函数的输入类型匹配即可。所以，刚刚的例子，可以进一步用范型改造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func funcBuild&#60;T, U, V&#62;(f: T -&#62; U, _ g: V -&#62; T)&#10;    -&#62; V -&#62; U &#123;&#10;        return &#123;&#10;            f(g($0))&#10;        &#125;&#10;&#125;&#10;let f3 = funcBuild(&#123; &#34;No.&#34; + String($0) &#125;, &#123;$0 * 2&#125;)&#10;f3(23) // &#32467;&#26524;&#26159; &#34;No.46&#34;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，我们保证函数 g 的输出类型是 T，函数 f 的输入类型是 T。这样，在例子中，我们将一个 <code>*2</code> 的函数与一个数字转字符串的函数拼接起来，构造出一个先乘 2，再转字符串的函数。</p>
<p>相应的例子还有很多，比如 WWDC 中就介绍过一个给函数增加缓存机制的代码，在该代码中，任意一个不带缓存功能的函数，经过改造，都可以变成一个带缓存功能的函数。代码如下，大家可以自行学习一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func memoize&#60;T: Hashable, U&#62;( body: (T)-&#62;U ) -&#62; (T-&#62;U) &#123;&#10;    var memo = Dictionary&#60;T, U&#62;()&#10;    return &#123; x in&#10;        if let q = memo[x] &#123; return q &#125;&#10;        let r = body(x)&#10;        memo[x] = r&#10;        return r&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结一下本次烧脑锻炼到的脑细胞：</p>
<ul>
<li>Swift 是一个结合面向对象编程和函数式编程特性的语言。</li>
<li>函数在 Swift 中是一等公民，可以被赋值、被当作参数传递、参与计算、当作结果被返回或被动态创建。</li>
<li>因为有类型推导，函数的参数有各种省略规则。</li>
<li>函数作为参数时，有 @noescape，throw 和 rethrow 关键字需要了解。</li>
<li>函数作为参数时，不易阅读。合理使用 typealias 可以使源码结构更清晰。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（一） - Optional 的嵌套]]></title>
    <link href="http://blog.devtang.com/2016/02/27/swift-gym-1-nested-optional/"/>
    <id>http://blog.devtang.com/2016/02/27/swift-gym-1-nested-optional/</id>
    <published>2016-02-27T01:21:32.000Z</published>
    <updated>2016-02-27T01:33:21.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/swift-brain-gym-optional" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第一节，练习前请做好准备运动，保持头脑清醒。</p>
<h2 id="u51C6_u5907_u8FD0_u52A8_uFF1AOptional__u7684_u4ECB_u7ECD"><a href="#u51C6_u5907_u8FD0_u52A8_uFF1AOptional__u7684_u4ECB_u7ECD" class="headerlink" title="准备运动：Optional 的介绍"></a>准备运动：Optional 的介绍</h2><p><img src="http://ww3.sinaimg.cn/mw690/65dc76a3gw1f0sz13edhpj209s061mxt.jpg" alt=""></p>
<p>王巍的《Swifter》(<a href="http://swifter.tips/buy" target="_blank" rel="external">http://swifter.tips/buy</a>)一书中，介绍了一个有用的命令：在 LLDB 中输入 <code>fr v -R foo</code>，可以查看 <code>foo</code> 这个变量的内存构成。我们稍后的分析将用到这个命令。</p>
<p>在 Swift 的世界里，一切皆对象，包括 Int Float 这些基本数据类型，所以我们可以这么写：<code>print(1.description)</code>。</p>
<p>而对象一般都是存储在指针中，Swift 也不例外，这就造成了一个问题，指针为空的情况需要处理。在 Objective-C 中，向一个 nil 的对象发消息是默认不产生任何效果的行为，但是在 Swift 中，这种行为被严格地禁止了。</p>
<p>Swift 是一个强类型语言，它希望在编译期做更多的安全检查，所以引入了类型推断。而类型推断上如果要做到足够的安全，避免空指针调用是一个最基本的要求。于是，Optional 这种类型出现了。Optional 在 Swift 语言中其实是一个枚举类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Optional&#60;Wrapped&#62; : _Reflectable, NilLiteralConvertible &#123;&#10;    case None&#10;    case Some(Wrapped)&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Optional__u7684_u5D4C_u5957"><a href="#Optional__u7684_u5D4C_u5957" class="headerlink" title="Optional 的嵌套"></a>Optional 的嵌套</h2><p>Optional 类型的变量，在使用时，大多需要用<code>if let</code>的方式来解包。如果你没有解包而直接使用，编辑器通过类型推断会提示你，所以看起来这套机制工作得很好。但是，如果 Optional 嵌套层次太多，就会造成一些麻烦，下面我们来看一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a: Int? = 1&#10;let b: Int?? = a&#10;let c: Int??? = b</span><br></pre></td></tr></table></figure>
<p>在这个机制中，1 这个 Int 值被层层 Optional 包裹，我们用刚刚提到的<code>fr v -R</code>，可以很好的看出来内部结构。如下图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) fr v -R a&#10;(Swift.Optional&#60;Swift.Int&#62;) a = Some &#123;&#10;  Some = &#123;&#10;    value = 1&#10;  &#125;&#10;&#125;&#10;&#10;(lldb) fr v -R b&#10;(Swift.Optional&#60;Swift.Optional&#60;Swift.Int&#62;&#62;) b = Some &#123;&#10;  Some = Some &#123;&#10;    Some = &#123;&#10;      value = 1&#10;    &#125;&#10;  &#125;&#10;&#125;&#10;&#10;(lldb) fr v -R c&#10;(Swift.Optional&#60;Swift.Optional&#60;Swift.Optional&#60;Swift.Int&#62;&#62;&#62;) c = Some &#123;&#10;  Some = Some &#123;&#10;    Some = Some &#123;&#10;      Some = &#123;&#10;        value = 1&#10;      &#125;&#10;    &#125;&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>从这个示例代码中，我们能看出来多层嵌套的 Optional 的具体内存结构。这个内存结构其实是一个类似二叉树一样的形状，如下图所示：</p>
<p><img src="http://ww3.sinaimg.cn/mw690/65dc76a3gw1f08i00trqpj20ji0ch3ze.jpg" alt=""></p>
<ul>
<li>第一层二叉树有两个可选的值，一个值是 .None，另一个值类型是 <code>Optional&lt;Optional&lt;Int&gt;&gt;</code>。</li>
<li>第二层二叉树有两个可选的值，一个值是 .None，另一个值类型是 <code>Optional&lt;Int&gt;</code>。</li>
<li>第三层二叉树有两个可选的值，一个值是 .None，另一个值类型是 <code>Int</code>。</li>
</ul>
<p>那么问题来了，看起来这个 Optional.None 可以出现在每一层，那么在每一层的效果一样吗？我做了如下实验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a: Int? = nil&#10;let b: Int?? = a&#10;let c: Int??? = b&#10;let d: Int??? = nil</span><br></pre></td></tr></table></figure>
<p>如果你在 playground 上看，它们的值都是 nil，但是它们的内存布局却不一样，特别是变量 c 和 变量 d：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) fr v -R a&#10;(Swift.Optional&#60;Swift.Int&#62;) a = None &#123;&#10;  Some = &#123;&#10;    value = 0&#10;  &#125;&#10;&#125;&#10;&#10;(lldb) fr v -R b&#10;(Swift.Optional&#60;Swift.Optional&#60;Swift.Int&#62;&#62;) b = Some &#123;&#10;  Some = None &#123;&#10;    Some = &#123;&#10;      value = 0&#10;    &#125;&#10;  &#125;&#10;&#125;&#10;&#10;(lldb) fr v -R c&#10;(Swift.Optional&#60;Swift.Optional&#60;Swift.Optional&#60;Swift.Int&#62;&#62;&#62;) c = Some &#123;&#10;  Some = Some &#123;&#10;    Some = None &#123;&#10;      Some = &#123;&#10;        value = 0&#10;      &#125;&#10;    &#125;&#10;  &#125;&#10;&#125;&#10;&#10;(lldb) fr v -R d&#10;(Swift.Optional&#60;Swift.Optional&#60;Swift.Optional&#60;Swift.Int&#62;&#62;&#62;) d = None &#123;&#10;  Some = Some &#123;&#10;    Some = Some &#123;&#10;      Some = &#123;&#10;        value = 0&#10;      &#125;&#10;    &#125;&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>变量 c 因为是多层嵌套的 nil，所以它在最外层的二叉树上的值，是一个 <code>Optional&lt;Optional&lt;Int&gt;&gt;</code>。</li>
<li>变量 d 因为是直接赋值成 nil，所以它在最外层的二叉树上的值，是一个 <code>Optional.None</code>。</li>
</ul>
<p>麻烦的事情来了，以上原因会造成用 if let 来判断变量 c 是否为 nil 失效了。如下代码最终会输出 <code>c is not none</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a: Int? = nil&#10;let b: Int?? = a&#10;let c: Int??? = b&#10;let d: Int??? = nil&#10;&#10;if let _ = c &#123;&#10;    print(&#34;c is not none&#34;)&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u89E3_u91CA"><a href="#u89E3_u91CA" class="headerlink" title="解释"></a>解释</h2><p>在我看来，这个问题的根源是：一个 Optional 类型的变量可以接受一个非 Optional 的值。拿上面的代码举例，a 的类型是 Int?，b 的类型是 Int??，但是 a 的值却可以赋值给 b。所以，变量 b（类型为 Int??），它可以接受以下几种类型的赋值：</p>
<ol>
<li>nil 类型</li>
<li>Int? 类型</li>
<li>Int?? 类型</li>
</ol>
<p>按理说，Swift 是强类型，等号左右两边的类型不完全一样，为什么能够赋值成功呢？我查了一下 Optional 的源码，原来是对于上面第 1，2 种类型不一样的情况，Optional 定义了构造函数来构造出一个 Int?? 类型的值，这样构造之后，等号左右两边就一样了。源码来自 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift</a>，我摘录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Optional&#60;Wrapped&#62; : _Reflectable, NilLiteralConvertible &#123;&#10;  case None&#10;  case Some(Wrapped)&#10;&#10;  @available(*, unavailable, renamed=&#34;Wrapped&#34;)&#10;  public typealias T = Wrapped&#10;&#10;  /// Construct a `nil` instance.&#10;  @_transparent&#10;  public init() &#123; self = .None &#125;&#10;&#10;  /// Construct a non-`nil` instance that stores `some`.&#10;  @_transparent&#10;  public init(_ some: Wrapped) &#123; self = .Some(some) &#125;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中，Optional 提供了两种构造函数，完成了刚刚提到的类型转换工作。</p>
<h2 id="u70E7_u8111_u4F53_u64CD"><a href="#u70E7_u8111_u4F53_u64CD" class="headerlink" title="烧脑体操"></a>烧脑体操</h2><p>好了，说了这么多，我们下面开始烧脑了，以下代码来自傅若愚（<a href="https://github.com/lingoer" target="_blank" rel="external">https://github.com/lingoer</a>）在不久前 Swift 大会（<a href="http://atswift.io/#speaker" target="_blank" rel="external">http://atswift.io/#speaker</a>）上的一段分享：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dict :[String:String?] = [:]&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;func justReturnNil() -&#62; String? &#123;&#10;    return nil&#10;&#125;&#10;dict[&#34;key&#34;] = justReturnNil()&#10;dict</span><br></pre></td></tr></table></figure>
<p>以下是代码执行结果：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hcnaidnj20vq06ugni.jpg" alt=""></p>
<p>我们可以看到，我们想通过给这个 Dictionary 设置一个 nil，来删除掉这个 key-value 对。但是从 playground 的执行结果上看，key 并没有被删掉。</p>
<p>为了测试到底设置什么样的值，才能正常地删掉这个 key-value 键值对，我做了如下实验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dict :[String:String?] = [:]&#10;// first try&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;dict[&#34;key&#34;] = Optional&#60;Optional&#60;String&#62;&#62;.None&#10;dict&#10;&#10;// second try&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;dict[&#34;key&#34;] = Optional&#60;String&#62;.None&#10;dict&#10;&#10;// third try&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;dict[&#34;key&#34;] = nil&#10;dict&#10;&#10;// forth try&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;let nilValue:String? = nil&#10;dict[&#34;key&#34;] = nilValue&#10;dict&#10;&#10;// fifth try&#10;dict = [&#34;key&#34;: &#34;value&#34;]&#10;let nilValue2:String?? = nil&#10;dict[&#34;key&#34;] = nilValue2&#10;dict</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hcj57k0j20vk0lqjxf.jpg" alt=""></p>
<p>我们可以看到，以下三种方式可以成功删除 key-value 键值对：</p>
<ul>
<li><code>dict[&quot;key&quot;] = Optional&lt;Optional&lt;String&gt;&gt;.None</code></li>
<li><code>dict[&quot;key&quot;] = nil</code></li>
<li><code>let nilValue2:String?? = nil;  dict[&quot;key&quot;] = nilValue2</code></li>
</ul>
<p>所以，在这个烧脑之旅中，我们发现，一个 [String: String?] 的 Dictionary，可以接受以下类型的赋值：</p>
<ul>
<li>nil</li>
<li>String</li>
<li>String?</li>
<li>String??</li>
</ul>
<p>如果要删除这个 Dictionary 中的元素，必须传入 nil 或 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code> ，而如果传入 <code>Optional&lt;String&gt;.None</code>，则不能正常删除元素。</p>
<p>好吧，实验出现象了，那这种现象的原因是什么呢？</p>
<p>还好苹果把它的实现开源了，那我们来一起看看吧，源文件来自：<a href="https://github.com/apple/swift/blob/master/stdlib/public/core/HashedCollections.swift.gyb" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/HashedCollections.swift.gyb</a>，以下是关键代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public subscript(key: Key) -&#62; Value? &#123;&#10;  get &#123;&#10;    return _variantStorage.maybeGet(key)&#10;  &#125;&#10;  set(newValue) &#123;&#10;    if let x = newValue &#123;&#10;      // FIXME(performance): this loads and discards the old value.&#10;      _variantStorage.updateValue(x, forKey: key)&#10;    &#125;&#10;    else &#123;&#10;      // FIXME(performance): this loads and discards the old value.&#10;      removeValueForKey(key)&#10;    &#125;&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>所以，当 Dictionary 的 value 类型为 String 时，如果你要设置它的值，它接受的是一个 String? 类型的参数。而因为我们刚刚例子中的 value 类型为 String?，所以正常情况下它需要的是一个 String?? 类型的参数。在上面的失败的例子中，我们传递的是一个 String? 类型的值，具体值为 <code>Optional&lt;String&gt;.None</code>，于是在执行时就会按以下的步骤来进行：</p>
<ol>
<li>我们传递一个值为 <code>Optional&lt;String&gt;.None</code>，类型为 String? 的参数。</li>
<li>因为传的参数类型是 String?，而函数需要的是 String??，所以会执行 Optional 的构造函数，构造一个两层的 Optional。</li>
<li>这个两层 Optional 的值为 <code>Optional.Some(&lt;Optional&lt;String&gt;.None&gt;)</code></li>
<li>进入到 Dictionary 的实现时，会用 if let 进行是否为 nil 的判断，因为两层的 Optional，所以 if let 判断它不是 nil。</li>
<li>所以代码执行到 <code>_variantStorage.updateValue(x, forKey: key)</code>，把 Optional<string>.None 当成值，设置给了相应的 key。</string></li>
</ol>
<p>如果你没理解，可以再翻翻最初我们对多层嵌套 nil 变量的实验和分析。</p>
<p>我们再看看传递参数是 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code> 的情况，步骤如下：</p>
<ol>
<li>我们传递一个值为 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code>，类型为 String?? 的参数。</li>
<li>因为参数类型是 String??，函数需要的类型也是 String??，所以参数不经变换，直接进入函数调用中。</li>
<li>这个时候参数的值不变，还是 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code>。</li>
<li>进入到 Dictionary 的实现时，会用 if let 进行是否为 nil 的判断，<code>Optional&lt;Optional&lt;String&gt;&gt;.None</code> 用 if let 判断，得到它是 nil。</li>
<li>所以代码执行到 <code>removeValueForKey(key)</code>，Dictionary 删除了相应的 key-value 键值对。</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>好了，「烧脑体操」第一节就做完了，运动一下是不是感觉神清气爽？</p>
<p>总结一下本次烧脑锻炼到的脑细胞：</p>
<ul>
<li>Optional 可以多层嵌套。</li>
<li>因为 Optional 的构造函数支持，所以可以将一个类型为 T 的值，赋值给一个类型为 T? 的变量。</li>
<li>因为 Optional 的构造函数支持，所以可以将 nil 赋值给一个任意嵌套层数的 Optional 变量。</li>
<li>将 Optional 嵌套的内容是 nil 时，大家要小心 if let 操作失效问题。</li>
<li>多层 Optional 嵌套容易烧脑细胞，尽量避免在工程中使用或触发。</li>
<li>遇到问题可以翻翻苹果在 Github 开源的 <a href="https://github.com/apple/swift" target="_blank" rel="external">Swift 源码</a>。</li>
</ul>
<p>愿大家玩得开心！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从 Octopress 迁移到 Hexo]]></title>
    <link href="http://blog.devtang.com/2016/02/16/from-octopress-to-hexo/"/>
    <id>http://blog.devtang.com/2016/02/16/from-octopress-to-hexo/</id>
    <published>2016-02-16T11:05:46.000Z</published>
    <updated>2016-02-16T12:47:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5E8F_u8A00"><a href="#u5E8F_u8A00" class="headerlink" title="序言"></a>序言</h2><p>我的博客之前一直使用的是 <a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>，不过 Octopress 已经很久没有更新了。而且 Octopress 是基于 Ruby 的，生成博客文章的速度真的是非常非常慢，每次我使用 <code>rake preview</code> 命令时，我的 MacBook 的 CPU 就会狂转。最新的一次我试图在新 MBP 上搭建 Octopress 博客环境失败了，这让我打定主意更换掉它。</p>
<p>之后我调研了一下，最终决定迁移到 Hexo，主要的原因是：</p>
<ul>
<li>Hexo 的原理和 Octopress 一样，都是生成静态文件，这样可以方便地托管到 GitHub 和 GitCafe 上。</li>
<li>Hexo 是基于 Node 的，而 Node 的速度非常快。</li>
<li>Hexo 对 Octopress 的迁移很友好，图片引用方式完全一样，所以我的博客文章不需要做什么改动。</li>
</ul>
<p>迁移本来应该在春节前就做完的，不过我在选择 Hexo 的主题上犯难了，Hexo 自带的主题丑极了，而我试了将近 10 个主题，都不满意。最终，我发现了 <a href="http://swift.gg/" target="_blank" rel="external">SwiftGG</a> 使用的主题 <a href="https://github.com/wuchong/jacman" target="_blank" rel="external">Jacman</a>，于是决定就它了！</p>
<p>整个迁移过程大概如下：</p>
<h2 id="u5B89_u88C5_Hexo"><a href="#u5B89_u88C5_Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>首先使用如下命令安装 Hexo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h2 id="u521B_u5EFA_u4E00_u4E2A_u65B0_u7684_u535A_u5BA2"><a href="#u521B_u5EFA_u4E00_u4E2A_u65B0_u7684_u535A_u5BA2" class="headerlink" title="创建一个新的博客"></a>创建一个新的博客</h2><p>接着我们创建一个新的博客目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &#60;folder&#62;&#10;$ cd &#60;folder&#62;&#10;$ npm install</span><br></pre></td></tr></table></figure>
<p>以上命令完成后，会在目标目录生成以下的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; _config.yml&#10;&#9500;&#9472;&#9472; package.json&#10;&#9500;&#9472;&#9472; scaffolds&#10;&#9500;&#9472;&#9472; source&#10;|   &#9500;&#9472;&#9472; _drafts&#10;|   &#9492;&#9472;&#9472; _posts&#10;&#9492;&#9472;&#9472; themes</span><br></pre></td></tr></table></figure>
<p>相比 Octopress，Hexo 的目录结构更加简单：</p>
<ul>
<li>_config.yml 是博客的配置文件。</li>
<li>scaffolds 是博客文章模板。</li>
<li>source 是博客文章目录。</li>
<li>themes 存放主题风格文件。</li>
</ul>
<h2 id="u8FC1_u79FB_u548C_u914D_u7F6E"><a href="#u8FC1_u79FB_u548C_u914D_u7F6E" class="headerlink" title="迁移和配置"></a>迁移和配置</h2><p>迁移起来还是很方便，把以前 Octopress 的 <code>source/_post</code> 目录下的文章，拷贝到 Hexo 的同名目录下即可。</p>
<p>以前的图片目录，也可以直接拷贝到 <code>source/images</code> 目录下。</p>
<p>Google 统计相关的设置可以在 jacman 的 _config.yml 文件中配置。我以前用的评论系统太旧了，这次正好换成了<a href="http://tangqiaoboy.duoshuo.com/" target="_blank" rel="external">多说</a>，同样也是在 jacman 的配置文件中设置。</p>
<h2 id="u4FEE_u6539_u754C_u9762"><a href="#u4FEE_u6539_u754C_u9762" class="headerlink" title="修改界面"></a>修改界面</h2><p>选择 Hexo 的另一个原因就是它的结构很简单，比较方便我定制。我在迁移完博客文章后，对 jacman 主题进行了一些定制。删掉了底部的作者介绍，然后在右侧边栏加上了我的微信公众号介绍。如果你想看看我是如何定制的，可以直接查看我 Fork 出来的 jacman 项目上的 Commits 即可，项目地址在 <a href="https://github.com/tangqiaoboy/jacman" target="_blank" rel="external">这里</a>。</p>
<h2 id="u53D1_u5E03_u6587_u7AE0"><a href="#u53D1_u5E03_u6587_u7AE0" class="headerlink" title="发布文章"></a>发布文章</h2><p>Hexo 支持直接发布到 GitHub，不过我在配置好 <code>_config.yml</code> 文件后，执行 <code>Hexo deploy</code> 一直失败！Hexo 一直卡在生成页面过程中，没有任何报错，这使得我也不知道如何修复它。</p>
<p>最终，我自己写了一个小脚本来做发布工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! /bin/zsh&#10;&#10;hexo clean&#10;hexo generate&#10;cd public&#10;&#10;git init&#10;git add .&#10;git commit -m &#34;update at `date` &#34;&#10;&#10;git remote add origin git@github.com:tangqiaoboy/tangqiaoboy.github.com.git &#62;&#62; /dev/null 2&#62;&#38;1&#10;echo &#34;### Pushing to Github...&#34;&#10;git push origin master -f&#10;echo &#34;### Done&#34;&#10;&#10;git remote add gitcafe git@gitcafe.com:tangqiaoboy/tangqiaoboy.git &#62;&#62; /dev/null 2&#62;&#38;1&#10;echo &#34;### Pushing to GitCafe...&#34;&#10;git push gitcafe master:gitcafe-pages -f&#10;echo &#34;### Done&#34;</span><br></pre></td></tr></table></figure>
<p>如果你遇到了和我一样问题的话，把以上脚本稍做修改应该也能很好地工作。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>Octopress 已经过时，建议有时间的朋友都可以尝试替换掉它。Hexo 算不上完美，但还算是一个不错的替代方案。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5E8F_u8A00"><a href="#u5E8F_u8A00" class="headerlink" title="序言"></a>序言</h2><p>我的博客之前一直使用的是 <a href="http://octopress.org/" target=]]>
    </summary>
    
      <category term="blog" scheme="http://blog.devtang.com/tags/blog/"/>
    
      <category term="shell" scheme="http://blog.devtang.com/categories/shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人员、流程和产品上的思考 - 读《启示录》总结]]></title>
    <link href="http://blog.devtang.com/2016/02/16/inspired-summary/"/>
    <id>http://blog.devtang.com/2016/02/16/inspired-summary/</id>
    <published>2016-02-16T05:32:33.000Z</published>
    <updated>2016-02-16T10:32:21.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img12.360buyimg.com/n1/jfs/t640/134/203561693/178183/b1f2b244/54562358Nb9bef513.jpg" alt=""></p>
<p><a href="http://item.jd.com/10628082.html" target="_blank" rel="external">《启示录：打造用户喜爱的产品》</a> 出版于 2011 年，作为最早一批出版的关于产品经理图书，直到现在仍然非常畅销。它的作者是 eBay 前产品副总裁 Marty Cagan。</p>
<p>Marty Cagan 的这本书有点文集的感觉，从任何一章开始读，都不会感觉到突兀。很多文章最初应该是以博客的形式发表在 <a href="http://www.svpg.com/articles/" target="_blank" rel="external">http://www.svpg.com/articles/</a> 网站上的。整体上图书的文章分为三大部分：人员、流程和产品。以下是一些读书总结。</p>
<h2 id="u4EBA_u5458"><a href="#u4EBA_u5458" class="headerlink" title="人员"></a>人员</h2><p>图书的第一部分是「人员」，用了 10 个章节来阐述。前 5 章主要介绍互联网产品研发中的关键角色定义以及职责，后 5 个章节介绍了一些人员招聘和管理的心得。</p>
<p>Marty Cagan 认为互联网研发的角色包括：产品经理、用户体验设计师、项目管理人员、开发团队、运维团队、产品营销人员，并且他分别讲解了这些角色的职责和工作内容差别。</p>
<p>具体在执行上，其实有可能一人身兼多职，比如我们小猿搜题的产品经理同时需要负责做项目管理相关的推进和协调工作。也可能一个职位被拆分成多个细分的工作方向，比如用户体验设计师在网易公司就会拆分成负责交互效果和负责视觉效果的设计师。</p>
<p>书中我印象比较深刻的是对产品经理和项目经理的讨论。Marty Cagan 在书中是这么介绍的：</p>
<blockquote>
<p>产品经理产注的是定义有价值的产品。</p>
<p>项目经理关注如何执行计划以交付产品。</p>
</blockquote>
<p>书中提到了项目经理需要的能力包括：</p>
<ul>
<li>工作紧迫感</li>
<li>善于捕捉问题</li>
<li>思路清晰</li>
<li>用数据说话</li>
<li>果断</li>
<li>判断力</li>
<li>态度（不能找延期的借口）</li>
</ul>
<p>所以这里面涉及的技能差别巨大，那为什么我们在创业时选择让产品经理身兼项目管理工作呢？除了希望团队保持人员在数量上的敏捷之外，我们认为产品经理如果能够具备这样的能力，会使得他们能具有更有大局观。这个大局观说实际点，就是知道自己的产品方案在执行时会有多大具体的开发成本，在做妥协的时候，知道如何的产品调整会有助于开发团队更快地产出。</p>
<h2 id="u6D41_u7A0B"><a href="#u6D41_u7A0B" class="headerlink" title="流程"></a>流程</h2><p>这部分用了 20 个章节，介绍了做产品的各种流程和做事方法。</p>
<p>其中涉及的很多流程，已经被广泛接受，并成为事实上的标准做法。比如基于 Scrum 的敏捷软件开发方法，虽然有一些公司不完全采用 Scrum，但是其中的看板、站立会议等实践仍然被借鉴融入到了日常工作流程中。</p>
<p>作者推荐产品经理用「高保真」原型来代替产品文档。对于「高保真」原型，作者还在网站上提供了详细的示例：<a href="http://www.svpg.com/examples" target="_blank" rel="external">http://www.svpg.com/examples</a>，我看了之后感觉还是比较惊讶，因为这个 <a href="http://www.svpg.com/assets/Files/Prototype.zip" target="_blank" rel="external">原型</a> 的「高保真」程度已经到了让人看不出来是原型的程度。</p>
<p>就我了解到的大多数公司，都还是用 Axure 或 Omni Graffle 来制作产品文档，其远远谈不上「高保真」，我对所有产品都应该用「高保真」原型来制作存疑。</p>
<h2 id="u4EA7_u54C1"><a href="#u4EA7_u54C1" class="headerlink" title="产品"></a>产品</h2><p>这部分用了 9 个章节，介绍了一些做产品的心得。例如：</p>
<p>第 32 章让我们提防做一些小众需求的功能，主要是给那些做企业级应用的公司的建议。</p>
<p>第 34 章介绍了产品背后涉及的人性：贪婪、恐惧、欲望。这里面的道理谁都懂，不过要真正应用到产品中，还需要长久的思考。之前听一个朋友说，不管是德州扑克，还是炒股，都是一个「克服贪婪与恐惧的游戏」。道理谁都懂，但是能玩好德州扑克和炒股挣钱的人并不多。</p>
<p>第 35 章介绍的情感接纳曲线也是涉及人性的话题，他指出很多人的决策都是为了宣泄情绪，关注并利用到这一点之后，就可以做出广受欢迎的产品。书中举的是关于非理性消费的例子，比如环保主义者就会花很多钱买普锐斯（丰田公司的混合动力汽车），但是其实他们更多的是为情绪买单。作者认为非理性消费本质是对不满情绪的过度反应，是放大后的情感需求在作怪。</p>
<p>对于如何寻找这种需求，作者提出可以把自己想像成一个新生的人，一切东西都是新鲜的，然后感受产品对自己内心的细微影响。这种目标用户的代入感或许是一个产品经理的必修课程吧。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>图书最后用两章进行了一个总结，包括整理出一个「最佳实践经验」和「产品经理的反省清单」。我对此体会并不深，但是考虑到可能自己还没悟到，所以先摘录如下：</p>
<p>「最佳实践经验」有十条：</p>
<ul>
<li>1、产品管理的职责</li>
<li>2、用户体验</li>
<li>3、机会评估</li>
<li>4、特约客户</li>
<li>5、产品原则</li>
<li>6、人物角色</li>
<li>7、探索（定义）产品</li>
<li>8、使用原型</li>
<li>9、用户参与原型测试</li>
<li>10、根据数据进行改进</li>
</ul>
<p>「产品经理的反省清单」也有十条：</p>
<ul>
<li>1、产品能吸引目标消费用户的关注吗？</li>
<li>2、设计是否人性化，好操作？</li>
<li>3、能赢得过竞品么？</li>
<li>4、了解目标用户吗？</li>
<li>5、是否有别于其他的产品呢？</li>
<li>6、产品能正常运行么？</li>
<li>7、是否完整，销售是否能够完成。</li>
<li>9、特色是否与目标用户一致。</li>
<li>10、产品值钱吗？值多少钱？</li>
<li>11、了解团队其他成员的想法吗？</li>
</ul>
<p>作为最早一批出现的介绍产品经理工作的书籍，《启示录》非常适合入门，特别是适合有一些具体产品工作实践的同学阅读。本书不太好的地方就是内容组织的条理性太差，并且涉及的内容通常并没有很深入展开。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img12.360buyimg.com/n1/jfs/t640/134/203561693/178183/b1f2b244/54562358Nb9bef513.jpg" alt=""></p>
<p><a href="http://item]]>
    </summary>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过他人完成任务的艺术 - 读《领导梯队》]]></title>
    <link href="http://blog.devtang.com/2016/02/16/the-leadership-pipeline-summary/"/>
    <id>http://blog.devtang.com/2016/02/16/the-leadership-pipeline-summary/</id>
    <published>2016-02-16T05:24:31.000Z</published>
    <updated>2016-02-16T10:26:44.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img11.360buyimg.com/n1/jfs/t991/39/1365739528/216597/92223aa5/559a1e10N51068ad5.jpg" alt=""></p>
<p><a href="http://item.jd.com/10708646.html" target="_blank" rel="external">《领导梯队》</a> 是美团的 <a href="http://baike.baidu.com/item/%E9%99%88%E6%99%93%E4%BA%AE/17510291" target="_blank" rel="external">陈晓亮</a> 同学推荐给我的，看完了一段时间，但是一直没有整理读书笔记，这次趁着春节回顾了一下本书。</p>
<p>领导力就是通过他人去完成任务的学问。本书通过对六个典型的管理层级最经常出现的问题，从领导技能、时间管理能力、工作理念三个方面进行了分析，提出了改进建议。</p>
<p>本书对管理层级的划分非常宏大，看起来像是给一个上万人集团公司写的一样，书中甚至有一章是教你如何做 CEO，这可能与本书的作者拉姆·查兰长期从事管理方面的教学工作有关。而我因为刚刚从一个开发人员转型做管理工作，所以我主要阅读的图书的前两章，里面涉及了如何「从管理自我到管理他人」。</p>
<p>对于每一个领导阶段，书中都从如下三个方面进行了工作指导：</p>
<ol>
<li>领导技能：培养胜任新职务所需要的新能力，提升领导力。</li>
<li>时间管理：重新配置时间精力资源，决定如何高效工作。</li>
<li>工作理念：更新工作理念和价值观，让工作聚焦重点。</li>
</ol>
<p>而这三个方面，也是我常常困惑的地方。我常常问自己：</p>
<ol>
<li>作为一个技术转管理的人，我应该如何学习和提高？</li>
<li>我应该如何安排自己的日常工作时间？</li>
<li>有什么核心的方法论来指导自己？</li>
</ol>
<p>而这些问题，我试图从本书中得到答案，有一些找到了，也有一些没找到。</p>
<h2 id="u4ECE_u7BA1_u7406_u81EA_u6211_u5230_u7BA1_u7406_u4ED6_u4EBA"><a href="#u4ECE_u7BA1_u7406_u81EA_u6211_u5230_u7BA1_u7406_u4ED6_u4EBA" class="headerlink" title="从管理自我到管理他人"></a>从管理自我到管理他人</h2><p>我们大部分初入职场的人刚开始都是个人贡献者，随着能力的提高，有一些人在自己专业领域上做出了出色的成绩。而公司往往会给这些人增加更多的职责，这些职责很多时候都是涉及沟通、组织和管理的。所以，这些优秀的个人贡献者，开始迎接他们的第一次转型挑战，尝试学会从管理自我到管理他人。</p>
<p>书中也提到，优秀的个人贡献者和优秀的管理人员所需要的技能树并不一样。所以并不是每一个人都是能够完成这一转变。而就我所在的互联网行业来看，很多时候，优秀的个人贡献者也不一定需要做这个转变，也能在技术领域一路提升，成为技术专家。</p>
<p>例如阿里的 <a href="http://baike.baidu.com/view/15099717.htm" target="_blank" rel="external">多隆</a>，就是一位一直坚持在技术领域的专家，他做到了阿里的合伙人。我也见到一些朋友坚持在一线做技术，其薪资待遇高于那些做管理的人。所以这个职位转变更多需要是内心的喜欢和坚持。如果转型失败，后果很可能是自废武功—-既弱化了专业的职业技能，又是一个失败的管理者。</p>
<p>我们先来看看书中指出管理他人的技能树吧：</p>
<h3 id="u9886_u5BFC_u6280_u80FD"><a href="#u9886_u5BFC_u6280_u80FD" class="headerlink" title="领导技能"></a>领导技能</h3><p>书中指出管理他人首先需要的技能是「领导技能」，具体包括：</p>
<ul>
<li>制定计划（项目计划，预算计划和人员计划）</li>
<li>工作设计</li>
<li>人员选拔（其实就是招聘）</li>
<li>授权（工作安排）</li>
<li>绩效监督</li>
<li>教练辅导与反馈</li>
<li>绩效评估</li>
<li>奖励与激励</li>
<li>沟通与营造工作氛围</li>
<li>为部门发展建立上下左右的良好关系</li>
<li>获取资源</li>
</ul>
<p>与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下：</p>
<ul>
<li>技术或者业务能力</li>
<li>团队协作能力</li>
<li>为了个人利益和个人成员建立的人际关系</li>
<li>合理运用公司的工具、流程和规则</li>
</ul>
<p>书中将以上内容分为了三类：界定和布置工作、提高下属的胜任能力、建立人际关系。我觉得分得并不清晰，我按个人理解，用工作方式再次进行了分类：</p>
<ul>
<li>自己思考的工作：制定计划、工作设计、绩效评估</li>
<li>与人沟通的工作：授权、教练辅导与反馈、营造工作氛围、获取资源、奖励与激励</li>
<li>自己执行的工作：人员选拔、绩效监督</li>
</ul>
<p>所以我觉得一个好的一线管理人员，应该有思考和规划的能力、沟通能力、以及执行力。执行力在个人贡献者阶段其实也有锻炼，所以主要需要学习的是思考和规划的能力、沟通能力。</p>
<p>沟通能力似乎和演讲一样，就是一个多练习才能提高的技能。我平时会注意观察和总结自己的言语表达方式，以及观察别人的沟通方式，能感受到自己在一点点进步。</p>
<p>思考和规划的能力似乎也是一个需要花时间来积累的事情。好在很多时候规划并不是我来做的，所以我对此承担的压力并不大。</p>
<h3 id="u65F6_u95F4_u7BA1_u7406"><a href="#u65F6_u95F4_u7BA1_u7406" class="headerlink" title="时间管理"></a>时间管理</h3><p>时间管理方面的技能，具体包括：</p>
<ul>
<li>年度时间计划（时间安排、项目进度）</li>
<li>与下属沟通的专门时间（一是自己的需要，二是下属的需要）</li>
<li>为部门和团队工作设定时间方面的优先次序</li>
<li>与其他部门、客户和供应商沟通的时间</li>
</ul>
<p>与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下：</p>
<ul>
<li>遵守工作上下班时间</li>
<li>遵守工作的进度安排</li>
</ul>
<p>其实简单来说，以前是别人给自己安排工作，现在需要自己给自己安排工作了。每天的时间怎么分配，花在哪些事情上，一线经理需要开始思考了。</p>
<p>我当前主要的工作内容包括参与产品讨论，参与技术讨论，跟进项目上线，与运营同事沟通，与我的领导沟通，与主要具体负责人定期沟通。除此之外，还有团队的工作安排，一些面试工作。</p>
<p>我以前会主动承担一些开发任务，但是我发现这其实是不太合适的，因为我的时间沟通工作比较多，所以开发工作时间很多时候并不能保证进度。我以前也会过多地参与到项目进度推进中，现在发现也是不太合适的，这方面的工作我更多交给了相应的产品经理来完成。</p>
<p>但是，我对自己的时间安排也不尽满意。主要是我不太清楚我应该如何安排每天事情的优先级，以及当某一天没有固定安排的时候，我应该做什么事情。我有一些例行的事情可选，但是并没有安排好，例如：</p>
<ul>
<li>Check 一下和团队的人哪些人很久没有一对一沟通过，如果没有的话做一次。</li>
<li>关注 Pipe 上产品的各项指标，看是否有异常的、未被发现的数据。</li>
<li>关注用户反馈，看看用户都在说什么。</li>
<li>在 QQ 上找一些用户聊聊天。</li>
<li>关注自己的产品细节，反复使用。</li>
<li>关注竞争对手的功能改进。</li>
<li>看用户的原始数据（Frog，上传的图片）。</li>
<li>思考人员、流程和产品，各自有没有什么问题。</li>
</ul>
<p>这些问题在本书中没有涉及，我通过和我的领导郭常圳沟通，最终确定的结论是：我们把工作分为「被动工作时间」和「主动工作时间」。</p>
<ul>
<li>被动工作时间包括：定期的产品过稿、美术过稿、Scrum会议、邮件、在QQ上或当面主动来找我的事情。</li>
<li>主动工作时间包括：刚刚提到的看产品数据、看用户反馈，看原始数据等事情。</li>
</ul>
<p>郭常圳认为，我们应该把主动工作时间「例行化」，「例行化」是指每天抽出固定的时间来做这些事情，这样使得这些事情不被遗漏和忽视。在例行化的事情之外，我需要更多的留出「主动思考」时间，「主动思考」是最重要，并且是将这些输入转化成想法或决策的关键过程。</p>
<p>所以，我刚刚提到的那些事情，都应该变成每天例行做的事情。</p>
<h3 id="u5DE5_u4F5C_u7406_u5FF5"><a href="#u5DE5_u4F5C_u7406_u5FF5" class="headerlink" title="工作理念"></a>工作理念</h3><p>书中提到的工作理念的技能，具体包括：</p>
<ul>
<li>通过他人完成任务</li>
<li>下属员工的成功（就是自己的成功）</li>
<li>管理性工作和修养</li>
<li>部门的成功（就是自己的成功）</li>
<li>像一位真正的管理者</li>
<li>正直诚实</li>
</ul>
<p>与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下：</p>
<ul>
<li>通过个人能力完成任务</li>
<li>高质量的技术或专业化工作</li>
<li>遵循公司的价值观</li>
</ul>
<p>这一部分涉及成就感的转变，以前个人贡献者的成就感来源于自己的努力和成长。现在一线管理人员的成就感变成了下属的成功和团队的成功。不但如此，一线管理人员还需要在各方面对下属进行辅导，帮助他们工作得更舒服，更开心。</p>
<p>另外，我对正直诚实这条也感触很深。公司大了之后，很多文化就是来自于创始人以及一些核心员工。如果管理人员不能做到正直诚实，那么公司很可能变得充满了「政治斗争」，一但工作变成了维护自己利益以及小集团的利益，那么对公司的伤害是巨大的。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>本书的内容组织稍显混乱，虽然把领导技术、时间管理、工作理念作为每个阶段层级的主要改变内容，但是在具体阐述时，又会以另外一个角度展开。比如「 从管理自我到管理他人」一章的内容展开时，是按界定和布置工作、提高下属的胜任能力、建立人际关系作为内容小节阐述。而「从管理他人到管理经理人员」一章的内容，又是按「四个领导技能」展开。</p>
<p>本书很多章节总结性的内容散乱，最终以 QA 或故事的方式，列出一系列问题和回答来作为主要的章节内容，虽然很多内容读起来很有道理，但是使读者很难抽取出核心观点，也可能作者本身也没能总结出核心观点。</p>
<p>本书对于我的帮助是，我从中得到了不少指导性的规则，也帮助我梳理了自己的工作内容。虽然它没有解决我的所有问题，但是至少帮助我完成了对问题列表的整理和思考。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img11.360buyimg.com/n1/jfs/t991/39/1365739528/216597/92223aa5/559a1e10N51068ad5.jpg" alt=""></p>
<p><a href="http://item]]>
    </summary>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[和时间做朋友 - 读《奇特的一生》]]></title>
    <link href="http://blog.devtang.com/2016/02/16/make-friend-with-time/"/>
    <id>http://blog.devtang.com/2016/02/16/make-friend-with-time/</id>
    <published>2016-02-16T05:04:28.000Z</published>
    <updated>2016-02-18T13:14:02.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://camo.githubusercontent.com/9b0ba22b20c8464aefd022486269d4f3c8f3a5b8/687474703a2f2f696d6731302e333630627579696d672e636f6d2f6e312f6731352f4d30372f31312f30312f7242456857564a6e4a6167494141414141416e4f6362317365314141414564665141734b3934414363364a3231332e6a7067" alt=""></p>
<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>一切都不是我们的，而是别人的，只有时间是我们自己的财产。造物主交给我们，归我们所有的，只有这个不断流逝的、不稳定的东西。就连这个东西，谁只要愿意，都可以把它从我们手里剥夺走。</p>
<p>—— 古罗马哲学家：赛纳卡</p>
</blockquote>
<p>今天要介绍的是 <a href="http://item.jd.com/11331635.html" target="_blank" rel="external">《奇特的一生》</a> 这是一本关于时间的书，春节期间看到池建强在微信读书中推荐，于是就一口气读完了。该书讲述苏联科学家柳比歇夫将自己的一生用时间来计划，通过分析柳比歇夫「时间统计法」，作者认为这是让他生活得更好的秘密。</p>
<p>以下是我的读书感受。</p>
<a id="more"></a>
<h2 id="u548C_u65F6_u95F4_u505A_u670B_u53CB"><a href="#u548C_u65F6_u95F4_u505A_u670B_u53CB" class="headerlink" title="和时间做朋友"></a>和时间做朋友</h2><p>今年罗振宇的新年跨年演讲主题叫：「时间的朋友 2015」，听着名字就很酷，而李笑来老师的《把时间当做朋友》也是我非常喜欢的一本书。看吧，大家都喜欢谈时间。时间，是这个世界上人人都有的东西，但却又是最昂贵的东西。</p>
<p>为了节约时间，我们发明了汽车、火车、飞机代替了马车。我们发明了电活代替了电信。我们发明了电梯代替了楼梯。我们每天使用的微信，也代替了以前的短信。一切的发明，都为我们省下了大量时间，但是奇怪的是，我们越来越感到时间不够用。</p>
<p>你有这样的感受吗？晚上在电脑或手机面前看电影或者是刷微博，稍微不留神，就到了零晨 12 点了。但是我还记得小时候，家里偶尔会停电，那个时候点一盏蜡烛，大家围在蜡烛前面聊天，感觉聊了好久好久，来电后一看，才过了不到半个小时。</p>
<p>时间就是这样一个顽皮的小孩，当你认真看他的时候，他会像蜗牛一样慢慢地一秒一秒往前爬；当你忘记他的时候，他就会飞奔起来，等你发现的时候，你才发现人生在世，几十个年头也就一眨眼的功夫。</p>
<p>当今世界被移动互联网颠覆着，但时间的分配几乎同两千年以前的时代一模一样：「我们一生的时间，大部分用于错误及种种恶行；很大一部分虚抛浪掷，无所事事。我们整个一生，几乎都没有用来干应当干的事。」</p>
<p>今年我三十二岁了，有些时候会感觉很恐怖，搞互联网这个行业，有些时候晚上难免加班，熬夜之后身体明显会很不舒服，要过好几天才能缓过来，而以前大学在学校宿舍，打 Dota（一种多人联机对战游戏）玩到零晨 2，3 点也不觉得困。我希望我的「奔四」的这些年头，能够更有效，更有价值地度过。</p>
<p>所以，我们需要和时间做朋友，因为我们不希望一辈子就像眨眼一样就过去，而我们完全不记得曾经在这个世界上留下过什么。</p>
<h2 id="u65F6_u95F4_u7EDF_u8BA1_u6CD5"><a href="#u65F6_u95F4_u7EDF_u8BA1_u6CD5" class="headerlink" title="时间统计法"></a>时间统计法</h2><p><a href="http://item.jd.com/11331635.html" target="_blank" rel="external">《奇特的一生》</a> 在介绍了柳比歇夫的大量评价和成就之后，在第七章介绍了「时间统计法」。「时间统计法」实在太简单了，其实就是每做一件事情，记录下它花费的时间。然后，每周、每月、每年汇总和分类，看自己的时间是如何用掉的。</p>
<p>在时间统计法之上，本书也提出了一些注意细节，我总结如下。</p>
<h3 id="u5E94_u8BE5_u7EDF_u8BA1_u7EAF_u65F6_u95F4"><a href="#u5E94_u8BE5_u7EDF_u8BA1_u7EAF_u65F6_u95F4" class="headerlink" title="应该统计纯时间"></a>应该统计纯时间</h3><p>本书强调时间统计法应该计算纯时间：</p>
<blockquote>
<p>“工作中的任何间歇，我都要刨除。我计算的是纯时间，” 柳比歇夫写道，“纯时间要比毛时间少得多。所谓毛时间，就是你花在这项工作上的时间。”</p>
<p>常常有人说，他们一天工作十四五个小时。这样的人可能是有的。可是拿纯时间来说，我一天干不了那么多。我做学术工作的时间，最高纪录是 11 小时 30 分。</p>
<p>有七八个小时的纯工作时间，我就心满意足了。我最高纪录的一个月是 1937 年 7 月，我一个月工作了 316 小时，每日平均纯工作时间是 7 小时。如果把纯时间折算成毛时间，应该增加 25% 到 30%。我逐渐改进我的统计，最后形成了我现在使用的方法。</p>
</blockquote>
<h3 id="u5B66_u4F1A_u5229_u7528_u788E_u7247_u65F6_u95F4"><a href="#u5B66_u4F1A_u5229_u7528_u788E_u7247_u65F6_u95F4" class="headerlink" title="学会利用碎片时间"></a>学会利用碎片时间</h3><p>书中把碎片时间称作「时间下脚料」：</p>
<blockquote>
<p>他只是想方设法利用每一分钟，利用任何所谓的 “时间下脚料”：乘电车、坐火车、开会、排队……<br>还是在克里米亚，他已经注意到边走路边打毛衣的希腊女人。<br>每一次散步，他都用来捕捉昆虫。在那些废话连篇的会议上，他演算习题。</p>
</blockquote>
<h3 id="u5B66_u4F1A_u96C6_u4E2D_u6CE8_u610F_u529B"><a href="#u5B66_u4F1A_u96C6_u4E2D_u6CE8_u610F_u529B" class="headerlink" title="学会集中注意力"></a>学会集中注意力</h3><blockquote>
<p>应当学会不受周围环境的干扰，用在工作上的 3 个小时应当是真正做工作的 3 个小时，不想不相干的事，不听同事的谈话，不听铃声和笑声，也不听收音机……</p>
</blockquote>
<p>在这方面，我推荐大家使用番茄工作法，非常有效。</p>
<h3 id="u5B66_u4F1A_u603B_u7ED3"><a href="#u5B66_u4F1A_u603B_u7ED3" class="headerlink" title="学会总结"></a>学会总结</h3><p>任何的学习活动，都应该最终有总结，这样的学习才是真正的有价值的学习。我面试 iOS 开发的时候，喜欢问他们最近看了什么书，让他们讲一个最近看的「印象最深刻」的知识。大多数人都能回答出书名，但是想不起来书中讲了什么。</p>
<p>如果你看了一本书，但最终全部忘掉了，那就相当于没看。哦不对，应该更糟糕，因为你不但什么都没记住，还浪费了时间。</p>
<blockquote>
<p>柳比歇夫有种罕见的才能——随便哪本书的作者，凡有独特的见解，他都极善于汲取。有的书，一张纸就够；某些大部头书，需要几张纸来归纳。它们的精华同它们的厚度怎么也不相称：大量的插图、表格、附页、书皮。</p>
</blockquote>
<h3 id="u4E0D_u8981_u8BF4_u6CA1_u6709_u65F6_u95F4"><a href="#u4E0D_u8981_u8BF4_u6CA1_u6709_u65F6_u95F4" class="headerlink" title="不要说没有时间"></a>不要说没有时间</h3><p>人们常说，太忙了，没有时间做某某事。其实这是一个借口。如果你自己尝试做一下时间统计的话，你就会发现时间大把大把的有，只需要你有执行力。</p>
<p>而且，大部分情况下，稀缺的资源才会被珍惜。如果让你把工作辞掉，把时间留出来专门做一件事，你反倒很可能做不好。</p>
<p>书中是这么说的：</p>
<blockquote>
<p>我想以我的一个朋友来作为反面的例子。他曾经是一个很不错的科学家，后来又担任过一个很大的研究所的所长。马上我又想起我熟悉的一个作家类似的遭遇，随即又联想起另一个作家。职务确实剥夺了他们很多的时间，而且妨碍他们开展工作。但久而久之他们就习惯了这些客观情况的制约。<br>他们都幻想能摆脱，并经常说，到了那个时候，他们就要大干自己心爱的工作了，因为陷于各种繁杂应酬活动是很难写出书来，更不可能从事科学研究。<br>他们终于摆脱出来了。每个人都盼到了这么一天。但很快发现，他们谁也不能工作了。</p>
</blockquote>
<h2 id="u6211_u4EEC_u662F_u673A_u5668_u4EBA_u5417"><a href="#u6211_u4EEC_u662F_u673A_u5668_u4EBA_u5417" class="headerlink" title="我们是机器人吗"></a>我们是机器人吗</h2><p>书中的柳比歇夫严格记录了几十年自己的时间花费，让人看起来像机器人一样。我们是机器吗？我们为什么要把自己的生活弄得像机器一样严格而呆板？</p>
<p>对此，我的体会是，人生很多时候，需要我们把自己当做机器一样，执行自己预先的规划。比如对于我个人来说，坚持写微信公众号文章这件事情，到底有多大的意义？我不知道，但是我知道放弃一件事情非常容易，但坚持做一件事情，很可能会收获巨大。所以，这个名为「iOS 开发」的公众号我一写就是三年。有些时候不知道写些什么 iOS 开发的东西，我就写读书笔记，创业感悟。</p>
<p>现在我从技术转管理了，在时间计划上，我的领导常圳建议我把主动工作时间「例行化」。「例行化」是指每天抽出固定的时间来做固定事情，这些固定的事情包括：看产品数据、看用户反馈，看原始数据等，你觉得这些事情会有趣吗？其实不怎么有趣，但是这些事情对我的工作有很大的帮助，所以在这些事情上，我需要把自己变成「机器人」，不带有任何情绪地、认真地把它做好。</p>
<p>对于写书也是一样，我在写《iOS 开发进阶》的时候，刚开始兴奋，周末可以写一整天，然后就慢慢变得烦躁而疲倦了。我可以找相当多的借口放弃：创业太累、时间不够、稿费太少 …… 但是，我还是把自己当机器人一样，按照之前计划的章节安排，一章一章写。</p>
<p>我们不是机器人，但是我们内心足够强大，才能使得自己像机器人一样。</p>
<p>这其实也代表着心智的成熟。</p>
<h2 id="u4E00_u4E07_u5C0F_u65F6_u5B9A_u7406"><a href="#u4E00_u4E07_u5C0F_u65F6_u5B9A_u7406" class="headerlink" title="一万小时定理"></a>一万小时定理</h2><p>《异类》一书中揭示了成功的秘密：大量不管天赋多么高的人，都是经过 10000 小时的训练，才成为专家的。不管是钢琴家（书中以 6 岁就开始作曲的莫扎特为例），还是程序员（书中以 Java 语言的作者乔伊和微软的创始人比尔盖茨为例），他们都是由于环境的优势，早早地完成了 10000 小时训练，才成为人们眼中的天才的。</p>
<p>而本书 <a href="http://item.jd.com/11331635.html" target="_blank" rel="external">《奇特的一生》</a> 中介绍的时间统计法，其实就是一种实际可操作的「一万小时定理实践手册」。</p>
<p>通过对未来五年的规划，然后定出每年的年度目标，然后进一步进行拆解成月度目标，再结合时间统计法来计划每天的工作，并且检查自己工作完成情况，我们就会惊喜地发现，按这个进度我们很可能达成目标。</p>
<p>当然，<a href="http://item.jd.com/11331635.html" target="_blank" rel="external">《奇特的一生》</a> 中讲了另外一种情况：主人公柳比歇夫通过时间统计法，最终发现自己在 72 岁设立的写作目标并不实际，所以他最终调整了写作的内容，放弃了一部分章节，使得书稿能够最终完成。但这何尝不是一种合理的调整，他避免了柳比歇夫临死前才发现时间不够，后悔莫及的情况。</p>
<h2 id="Scrum__u7684_u8BA1_u5212_u548C_u56DE_u987E"><a href="#Scrum__u7684_u8BA1_u5212_u548C_u56DE_u987E" class="headerlink" title="Scrum 的计划和回顾"></a>Scrum 的计划和回顾</h2><p>看完了时间统计法，突然发现这个方法其实和 Scrum 有着非常惊人的相似度：</p>
<ul>
<li>制定长远目标，对应 Scrum 的 Milestone 的概念。</li>
<li>制定年度、月度目标，对应 Scrum 的每一个 Sprint。</li>
<li>每天的工作计划和时间统计，对应 Scrum 的每日站会。</li>
<li>定期的时间统计总结，对应 Scrum 的燃尽图和回顾会议。</li>
<li>短期和长期目标的达成，对应 Scrum 的评审会议。</li>
</ul>
<p>时间统计法以及它的一些指导思想，其实就类似一个人生的 Scrum 规则。</p>
<p>Scrum 强调组织的透明、检验和适应。时间统计法强调对自己的透明、检验和适应：</p>
<ul>
<li>对自己的透明，是指用时间统计法，了解自己的时间花费到底在哪里。</li>
<li>对自己检验，是指看自己长远目标的完成进度是否理想。</li>
<li>对自己的适应，是指定期总结自己的时间花费，看是否有改进的空间。</li>
</ul>
<h2 id="u7C7B_u7684_u81EA_u7701_u4E0E_u4EBA_u7684_u81EA_u6211_u56DE_u987E"><a href="#u7C7B_u7684_u81EA_u7701_u4E0E_u4EBA_u7684_u81EA_u6211_u56DE_u987E" class="headerlink" title="类的自省与人的自我回顾"></a>类的自省与人的自我回顾</h2><p>现代的高级语言，类和对象都会有「自省」的能力。自省是说，这个对象在运行时，能够了解自己。比如 Java 语言，可以通过反射，了解自己的类名、成员变量和成员函数。C++ 语言可以通过 RTTI 达到同样的效果。而我们熟悉的 Objective-C 的 Runtime 也非常强大，不但可以了解自己，还可以动态修改类的成员函数实现。</p>
<p>我之所以认为 Swift 语言还不完善，也是因为 Swift 语言在这方面的能力还比较弱，我感觉苹果在未来的版本中一定会增加这方面的特性。</p>
<p>「自省」的能力代表着一系列高级的编程技巧，Java 可以通过反射做到 IOC（反转控制），Objective-C 可以做到动态打补丁。而人呢，如果能够做到自我的回顾、总结和调整，那么也就能不断进步了。</p>
<p><a href="http://item.jd.com/11331635.html" target="_blank" rel="external">《奇特的一生》</a> 中的时间统计法是一种特别简单可操作的方法，使你具备「自省」的能力。</p>
<h2 id="u4E0D_u8981_u5D07_u62DC_u5929_u624D"><a href="#u4E0D_u8981_u5D07_u62DC_u5929_u624D" class="headerlink" title="不要崇拜天才"></a>不要崇拜天才</h2><p>作者在书中这么说：「我之所以对柳比歇夫产生兴趣，正由于他不是天才，因为天才是无法分析的，好在天才也不用去研究。天才只适合于让大家来赞美。」</p>
<p>这个世界基本上没有天才，我们也不需要崇拜天才，大部分成功的人都和你我一样，学习那些优秀的人做得好的地方，努力让自己提高一些。不要和天才比，要和自己比，这种价值观是我喜欢并坚持的。</p>
<h2 id="u76EE_u6807_u4E4B_u5916_uFF1A_u4E0D_u8981_u6210_u4E3A_u300C_u65F6_u95F4_u7684_u5974_u96B6_u300D"><a href="#u76EE_u6807_u4E4B_u5916_uFF1A_u4E0D_u8981_u6210_u4E3A_u300C_u65F6_u95F4_u7684_u5974_u96B6_u300D" class="headerlink" title="目标之外：不要成为「时间的奴隶」"></a>目标之外：不要成为「时间的奴隶」</h2><p>很难有一种理论体系能够解释所有现象，牛顿的物理学三大定理那么牛逼，也只能在宏观世界中适用。时间统计法也是一样，我们不能指望它解决我们所有的问题。</p>
<p>更进一步地，我们不能让我们成为「时间的奴隶」。这个世界并不是所有事情都能用时间来衡量价值，所以我们不能只关注长远目标，忘记了留意身边那些美好的瞬间。</p>
<p>所以，任何事情都有一个度，在你还没有学会好好利用时间的时候，你应该尝试用时间统计法来改进自己的时间规划；当你已经有很好的时间规划的时候，或许留一些随意时间，反倒是好的。</p>
<p>本书的主人公柳比歇夫就是这样一个人，他虽然是一个坚持做了几十年时间统计法的「强迫症患者」，但是他同样会花大量的时间回复书信，很多书信仅仅是向他求教一些专业知识。他从长远规划中安排出了这些时间，来帮助那些素不相识的朋友，这让我感受到了他的可爱。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这是一本非常有意思的书，讲了一个看起来细毫没有技术含量的生活方式：时间统计。但是，它让主人公柳比歇夫获得了人生的快乐和成就，希望我们大家都能够找到这样的快乐和成就。</p>
<p>愿大家猴年大吉！</p>
<!--

全书的章节构成是：

 * 第一章：算是引言，介绍为什么要写本书。
 * 第二章：别人对柳比歇夫的评价。
 * 第三章：介绍柳比歇夫的一生成就。
 * 第四章：介绍柳比歇夫时间帐本，引出将要介绍的时间统计法。
 * 第五章：讨论做时间统计的意义。
 * 第六章：长远目标是时间统计价值的基础。
 * 第七章：如何做时间统计（本书实际可操作的部分）。
 * 第八章：再次介绍了做时间统计意义。
 * 第九章：柳比歇夫的收获。
 * 第十章：柳比歇夫的自我评价。
 * 第十一章：井井有条的生活带来的好处。
 * 第十二章：柳比歇夫性格的代价。
 * 第十三张：柳比歇夫的自我批评。
 * 第十四章：比时间更宝贵的东西：目标，成长。
 * 第十五章：自我认知的成长。
 * 第十六章：超越自己。

-->
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://camo.githubusercontent.com/9b0ba22b20c8464aefd022486269d4f3c8f3a5b8/687474703a2f2f696d6731302e333630627579696d672e636f6d2f6e312f6731352f4d30372f31312f30312f7242456857564a6e4a6167494141414141416e4f6362317365314141414564665141734b3934414363364a3231332e6a7067" alt=""></p>
<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>一切都不是我们的，而是别人的，只有时间是我们自己的财产。造物主交给我们，归我们所有的，只有这个不断流逝的、不稳定的东西。就连这个东西，谁只要愿意，都可以把它从我们手里剥夺走。</p>
<p>—— 古罗马哲学家：赛纳卡</p>
</blockquote>
<p>今天要介绍的是 <a href="http://item.jd.com/11331635.html">《奇特的一生》</a> 这是一本关于时间的书，春节期间看到池建强在微信读书中推荐，于是就一口气读完了。该书讲述苏联科学家柳比歇夫将自己的一生用时间来计划，通过分析柳比歇夫「时间统计法」，作者认为这是让他生活得更好的秘密。</p>
<p>以下是我的读书感受。</p>]]>
    
    </summary>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[教你阅读图书的「方法论」- 评《如何阅读一本书》]]></title>
    <link href="http://blog.devtang.com/2016/01/17/how-to-read-a-book-summary/"/>
    <id>http://blog.devtang.com/2016/01/17/how-to-read-a-book-summary/</id>
    <published>2016-01-17T01:58:18.000Z</published>
    <updated>2016-02-16T10:26:44.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/how-to-read-a-book.jpg">
<h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><p>最近常圳给我推荐了 <a href="http://item.jd.com/11435655.html" target="_blank" rel="external">《如何阅读一本书》</a> 这本书。这本书最初出版于 1940 年，然后于 1970 年进行了增补改写。到现在已经面世 70 多年，在我写这篇笔记的时候，该书在京东上的 <a href="http://book.jd.com/booktop/0-0-0.html?category=3281-0-0-0-10001-1" target="_blank" rel="external">销售排名</a> 位于社会科学销量榜第 2 名，可见该书是多么畅销。</p>
<p>在花两周读完本书之后，我最大的收获是学会了如何更加科学地阅读。在本书中，作者将阅读分为四个层次，并且逐条讲解每一个层次的阅读方法，以及需要达到的目标。本书将阅读分为如下四个层次：</p>
<ol>
<li>基础阅读</li>
<li>检视阅读</li>
<li>分析阅读</li>
<li>主题阅读</li>
</ol>
<p>我一直对这 4 个偏学术的名词记不太清，我对这四个层次的理解如下：</p>
<ol>
<li>基础阅读，是指基本的识字和认识能力，能够知道每个字和句子表面的意思。这个确实也没什么好多说的，全书第 3 章花了一共 8 页简单介绍了一下。我想这一层次的内容主要可以使得全书的理论结构更加完整。</li>
<li>检视阅读，是指的快速获得图书重要信息的能力，其实就是略读。但是本书有价值的地方在于，他提供了一套略读的方法指导，使得你能够更科学地快速获得全书的概要信息。</li>
<li>分析阅读，其实就是精读，作者对于分析阅读提出了一系列问题，让我们通过回答这些问题，来辅助我们获得书本背后作者想传达的思想。</li>
<li><p>主题阅读，其实就是把含有相似内容的书籍综合起来一起读，从而对目标知识产生更全面的理解。这就像我们大学时要写某个具体领域的研究论文，然后就会用一些关键词在学校图书馆或期刊上搜索，然后把这些同一领域的图书或期刊都借出来系统学习。</p>
<p>所以，我认为本书的牛逼之处并不在于提出了阅读的 4 个层次，即使没有本书，我们在实际生活中也会自觉的在阅读中，根据自己的需要，采用不同的层次来阅读。本书之所以受欢迎，是因为它对于每个阅读层次，都有一套具体的、可执行的操作方法，有了这套「方法论」，大家可以按步就班地来做更加科学地阅读。</p>
</li>
</ol>
<p>我们常常会出现这样一个对话场景：</p>
<blockquote><p>A 说：「某某书你看过了吗？」<br>B 回答说：「看过了，挺不错的！」<br>A 问：「讲了什么？」<br>B 说：「呃。。。不记得了。」</p>
</blockquote>
<p>我想《如何阅读一本书》的价值就在于这儿吧，它让以上这种场景尽可能地避免了。我们来看看它的「方法论」到论是什么样的。</p>
<h3 id="u68C0_u89C6_u9605_u8BFB"><a href="#u68C0_u89C6_u9605_u8BFB" class="headerlink" title="检视阅读"></a>检视阅读</h3><p>基础阅读我就不介绍了。因为基本的识字和认识能力应该是每一个成年人都应该具有的。我们直接来看看检视阅读的方法。</p>
<p>检视阅读的第一阶段：系统的略读。具体的做法如下：</p>
<ol>
<li>先看书名页，然后如果有序就先看序。</li>
<li>研究目录页。</li>
<li>如果书中附有索引，也要检阅一下。</li>
<li>读一下出版者的介绍（如果有）。</li>
<li>开始挑几个看起来跟主题息息相关的篇章来看。</li>
<li>把书打开，随意浏览，念个一两段，有时候连续读几页，但不要太多。</li>
</ol>
<p>检视阅读的第二阶段：</p>
<ol>
<li>不要在不懂的地方停下来深究（查询或思索）。</li>
<li>注意阅读速度（文中还介绍了一些速读的技巧：如避免「半出声」的阅读，用手指快速移动来控制眼睛停留时间等）。</li>
</ol>
<h3 id="u5206_u6790_u9605_u8BFB"><a href="#u5206_u6790_u9605_u8BFB" class="headerlink" title="分析阅读"></a>分析阅读</h3><p>作者认为一个主动的阅读者，需要解决如下四个问题：</p>
<ol>
<li>这本书整体上在谈些什么？</li>
<li>作者细部说了什么，怎么说的？</li>
<li>这本书讲得是否有道理？是全部有道理，还是部分有道理？</li>
<li>这本书跟你有什么关系？</li>
</ol>
<p>为了解决以上问题，作者将分析阅读分成如下几个阶段。</p>
<p>第一阶段（解决问题 1），找出一本书在谈些什么的四个规则：</p>
<ol>
<li>依照书本的科类与主题作分类。</li>
<li>用最简短的句子说出整本书在谈些什么。</li>
<li>按照顺序或关系，列出全书的重要部分。</li>
<li>找出作者在问的问题，或作者想解决的问题。</li>
</ol>
<p>第二阶段（解决问题 2）：诊释一本书的内容规则</p>
<ol>
<li>诊释作者的关键字，与他达成共识。</li>
<li>由最重要的句子中，抓住作者的重要主旨。</li>
<li>知道作者的论述是什么，从内容中找出相关的句子，再重新架构出来。</li>
<li>确定作者已经解决了哪些问题，还有哪些是没解决的。再判断哪些是作者知道他没解决的问题。</li>
</ol>
<p>第三阶段（解决问题 3 和 4）：像是沟通知识一样地评论一本书的规则</p>
<ol>
<li><p>智慧礼节的一般规则：</p>
<ul>
<li>除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。</li>
<li>不要争强好胜，非辩到底不可。</li>
<li>在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。</li>
</ul>
</li>
<li><p>批评观点的特别标准：</p>
<ul>
<li>证明作者的知识不足。</li>
<li>证明作者的知识错误。</li>
<li>证明作者不合逻辑。</li>
<li>证明作者的分析与理由是不完整的。</li>
</ul>
</li>
</ol>
<p>在我看来，第三阶段指出的批评观点的标准，使得人们更加容易清楚自己的立场是如何而来的。作者是这样说的：「如何你不能用相关证据显示作者是知识不足、知识有误，或不合逻辑，你就不能反对他」。很多人面对一些结论的时候，表现出强烈的反对，但是如果你发现他不能按以上标准来反对的话，就说明他并不真正在反对，只是「不喜欢」这个结论，而这只是在表达一种情绪或者偏见。我们应该尽量避免陷入情绪中，或者至少应该在陷入情绪中时，知道自己当前只是在发泄，而不是在讨论问题。</p>
<h3 id="u4E3B_u9898_u9605_u8BFB"><a href="#u4E3B_u9898_u9605_u8BFB" class="headerlink" title="主题阅读"></a>主题阅读</h3><p>作者将主题阅读分为两个阶段。</p>
<p>第一阶段：准备：</p>
<ol>
<li>针对要研究的主题，列出书单。</li>
<li>浏览书单中的书，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。</li>
</ol>
<p>第二阶段：阅读：</p>
<ol>
<li>从书单中的书中，找出与主题最相关的章节。</li>
<li>根据主题创造出一套中立的词汇，带引作者与你达成共识。</li>
<li>建立一个中立的主旨，列出一连串的问题，使大多数的作者为解读这些问题提供了他们的回答。</li>
<li>界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。</li>
<li>分析这些讨论。</li>
</ol>
<p>主题阅读的理想上要保持客观，当你要解读作者的某个观点时，必须从他文章中引一段话来并列。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>《如何阅读一本书》是一本用「方法论」来指导阅读行为的图书。这本书将阅读分为四个阶段，每个阶段又细分为一些具体的执行方法。使用书中介绍的方法，可以使得我们更快、更有效地获取图书中的关键信息。</p>
<p>更宽泛地说，《如何阅读一本书》培养的是一种获取有效信息的手段和习惯，不管是阅读图书，还是阅读博客、邮件以及平时讨论问题，我们都可以利用书中提到的分析阅读的方法，来获得有效的信息。另外，当涉及争论时，书提到的批评别人观点的方法也非常客观，这会使得大家的争论会更加理智。</p>
<p>本书不太好的地方在于内容太过啰嗦，如果能够将内容再精简一半，我可能会更喜欢一些。另外，将「略读」和「精读」换个名字成「检视阅读」和「分析阅读」，也让我觉得有些太夸张了一些。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/how-to-read-a-book.jpg">
<h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><p>最近常圳给我推荐了]]>
    </summary>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MagicalRecord 作者 Saul Mora 的故事]]></title>
    <link href="http://blog.devtang.com/2016/01/12/saul-introdution/"/>
    <id>http://blog.devtang.com/2016/01/12/saul-introdution/</id>
    <published>2016-01-12T14:20:45.000Z</published>
    <updated>2016-02-16T10:26:44.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/saul-mora.jpg">
<p>这次 Swift 开发者大会上，我认识到了一位新朋友，他叫 Saul Mora（如上图），听到这个名字时我没有什么感觉，但是随后旁边的一个朋友介绍道：「他是 MagicRecord」的作者之一，我突然眼睛亮了。</p>
<p>不知道有多少人听过 MagicRecord，MagicRecord 是一个基于 Core Data 的库，可以让你更加方便地使用 Core Data。在我学习 Core Data 时，曾经抱怨过 Core Data 一些设计过于繁琐，使用不方便，那时就常常会听到人们说：「你应该使用 MagicRecord」。而 MagicalRecord 的 Github 首页上 <a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="external">https://github.com/magicalpanda/MagicalRecord</a> ，已经有了 8000 多的 Star 数。</p>
<p>在我进一步和 Saul Mora 聊天时，我才发现，他的作品远远不只是 MagicRecord。他还是著名的 iOS 网站 Ray Wenderlich 的图书《Core Data by Tutorials》作者，并且发表了很多文章在 Ray Wenderlich 上。另外，他也是一个有趣的人，他维护着他的名为 NSBrief 的 podcast：<a href="http://nsbrief.com" target="_blank" rel="external">http://nsbrief.com</a>，采访了很多 iOS 和 Mac 的开发者。</p>
<p>好了，现在关键来了，Saul Mora 在硅谷工作得有些腻了，而且他想学习中文，于是他现在来到了中国，打算在北京、上海或成都找一份 iOS 开发的工作。</p>
<p>我想，这对于很多公司来说，都是一个千载难逢的机会，来招募到一位全球顶尖的 iOS 开发者。所以，如果你对 Saul 感兴趣，可以将你的公司介绍、希望他过去做的事情、大概的待遇，以及任何你觉得可以吸引他的信息，发到他的邮箱：</p>
<p>Saul@casademora.com</p>
<p>对了，Saul 现在还在学习中文，所以他还不能很流利地用中文交流。所以如果邮件用英文写的话，会更有利于他考虑工作机会哟。</p>
<p>感谢 Saul 给开源社区的贡献，也祝福他在中国能够开始一段愉快的经历！</p>
<hr>

<p>以下是 Saul 写的自我介绍：</p>
<p>About Saul</p>
<p>Saul Mora is an American iOS developer. He has been involved with the iOS community for several years. He has helped start Cocoaheads and NSCoderNight meetups in Phoenix, Arizona and Denver, Colorado. </p>
<p>He is the author of MagicalRecord (<a href="http://magicalrecord.com" target="_blank" rel="external">http://magicalrecord.com</a>), the iOS framework for use with Core Data. Saul is a co-author of Core Data by Tutorials (<a href="http://www.raywenderlich.com/store/core-data-by-tutorials" target="_blank" rel="external">http://www.raywenderlich.com/store/core-data-by-tutorials</a>) published with Ray Wenderlich (<a href="http://raywenderlich.com" target="_blank" rel="external">http://raywenderlich.com</a>)</p>
<p>Over the past few years, Saul has produced the NSBrief podcast (<a href="http://nsbrief.com" target="_blank" rel="external">http://nsbrief.com</a>) to talk to many developers in the iOS and Mac development community. Saul has also shared his knowledge in person all over the world giving talks at many developer conferences in the USA and Europe. </p>
<p>Saul has spent the last year in Silicon Valley and has recently decided to move to China to pursue his goal to become fluent in the Chinese language. He is eager to meet iOS developers everywhere and share his knowledge and experience with all the developers in China.</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/saul-mora.jpg">
<p>这次 Swift 开发者大会上，我认识到了一位新朋友，他叫 Saul Mora（如上图），听到这个名字时我没有什么感觉，但是随后旁边的一个朋友介绍道：「他是 MagicRecord」的作者之一，我突然眼睛亮]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[首届 Swift 开发者大会见闻]]></title>
    <link href="http://blog.devtang.com/2016/01/10/atswift-conference-summary/"/>
    <id>http://blog.devtang.com/2016/01/10/atswift-conference-summary/</id>
    <published>2016-01-10T14:31:55.000Z</published>
    <updated>2016-02-29T13:19:13.000Z</updated>
    <content type="html"><![CDATA[<p>今天是中国 iOS 开发者的一次聚会，因为首届 Swift 开发者大会在北京成功举办了。这次会议的质量很高，大会的相关 keynote 和 视频，稍后都会在官网上公开，所以没能参会的同学可以关注官网（ <a href="http://atswift.io/" target="_blank" rel="external">http://atswift.io/</a> ）的内容更新。我作为大会的主席（其实基本没出什么力）全程参与了全天的大会，在此记录下一些参会的见闻。</p>
<p>先说说本次的大会的演讲内容吧。这次大会的 Keynote 可<a href="https://github.com/atConf/atswift-2016-resources" target="_blank" rel="external">在此下载</a>。</p>
<p>2016.02.29更新：中国首届swift开发者大会的视频已经放出：<a href="http://www.imooc.com/learn/600" target="_blank" rel="external">http://www.imooc.com/learn/600</a></p>
<h3 id="Chris"><a href="#Chris" class="headerlink" title="Chris"></a>Chris</h3><p>开场的是 objc.io 的创始人 Chris Eidhof。Chris 是大会演讲者中唯一没有准备 keynote 的人，但是演讲相当精彩。Chris 虽然没有 keynote，但是内容是精心准备过的，他先用 playground 简单介绍了一些 Swift 的内容后，就转到一个游戏 Demo 的重构工作中，整个重构工作包括几点：</p>
<ol>
<li>用 typealias 去掉 NSUserDefaults 的依赖。</li>
<li>用 protocol 来代替继承。</li>
<li>用 extension 来实现 protocol。</li>
<li>尽量用 struct。 </li>
<li>全程用 testcase 来验证重构过程。</li>
</ol>
<p>最终，我们看到了一个重构之后的游戏 Demo，相比以前的工程，重构后的项目代码更短，逻辑更清晰。</p>
<p>人们常说，Talk is cheap, show me the code。 Chris 用行动让我们看到如何写出更好的 Swift 代码。</p>
<h3 id="u5085_u82E5_u611A"><a href="#u5085_u82E5_u611A" class="headerlink" title="傅若愚"></a>傅若愚</h3><p>傅若愚来自 thoughtworks，和我一样是成都人。他这次的演讲主题是《越过 OC 与 Swift 间的鸿沟》，对于正在经历从 OC 到 Swift 转型的各位来说，非常实际。</p>
<p>他从一段代码来引出了大家的好奇，下面这段代码，居然会有两种输出结果，你猜出来是什么原因了吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">someArray = [1, 2, 3]&#10;var result = someArray.map(&#123;&#34;No. \($0)&#34;&#125;)</span><br></pre></td></tr></table></figure>
<p>接着傅若愚介绍了从 OC 转到 Swift 需要注意的地方：</p>
<ol>
<li>优先用 protocol 而不是继承</li>
<li>更多通过 annum, struct, extension 来达成目的。</li>
</ol>
<p>最后，他展示了一个利用函数式编程来重构代码的例子。</p>
<h3 id="Greg"><a href="#Greg" class="headerlink" title="Greg"></a>Greg</h3><p>Greg 是加拿大多伦多的一位 iOS 自由职业者，亚裔，看起来非常像中国人，但是其实他不会说中文。他在为著名 的 raywenderlich.com 撰写博客。本次他分享的是《Swift Style》。</p>
<p>在介绍了编写易读的代码的重要性之后，他从以下 3 方面介绍了他的 Swift 经验：</p>
<ol>
<li>Value types</li>
<li>Protocol</li>
<li>Safety</li>
</ol>
<p>提问环节的时候，Chris 当托似地问了一个非常有趣的问题：「你最近 1 年在写 Swift 代码上有何转变？」。</p>
<p>这个问题非常有意思，Greg 说他现在用了更多的 guard 关键词，然后 Greg 也说到，他写习惯 Swift 之后，因为养成了强类型检查的习惯，他偶尔回去写 oc 的时候会不停地 check 各种 nil。</p>
<h3 id="u674E_u6D01_u4FE1"><a href="#u674E_u6D01_u4FE1" class="headerlink" title="李洁信"></a>李洁信</h3><p>李洁信是下午第一场，非常犯困的时间。洁信稍微有一些紧张，内容是关于《Swift 中的协议编程》，他把这些内容都梳理得挺好的，讲得挺清楚。</p>
<h3 id="u738B_u5DCD"><a href="#u738B_u5DCD" class="headerlink" title="王巍"></a>王巍</h3><p>喵神王巍是下午第二场，王巍的主题是《如何打造一个让人愉快的框架》，喵神的准备非常充分，演讲过程中还各种卖萌，实在是非常可爱。喵神主要从以下几个方面介绍了框架的开发：</p>
<ol>
<li>静态库和框架的对比</li>
<li>包和依赖管理</li>
<li>创建框架</li>
<li>一些 Tips</li>
<li>发布框架</li>
<li>持续集成</li>
</ol>
<p>如果你希望基于 Swift 来开发一个 framework，非常值得看看喵神的分享。</p>
<h3 id="u5305_u6DB5_u537F"><a href="#u5305_u6DB5_u537F" class="headerlink" title="包涵卿"></a>包涵卿</h3><p>包涵卿讲的是《Swift 函数式编程实践》，这块其实是挺难讲的，前面的一些函数式编程的基础还好，比如柯里化之类，但是后面估计比较难理解，我不知道现场有多少人听懂了 Monad 的概念，不过这个确实是比较挑战的话题。</p>
<h3 id="u7FC1_u9633"><a href="#u7FC1_u9633" class="headerlink" title="翁阳"></a>翁阳</h3><p>这场话题茶歇回去之后听了一半，所以没怎么整理出来笔记。有些遗憾。</p>
<h3 id="u5468_u6977_u96EF"><a href="#u5468_u6977_u96EF" class="headerlink" title="周楷雯"></a>周楷雯</h3><p>周楷雯的分享里介绍了各种性能优化的技巧。可惜他当时手机变砖，有一些着急，讲得比较快，很多点感觉展开讲会更好一些。</p>
<h3 id="u540E_u8BB0"><a href="#u540E_u8BB0" class="headerlink" title="后记"></a>后记</h3><p>这次 Swift 大会中还做了一些有趣的调查，在此将数据分享给大家：</p>
<ol>
<li>这次有 3/4 的听众来自外地！</li>
<li>现场有 1/3 的听众已经开始将 Swift 应用于公司项目开发中。</li>
</ol>
<p>这次大会的组委会都很棒，包括梁杰、裕波、王臣汉、陈雨恒、李涛（还有一些我没能记住名字的同学）都对这次大会付出了大量心血。作为一个非赢利性的 Swift 大会，我觉得他们做到了内容的高质量，期待明年的第二届大会如期进行！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天是中国 iOS 开发者的一次聚会，因为首届 Swift 开发者大会在北京成功举办了。这次会议的质量很高，大会的相关 keynote 和 视频，稍后都会在官网上公开，所以没能参会的同学可以关注官网（ <a href="http://atswift.io/" target=]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ReactiveCocoa 讨论会]]></title>
    <link href="http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/"/>
    <id>http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/</id>
    <published>2016-01-03T07:22:13.000Z</published>
    <updated>2016-02-16T10:26:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>（其简称为 RAC）是由 <a href="https://github.com/blog/1107-reactivecocoa-for-a-better-world" target="_blank" rel="external">Github</a> 开源的一个应用于 iOS 和 OS X 开发的新框架。RAC 具有函数式编程和响应式编程的特性。它主要吸取了 .Net 的 <a href="http://msdn.microsoft.com/en-us/data/gg577609" target="_blank" rel="external">Reactive Extensions</a> 的设计和实现。</p>
<p>但是，相对于传统的 MVC 架构，ReactiveCocoa 的函数式编程方式的学习曲线陡峭，业界也没有丰富的图书资料，这使得大家对这种技术望而却步。这次，我邀请了一些行业内关注和使用 ReactiveCocoa 的内行，进行了一次关于 RAC 的讨论会，会上大家主要聊了 RAC 在使用中的各种问题，我们希望这次讨论会能够让重新全面审视这个开发框架。</p>
<h2 id="u8BA8_u8BBA_u6210_u5458"><a href="#u8BA8_u8BBA_u6210_u5458" class="headerlink" title="讨论成员"></a>讨论成员</h2><p>本次讨论会邀请到的讨论者来自美团，百度，蘑菇街等公司。讨论前为了先相互认识，我让大家自我介绍了一下，并且顺便简单介绍各自所在的团队人数以及使用 RAC 的时长，以下是大家的自我介绍：</p>
<ul>
<li><p>臧成威，来自美团，团队基本都在使用 RAC，从 14 年初开始使用 RAC。在美团搞过 RAC 的几期培训，有丰富的经验。</p>
</li>
<li><p>李忠 (limboy)，来自蘑菇街。李忠的博客（<a href="http://limboy.me/" target="_blank" rel="external">http://limboy.me/</a>）上有很多介绍 RAC 的高质量文章。（这次讨论会李忠当时有事没有参加，事后对相关问题留言表达了自己的看法）</p>
</li>
<li><p>唐晓轩 (txx)，来自礼物说，团队四个人，目前 “只有” 礼物说这一款产品。从年初开始使用 RAC，到现在正在安利 Android  团队使用 RXJava。</p>
</li>
<li><p>孙源 (sunnyxx)，来自百度，从 13 年年底开始接触 RAC，当时边学边用 RAC 写了一个完整的项目，那时候还没现在这么火（当时 Limboy 的文章看了好几遍），后来在项目中在一个完整模块中尝试使用过，因为大家对函数响应式编程了解程度差别很大，导致代码几乎无法维护，随后重构。现在也有时用到，但都用于某个特定的功能的便捷实现上，无 MVVM，基本不会跨类使用。</p>
</li>
<li><p>雷纯锋，来自广州支点网络科技股份有限公司，团队三个人使用 RAC ，从 12 年 6 月份开始使用 RAC ，公司项目一直使用的是 RAC。项目中一直也是用的 MVVM + RAC 的结构，另外我也有在维护一个 MVVM + RAC 的开源项目，叫 MVVMReactiveCocoa。</p>
</li>
<li><p>汤圣罡 (lexurs)，来自新味，2 个 iOS。RAC 经验两年。目前在用 Overcoat+Mantle+ReactiveCocoa 实现的网络层，某些逻辑多的页面也喜欢用 RAC 实现。因为想全部改成 Swift，正在投靠 RxSwift 和 PromiseKit 的过程中。</p>
</li>
<li><p>李雄略 (听榆大叔)，来自网家缘科技，分 2 个产品，每个产品 2 个 iOS 开发，从 14 年 3 月份开始使用 RAC，已在 3 个项目中使用 RAC。</p>
</li>
<li><p>蓝晨钰 (lancy)，来自猿题库，没有在公司项目使用过 RAC。个人喜欢 RAC，私底下写过 RAC 的小项目，读过 RAC 源码，但对 RAC 在大型项目中和团队合作中持谨慎态度，猿题库的架构是类 MVVM 架构，但没有引入 RAC。</p>
</li>
<li><p>唐巧（就是本文作者），来自猿题库，团队分 3 个产品，每个产品约 4 个 iOS 开发，没有在公司正式使用过 RAC，自己私下写过几百行 RAC 的代码，对于 RAC 是比较保守的一个人。</p>
</li>
</ul>
<p>好了，以下就是我们具体讨论的一些问题。</p>
<h3 id="u8BA8_u8BBA_uFF1A_u5982_u4F55_u5728_u56E2_u961F_u5185_u63A8_u5E7F_u5E76_u7528_u300C_u6B63_u786E_u7684_u59FF_u52BF_u300D_u4F7F_u7528_RAC_uFF1F"><a href="#u8BA8_u8BBA_uFF1A_u5982_u4F55_u5728_u56E2_u961F_u5185_u63A8_u5E7F_u5E76_u7528_u300C_u6B63_u786E_u7684_u59FF_u52BF_u300D_u4F7F_u7528_RAC_uFF1F" class="headerlink" title="讨论：如何在团队内推广并用「正确的姿势」使用 RAC？"></a>讨论：如何在团队内推广并用「正确的姿势」使用 RAC？</h3><p>大家提到在使用 RAC 的时候，出现的一些问题，例如：</p>
<ul>
<li>不是太精通 RAC 的同学往往写出来的非常难以维护</li>
<li>不知道新队友的 RAC 培养路径，Functional Programming -&gt; MVVM -&gt; ….</li>
</ul>
<p>对于难以维护的问题，臧成威的意见是：</p>
<blockquote>
<p>这个美团这边的解决方案主要是 review，review 可以保证项目中所有人的范式是相同的，大家对于不同的写法都会有充分的讨论，而我们的新手主要是参考旧代码的风格写出新代码，所以并没有发生难以维护这一现象。</p>
<p>但是前提是需要有很熟悉的人来带领，团队中熟悉 RAC 的人员基数得以保证。而且美团的 RAC 使用还是逐步放量的，从一开始的 UI 层使用，到底层逻辑层的使用，最后才到了 MVVM 的粘合层使用，这样避免了泛滥。</p>
<p>总结来说，对于 RAC 这样厚重的库，引入的时候的 review 是必要的，否则可控性太差，最后就难以收场了。</p>
</blockquote>
<p>总结起来就是：1、review + 有熟练的人带；2、逐步放开使用。</p>
<p>对于人才的培养，臧成威的意见是：</p>
<blockquote>
<p>RAC 的培养，从我这边三期的培训来看，课程的安排是这样的六节： 1. FRP 的思想概要 2. RAC 的 operations 介绍 3. 冷信号与热信号解惑 4. 生命周期指南 5. disposable 和多线程 6. 实战分享</p>
<p>其中先建立 FRP 的思想，虽然看起来是最远的，但是确实是后续使用和教学的基础。</p>
<p>一起培训大概有 30-50 人来听，课程一种持续三周，每周 2 节课、课程过后的 2 周，就可以发现代码中的 rac 使用明显提升</p>
<p>另外补充一点，关于新手学习，最不建议的就是在不了解 FRP 原理和一些基础概念的情况下，盲目的看源代码。我见过太多的同学，花费了很多的时间通览源码，但是根本没有用途。因为从思想到源代码是经历了很多雕琢的。里面有太多的 bugfix，太多的折中。</p>
<p>所以你看的时候，抛开了本质，一味的查看边界的处理，最后大都觉得痛苦，难用，难以掌握收场。</p>
<p>唐巧：RAC 确实和其它的开源库性质上差别比较大，思想方面需要学习的比较多。</p>
<p>是的，关键是思想。所以，一定要先从 “道” 上建立思想，然后从 “术” 上掌握使用，最后才是通览源码，掌握其原理。</p>
<p>第一节是道的课程，第二节是术的课程。这两节下来就知道能干什么了。</p>
</blockquote>
<p>雷纯锋意见也与臧成威一致。</p>
<p>唐晓轩介绍了一下他自己的学习过程：</p>
<blockquote>
<p>我是反着做的，先把 rac 当作 blocks kit 用 之后 看 racstream 的各种 operations，知道 rac 有哪些运算 其次 看 rac 的 uikit 扩展都是怎么实现的 最后才是函数式思维。</p>
</blockquote>
<p>我顺着臧成威的回答，问了一下通常使用 RAC 的规范是什么，臧成威回答道：</p>
<blockquote>
<p>大家可以参考这样的一条规范来做，首先通过 RACSignal#return RACSignal#createSignal 这类的创建一个 OOP 世界到 FRP 世界的一个转换，从而得到一个 Signal。</p>
<p>之后 signal 在不接触 OOP 的情况下进行数据的各类变换，注意 FP 的引用透明和变量不可变特性。</p>
<p>最后用 RAC 宏、RACSignal#subscribe、NSObject+liftSelect 这些操作把 FRP 的世界带回到 OOP 的世界里。</p>
</blockquote>
<p>臧成威还很体贴地画了一个示意图，非常给力：</p>
<img src="/images/fpr_oop_pattern.jpg">
<h3 id="u8BA8_u8BBA_uFF1A_u5927_u516C_u53F8_u7684_u5927_u578B__28_u81C3_u80BF_29_App__u662F_u5426_u9002_u5408_u4F7F_u7528_RAC_uFF1F"><a href="#u8BA8_u8BBA_uFF1A_u5927_u516C_u53F8_u7684_u5927_u578B__28_u81C3_u80BF_29_App__u662F_u5426_u9002_u5408_u4F7F_u7528_RAC_uFF1F" class="headerlink" title="讨论：大公司的大型 (臃肿) App 是否适合使用 RAC？"></a>讨论：大公司的大型 (臃肿) App 是否适合使用 RAC？</h3><p>由于第一个话题臧成威贡献最多内容，加上美团是大家所知道的使用 RAC 最多的大型 App，所以这个话题还是由臧成威首先回答，以下是他的发言。</p>
<blockquote>
<p>越大型的 app，说明内部的逻辑越复杂。而 RAC 从某几方面可以简化逻辑，使得代码从书写到执行都可以较为简化的完成功能</p>
<p>我大概总结了几个适用的场景。RAC 总结来说就是：数据随着时间而产生，所以能想到的三点比较适合用 RAC：</p>
<p>一、UI 操作，连续的动作与动画部分，例如某些控件跟随滚动。</p>
<p>二、网络库，因为数据是在一定时间后才返回回来，不是立刻就返回的。</p>
<p>三、刷新的业务逻辑，当触发点是多种的时候，业务往往会变得很复杂，用 delegate、notification、observe 混用，难以统一。这时用 RAC 可以保证上层的高度一致性，从而简化逻辑上分层。</p>
<p>只要有通知的业务逻辑，RAC 都方便有效化解。</p>
<p>雷纯锋：概括的说，应该就是统一所有异步事件吧。</p>
<p>不适用的场景，与时间无关的，需要积极求解的计算，例如视图的单次渲染。</p>
</blockquote>
<p>接着发言的是百度的孙源：</p>
<blockquote>
<p>我这是百度知道，体量比较小，可以随便玩。</p>
<p>我们现在就用它做点小功能，举个例子吧，聊天页面那个键盘弹出时 input bar 跟随滚动的功能，原来写需要接通知、写回调，现在在一个函数里面用 RAC 就比较方便。</p>
<p>像这种小功能，主要是方便开发，让 “干一个事儿的代码写在一个地方”。</p>
</blockquote>
<p>雷纯锋说他们的使用还是比较多：</p>
<blockquote>
<p>基本上异步的事件能用 RAC 的都用的 RAC。</p>
<p>不过代理方法用 RAC 的比较少，比如 UITableView 的代理方法一般都是直接写了。</p>
<p>用 RACSubject + RACComand 来简化和统一应用的错误处理逻辑，这个算比较经典的吧。</p>
<p>臧成威说：UI 交互上的点确实好多，比如下拉刷新、上拉导航条变透明。</p>
<p>实时响应用户的输入，控制按钮的可用性，这点用 RAC 来实现非常简单。</p>
</blockquote>
<p>李雄略说：</p>
<blockquote>
<p>我们主要用来处理界面上的数据显示，以及 UI 的交互操作上，不会用来写代理。</p>
</blockquote>
<p>对于这个话题，似乎大家的答案还是比较一致，即：大型 App 是适合使用 RAC 的。</p>
<h3 id="u8BA8_u8BBA_uFF1A_u90FD_u8BF4_u8C03_u8BD5_RAC__u5F88_u75DB_u82E6_uFF0C_u662F_u5426_u6709_u4E00_u4E9B_u8C03_u8BD5_u6280_u5DE7_u548C_u7ECF_u9A8C_u5206_u4EAB_uFF1F"><a href="#u8BA8_u8BBA_uFF1A_u90FD_u8BF4_u8C03_u8BD5_RAC__u5F88_u75DB_u82E6_uFF0C_u662F_u5426_u6709_u4E00_u4E9B_u8C03_u8BD5_u6280_u5DE7_u548C_u7ECF_u9A8C_u5206_u4EAB_uFF1F" class="headerlink" title="讨论：都说调试 RAC 很痛苦，是否有一些调试技巧和经验分享？"></a>讨论：都说调试 RAC 很痛苦，是否有一些调试技巧和经验分享？</h3><p>臧成威说：</p>
<blockquote>
<p>的确很痛苦，跟断点有的时候计算堆栈都要等几分钟。</p>
<p>关于调试，RAC 源码下有 instruments 的两个插件，方便大家使用。</p>
<p>signalEvents 这个可以看到流动的信号的发出情况，对于时序的问题可以比较好的解决。</p>
<p>diposable 可以检查信号的 disposable 是否正常</p>
</blockquote>
<img src="/images/rac-instrument.jpg">
<p>小伙伴们看了纷纷惊叹，表示以前没有用过这个神器。</p>
<p>雷纯锋接着分享：</p>
<blockquote>
<p>我的理解是一般给信号一个名字，然后通过下面的打印方法来进行调试。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// Logs all events that the receiver sends.&#10;- (RACSignal *)logAll;&#10;&#10;/// Logs each `next` that the receiver sends.&#10;- (RACSignal *)logNext;&#10;&#10;/// Logs any error that the receiver sends.&#10;- (RACSignal *)logError;&#10;&#10;/// Logs any `completed` event that the receiver sends.&#10;- (RACSignal *)logCompleted;</span><br></pre></td></tr></table></figure>
<p>李雄略说：</p>
<blockquote>
<p>我是用 log 方法来做的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DExecute((&#123;&#10;    setenv(&#34;RAC_DEBUG_SIGNAL_NAMES&#34;, &#34;RAC_DEBUG_SIGNAL_NAMES&#34;, 0);&#10;    [signalUserGeo setNameWithFormat:@&#34;signalUserGeo&#34;];&#10;    signalUserGeo = [signalUserGeo logAll];&#10;&#125;));</span><br></pre></td></tr></table></figure>
<p>李忠的补充：</p>
<blockquote>
<p>调试的话，如果是性能调试，主要是经验 +Instruments，经验类似于：少用 RACCommand、RACSequence 这样的，Instruments 可以用它的 Time Profile 来看。</p>
<p>如果是 Bug 调试，主要还是靠 Log，配合一些 Xcode 插件，比如 MCLog(可以很方便地过滤日志)，如果要还原堆栈的话，就加一个断点。</p>
</blockquote>
<p>接下来大家讨论起来：<br>&gt;</p>
<blockquote>
<p>臧成威：其实 instruments 也差不多，只是第一，不需要提前调用 logAll 这些；第二，可以利用 instruments 的筛选功能，不会看 log 看到眼花。</p>
<p>雷纯锋：实际调试起来好用吗？</p>
<p>臧成威：好用的，还可以看到发出 value 的堆栈。</p>
<p>雷纯锋：使用 instruments 来调试的频率大吗？或者说在什么情况下会去用 instruments 调试呢？</p>
<p>臧成威：一般调查问题的时候就它来查。比如某个信号接不到输出。</p>
<p>臧成威：或者输出的值里面有错误的，但是是经过 merge、zip 等好多操作混合出来的，不知道源头是神马。</p>
<p>雷纯锋：也就是说一般是在有问题，然后分析不出来的时候，才使用吗？</p>
<p>臧成威：是的，一般是调查问题的时候用的，不是开发的时候用的，因为打开是比较慢的。</p>
<p>李雄略：为了方便，我们保证一个 RACSignal 只会给订阅者 send 一种类型的 value，所以就手动给 signal 加了部分泛型支持：</p>
<p>@interface RACSignal<__covariant objecttype=""> : RACStream</__covariant></p>
<p>RACSignal<nsstring *=""> *signal = …</nsstring></p>
<p>孙源：用泛型，然后 map 之后呢</p>
<p>李雄略：map 无法支持</p>
<p>臧成威：RAC3 里面就有不错的泛型推导，但是是基于 swift 的。</p>
<p>臧成威：这个我也想过，但是语言不支持，基本上是搞不定的</p>
<p>孙源：调试这块也就是 log name 了。作者 guide 里面也是这么弄，用 Instrument 已经是高级技巧。</p>
<p>臧成威：加 log 比较不好的就是容易眼花，还有不好还原当时的堆栈。</p>
<p>孙源：我一般遇到问题，都是看代码脑补一遍过程，函数式就好在这里，基本上看着对了结果就没错。脑回路逻辑推导。</p>
<p>臧成威：是的，推导很有道理。我觉得 sunnyxx 说的是王道，所以培训，给大家建立思维很重要。</p>
<p>雷纯锋：恩，分析清楚整个运算过程是很重要的</p>
</blockquote>
<h3 id="u8BA8_u8BBA_uFF1ARAC__u76F8_u6BD4_RxSwift__u548C_PromiseKit__u6709_u54EA_u4E9B_u4F18_u7F3A_u70B9__3F"><a href="#u8BA8_u8BBA_uFF1ARAC__u76F8_u6BD4_RxSwift__u548C_PromiseKit__u6709_u54EA_u4E9B_u4F18_u7F3A_u70B9__3F" class="headerlink" title="讨论：RAC 相比 RxSwift 和 PromiseKit 有哪些优缺点 ?"></a>讨论：RAC 相比 RxSwift 和 PromiseKit 有哪些优缺点 ?</h3><p>臧成威继续分享：</p>
<blockquote>
<p>RAC vs RxSwift 的情况是这样：</p>
<p>从支持度来说，RAC 对 Cocoa 的支持更好。但是从标准性、性能来讲 RxSwift 更胜一筹。</p>
<p>因为毕竟是 Rx 团队的亲生项目。还有，OC 只有 RAC 支持，RxSwift 搞不定。</p>
<p>雷纯锋：需要在 Obj-C 下和 Swift 下，分别来比较吧？那 Obj-C 下，用 RAC 应该是没有疑问的了吧，那在 Swift 下呢？</p>
<p>Swift 场景下，由于 OC 做好的 bridge，所以 RAC3swift，仍然有不错的整合性。例如 notification、observer 这些。但是 RxSwift 与框架无关，所以这些功能需要自己补了。</p>
<p>但是 RxSwift 比较标准，和 RxJS、RxJava 所有定义统一，所以迁移过来很容易。但 RxJS 和 RxJava 的原始用户比较少，这点不大明显。</p>
<p>这是 Rx 和 RAC 的对比。</p>
<p>RAC3 swift 版有个特性，就是热信号传导，这点 RxSwift 没有。对于特定的场景来说，热信号传导更好。</p>
<p>PromiseKit 是一种异步库，思想和 FRP 不一样。</p>
<p>PromiseKit 应该和 js 的 promise 库差不多的意思吧，这个我是靠猜的。</p>
</blockquote>
<h3 id="u8BA8_u8BBA_uFF1ARAC__u5728_u5DE5_u7A0B_u4E2D_u4F7F_u7528_u8303_u56F4_u7684_u754C_u9650_uFF0C_u5F80_u5F80_u4E00_u5904_RAC__u5C31_u4F1A_u5F15_u8D77_u548C_u4ED6_u76F8_u5173_u6A21_u5757_u7684_RAC__u5316_uFF0C_u5982_u4F55_u786E_u5B9A_u754C_u9650_u5462_uFF1F"><a href="#u8BA8_u8BBA_uFF1ARAC__u5728_u5DE5_u7A0B_u4E2D_u4F7F_u7528_u8303_u56F4_u7684_u754C_u9650_uFF0C_u5F80_u5F80_u4E00_u5904_RAC__u5C31_u4F1A_u5F15_u8D77_u548C_u4ED6_u76F8_u5173_u6A21_u5757_u7684_RAC__u5316_uFF0C_u5982_u4F55_u786E_u5B9A_u754C_u9650_u5462_uFF1F" class="headerlink" title="讨论：RAC 在工程中使用范围的界限，往往一处 RAC 就会引起和他相关模块的 RAC 化，如何确定界限呢？"></a>讨论：RAC 在工程中使用范围的界限，往往一处 RAC 就会引起和他相关模块的 RAC 化，如何确定界限呢？</h3><p>臧成威：这个我觉得有点危言耸听了吧，对上对下是可以有效包装，逐步放量的。</p>
<p>臧成威：默认作为一种上下模块的通信协议，也不是很危险的事，所以我觉得没有太大的风险。上层拿到一个 RACSignal 就当做一个 BlockKit 的回调方式就可以。这样可以有效控制代码。</p>
<p>雷纯锋：这个我觉得要看模块之间用什么来通信吧。</p>
<p>李忠：这个我觉得还是跟使用场景有关。如果只是简单的对外暴露一个 property，外部直接 KVO 即可，甚至不用关心 RAC。但如果在一些比较复杂的场景使用 RAC 的话，很难做到对上层透明，除非内部的封装做得足够彻底。</p>
<p>李忠：比如网络请求，返回一个 <code>RACSignal</code>，然后外部 <code>subscribeNext</code> 之后，想要取消怎么办？这时只能保存一个 <code>RACDisposable</code> 变量，然后在适当的时机调用 <code>dispose</code> 方法；或者要等待 2 个请求一起完成，再做一些事情（当然可以通过 semaphore / dispatch_group 来做，但这样就丢了 RAC 的特性）等等。</p>
<p>李忠：所以还是要在项目初期就想清楚，如果团队成员对 RAC 都比较熟悉，那自然最好。如果其他人不太了解，甚至抵触，这时就要避免在复杂的场景下使用。</p>
<h3 id="u8BA8_u8BBA_uFF1A_u6709_u4EC0_u4E48_u5B66_u4E60_RAC__u597D_u7684_u8D44_u6599_u5417_uFF1F"><a href="#u8BA8_u8BBA_uFF1A_u6709_u4EC0_u4E48_u5B66_u4E60_RAC__u597D_u7684_u8D44_u6599_u5417_uFF1F" class="headerlink" title="讨论：有什么学习 RAC 好的资料吗？"></a>讨论：有什么学习 RAC 好的资料吗？</h3><p>臧成威：李忠的博客不错：<a href="http://limboy.me/" target="_blank" rel="external">http://limboy.me/</a></p>
<p>唐巧：之前雷纯峰特别推荐美团的几篇博客：<a href="http://tech.meituan.com/tag/ReactiveCocoa" target="_blank" rel="external">http://tech.meituan.com/tag/ReactiveCocoa</a></p>
<p>李忠：coursera 上有一门课是讲 Reactive Programming 的 ( <a href="https://www.coursera.org/course/reactive" target="_blank" rel="external">https://www.coursera.org/course/reactive</a> ) ，也会讲到 Functional Programming。</p>
<p>雷纯锋：我写的这篇是范围比较广一点。<a href="http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/</a> 《ReactiveCocoa v2.5 源码解析之架构总览》</p>
<p>另外要关于 Monad 的也有一篇，<a href="http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/</a> 《Functor、Applicative 和 Monad》</p>
<p>雷纯锋：raywenderlich 上的文章：<br><a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1</a>、<br><a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2</a>、<br><a href="http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1" target="_blank" rel="external">http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1</a>、<br><a href="http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2" target="_blank" rel="external">http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2</a>。</p>
<p>唐巧：我之前看过一本 《Functional Reactive Programming on iOS》，不过还是不够深入。</p>
<p>臧成威：话说，看懂 Haskell，理解 RAC 就不是难事了。</p>
<p>雷纯锋：是的，所以如果要理解 RAC 的思想的话，Haskell 可以学一下。<a href="http://learnyouahaskell.com/" target="_blank" rel="external">http://learnyouahaskell.com/</a></p>
<h3 id="RACSequence__u7684_u6027_u80FD_u95EE_u9898"><a href="#RACSequence__u7684_u6027_u80FD_u95EE_u9898" class="headerlink" title="RACSequence 的性能问题"></a>RACSequence 的性能问题</h3><p>讨论到最后大家还涉及到了 RACSequence 的性能问题。记录如下：</p>
<blockquote>
<p>臧成威：了解了概念后，看源码就很爽了，是 OC 语言的典范。</p>
<p>臧成威：不过看了 RACSequence 的实现，性能是无法使用的。</p>
<p>雷纯锋：无法使用？你们不用 RACSequence 吗？</p>
<p>臧成威：是的，Sequence 的性能很差。</p>
<p>臧成威：由于 OC 没有引用透明和尾递归优化。</p>
<p>雷纯锋：你们没有过吗？</p>
<p>臧成威：你试试 100 个长度的数组进行遍历排序，然后再变回来就明白了。</p>
<p>臧成威：现在都去掉了。</p>
<p>雷纯锋：它主要是用来实现懒计算吧。</p>
<p>雷纯锋：方便集合的转换吧，常规的遍历也不会使用它吧？</p>
<p>臧成威：就是说集合转换的性能太差了。</p>
<p>雷纯锋：恩，以后留意一下</p>
</blockquote>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>本次分享内容的主要贡献来自美团的臧成威同学，从美团的实践中我们也能看到，在有充足经验的人指导下，RAC 不但可以应用于大型项目，也可以工作得很舒服。</p>
<p>最后感谢参加这次讨论会的臧成威、李忠、唐晓轩、孙源、雷纯锋、汤圣罡、李雄略、蓝晨钰，希望他们的分享对大家有所帮助。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/ReactiveCocoa/ReactiveCo]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015 年个人总结]]></title>
    <link href="http://blog.devtang.com/2016/01/02/2015-summary/"/>
    <id>http://blog.devtang.com/2016/01/02/2015-summary/</id>
    <published>2016-01-02T11:08:13.000Z</published>
    <updated>2016-02-16T10:28:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5173_u4E8E_u521B_u4E1A"><a href="#u5173_u4E8E_u521B_u4E1A" class="headerlink" title="关于创业"></a>关于创业</h2><p>今年猿题库顺利拿到了 D 轮 6000 万美元的 <a href="http://36kr.com/p/531286.html" target="_blank" rel="external">融资</a>，估值 3.6 亿美元。而我负责的 <a href="http://www.yuansouti.com/" target="_blank" rel="external">小猿搜题</a>，也从年初的几十万用户，增长到了 5000 多万用户。</p>
<p>今年是小猿搜题的风光年，我们上了「天天向上」，在各种黄金档节目中打电视广告，整体用户数据增长惊人。研究组、市场运营、内容部门各种给力，使得产品技术工作进展得非常顺利。</p>
<p>下图是小猿搜题登上 AppStore 教育榜榜首的截图。</p>
<img src="/images/xyst_appstore_1.jpg">
<h2 id="u6211_u7684_u5DE5_u4F5C"><a href="#u6211_u7684_u5DE5_u4F5C" class="headerlink" title="我的工作"></a>我的工作</h2><p>对于我自己来说，2015 年的工作主要分成上半年和下半年两个阶段。</p>
<p>上半年，我一边负责小猿搜题的 iOS 开发工作，一边负责小猿搜题技术团队的组建和协调工作。小猿搜题当前大部分同事都是在上半年入职到这个团队的。</p>
<p>下半年，团队成员磨合得差不多了，团队里面 iOS 同事也成长起来了，我自己能够从 iOS 具体的开发工作中脱身，使得我更多地关注产品和团队了。</p>
<p>下半年自己的工作主要聚焦到了管理业务和管理团队上，每天组织协调和沟通的事情很多，除了 Scrum 的定期会议外，我还得参加产品的 Scrum 会议和产品过稿，还有美术的过稿。另外，我时不时也需要和运营的同事沟通协调。</p>
<p>有时候忙完一整天不知道时间是如何过去的，然后又看着自己 iOS 开发技能慢慢变弱，有一种焦虑感。于是我首先开始多读书，接着就是总结，试图调整自己。</p>
<p>数据分析的工作让我知道任何的改进都是应该基于数据的，这样更加理性。所以，我拿了一个小本子，记录自己每天的详细时间花费情况。于是就有了下图这样的一页一页的记录。</p>
<img src="/images/evernotes.jpg">
<p>这样大概记录了一周多，我基本上知道了自己的时间是如何花掉的了。然后，我开始归类自己的时间花费，看看主要花在了哪些地方。对于一些优先级不高的事情，我会注意调整它，不要让它把重要的事情给耽误了。</p>
<p>我也开始总结一个产品技术负责人的工作。在想得差不多了之后，我利用每周一早上和 CTO 的沟通机会进行讨论，最终，我完成了文章：<a href="/2015/12/18/from-dev-to-manager/">《涅槃重生:我的技术转管理之路》</a>，并且在北京架构师峰会上做了相应的技术转管理分享。</p>
<p>现在我不那么焦虑了，不过觉得自己还是需要多学习和提高。</p>
<h2 id="u56FE_u4E66_u51FA_u7248"><a href="#u56FE_u4E66_u51FA_u7248" class="headerlink" title="图书出版"></a>图书出版</h2><p><a href="http://item.jd.com/11598468.html" target="_blank" rel="external">《iOS 开发进阶》</a> 在 2015 年 1 月份顺利出版，然后首印 3000 册迅速卖掉了，出版社加印了 2000 册，然后过一周又卖光了，然后他们加印了 5000 册。之后又陆续有加印，最终到年底的时候，《iOS 开发进阶》销售了 17000 册，我听出版社老师说，这个成绩在技术图书里面是算相当好的。</p>
<img src="/images/ios_pro_17000.jpg">
<p>虽然称不上完美无缺，我个人对这本书的自评是问心无愧的。我用 Scrum 的管理方式来管理这本书的写作过程，我想在互联网时代，按时发布产品比什么都重要，所以，虽然有很多想继续完善的地方，我还是把它付印了。我也把写这本书的过程总结下来，完成了 <a href="/2015/01/11/how-to-finish-ios-pro-book/">《我是如何完成《iOS 开发进阶》的编写的》</a>，希望能给想出书的同行一些帮助。</p>
<p>由于我从一线 iOS 开发工作中脱离，《iOS 开发进阶》很可能不会再更新出第二版了，17000 册这个成绩，对于当时 30 岁的我来说，还算是一个不错的里程碑。这次写作让我感受到了出版的乐趣，其实我自己还在蕴量一些写作素材，或许以后会给大家一些新的分享。</p>
<h2 id="u5199_u4F5C"><a href="#u5199_u4F5C" class="headerlink" title="写作"></a>写作</h2><p>今年在博客上完成了 45 篇原创博客文章，差不多一周一篇的节奏。因为 iOS 开发做得少了，所以我的文章中涉及 iOS 开发技术细节的内容少了很多。</p>
<p>我仔细分析了一下今年的博客文章，内容涉及面很广。包括一些 iOS 开发方面的文章，如：</p>
<ul>
<li><a href="/2015/01/31/write-sdk-tips/">写 iOS SDK 注意事项</a></li>
<li><a href="/2015/03/15/ios-dev-controversy-1/">iOS 开发中的争议（一）</a></li>
<li><a href="/2015/03/22/ios-dev-controversy-2/">iOS 开发中的争议（二）</a></li>
<li><a href="/2015/11/02/mvc-and-mvvm/">被误解的 MVC 和被神化的 MVVM</a></li>
</ul>
<p>另外，我也向「娱乐记者」转变，采访了一些国内新出现的 iOS 大牛，以及报道一些行业新闻，比如</p>
<ul>
<li><a href="/2015/06/16/talk-about-swift-open-source/">谈谈苹果开源 Swift</a></li>
<li><a href="/2015/11/26/yykit-auther-interview/">专访 YYKit 作者 ibireme: 开源大牛是怎样炼成的</a></li>
</ul>
<p>我更不务正业地写起了硬件的评测：</p>
<ul>
<li><a href="/2015/06/28/apple-watch-usage-exp/">Apple Watch 使用体验</a></li>
</ul>
<p>当然，最离谱的就是我开始卖软件了，我和荔枝数码合作先后卖了 Reveal 和 Charles 两款 iOS 开发中需要的效率工具软件，也为此写了一些文章：</p>
<ul>
<li><a href="/2015/05/25/can-we-buy-time/">Reveal 中国特惠活动</a></li>
<li><a href="/2015/11/14/charles-introduction/">Charles 从入门到精通 (中国 5 折特惠)</a></li>
</ul>
<p>因为工作关系，我也开始总结自己的技术转管理收获，完成了：</p>
<ul>
<li><a href="/2015/10/25/one-on-one-summary/">浅析一对一沟通</a></li>
<li><a href="/2015/12/18/from-dev-to-manager/">涅槃重生:我的技术转管理之路</a></li>
</ul>
<p>在产品工作上面，总结了：</p>
<ul>
<li><a href="/2015/09/02/why-we-need-monitor-data/">数据的秘密（上）- 为什么要关注数据</a></li>
<li><a href="/2015/09/03/how-to-monitor-data/">数据的秘密（下）- 如何分析数据</a></li>
</ul>
<h2 id="u8BFB_u4E66"><a href="#u8BFB_u4E66" class="headerlink" title="读书"></a>读书</h2><p>另外，今年开始认真写读书笔记，完成了：</p>
<ul>
<li><a href="/2015/03/01/tipping-point/">《引爆点》读书心得</a></li>
<li><a href="/2015/04/04/from-0-to-1-book-summary/">《从 0 到 1 》读书笔记</a></li>
<li><a href="/2015/08/01/become-a-tech-leader-summary/">《成为技术领导者》读书心得</a></li>
<li><a href="/2015/08/02/the-story-of-success-book-summary/">《异类》读书心得</a></li>
<li><a href="/2015/08/22/reverse-book-summary/">《逆转》读书心得</a></li>
</ul>
<p>其实还看了一些别的书，包括《格鲁夫给经理人的第一课》、《增长黑客》、《领导梯队》等，但是都没有完成笔记，之后打算补上。</p>
<p>iOS 技术图书也看了不少，要说推荐，还是王巍的 <a href="https://selfstore.io/products/171" target="_blank" rel="external">《Swifter》</a> 和 Kevin 的 <a href="https://selfstore.io/products/367" target="_blank" rel="external">《Producter》</a> 。《Swifter》适合给新手入门用，《Producter》是一本跨界的书，适合 iOS 开发者用来开拓自己的眼界。</p>
<h2 id="u597D_u5947_u5FC3"><a href="#u597D_u5947_u5FC3" class="headerlink" title="好奇心"></a>好奇心</h2><p>2015 年我特别提醒自己要有好奇心，于是就做了很多有趣的事情。</p>
<p>比如，因为搬家和装修，我自己学习了换门锁、换马桶盖子、换马桶的上水管、组装板材家俱、在墙上钻孔这些技能，感觉还挺有意思的，有些时候就感觉在摆弄大号的积木玩具一样。</p>
<p>比如，因为对社群经济感兴趣，交了 1024 元加入了池建强和李笑来老师建的付费群。</p>
<p>比如，因为对 <a href="http://www.zaih.com/mentor/84802679/topic/29864843/" target="_blank" rel="external">「在行」</a> 这个 App 感兴趣，在上面接单，约见了五位朋友。</p>
<p>好奇心给我带来了极大的收获，比如池老师的那个付费群，我最终不但收获了不少有意思的分享，而且学习了当前社群的运作模式。在「在行」上接单不但收到了一些咨询费，更多的是认识了很多有趣的人，比如说罗飞。</p>
<p>如果要说好奇心给我带来的最大收获，那可能就是「iOS 开发」微信公众号的运营了。</p>
<p>从时间上看，我的「iOS 开发」微信公众号已经运营 3 年多了：</p>
<ul>
<li>2013 年 2 月 21 日，我开始在微信公众号里发表 iOS 开发相关内容。</li>
<li>2013 年 12 月累积发表了 140 条信息，累积了 5600 名粉丝。</li>
<li>2014 年 12 月累积了 1 万名粉丝。</li>
<li>2015 年 12 月累积了 3 万名粉丝。</li>
</ul>
<p>最主要的是，我原本没指望做这个事情有什么收获，但是从 2015 年起，开始有各种互联网企业找我投放广告。在这里感谢我的主要广告主：</p>
<ul>
<li><a href="https://www.upyun.com/zh/index.html" target="_blank" rel="external">UPYUN</a>：UPYUN 是国内领先的云服务提供商，专注于为开发者提供静态文件的云存储、云处理和 CDN 加速服务。</li>
<li><a href="http://100offer.com/" target="_blank" rel="external">100Offer</a>：用「拍卖」的方式来提供高端互联网人才招聘的网站。</li>
<li><a href="http://www.lagou.com/" target="_blank" rel="external">拉勾网</a>：最专业的互联网招聘平台，我自己就从上面招到了不少同事。</li>
<li><a href="http://www.infoq.com/cn" target="_blank" rel="external">InfoQ</a>：InfoQ 了提供中国最高质量的技术会议和技术文章，我自己也是 InfoQ 的社区编辑。现在 InfoQ 创始人 Kevin 把业务做得更广，成立了 <a href="http://www.geekbang.org/" target="_blank" rel="external">极客邦科技</a>，在极客邦科技之下，除了 InfoQ 之外，另外组建了高端技术人员社交网络 EGO、IT 职业学习平台 StuQ 和 企业培训服务 GIT。</li>
</ul>
<p>再次感谢你们，是你们让我这个自媒体有肉吃。</p>
<p>同时，我也要感谢我的读者，谢谢你们忍受偶尔出现的广告。我仔细算了一下，现在广告的频率是每月 2-3 次。你们放心，我会努力控制广告频率，如果控制不住，我就会涨价的！</p>
<h2 id="u672A_u6765_u7684_u8BA1_u5212"><a href="#u672A_u6765_u7684_u8BA1_u5212" class="headerlink" title="未来的计划"></a>未来的计划</h2><p>2016年，希望自己：</p>
<ul>
<li>每月至少完成一篇读书笔记。</li>
<li>每周坚持发至少一篇微信公众号文章。</li>
</ul>
<h2 id="u4E2A_u4EBA_Milestone"><a href="#u4E2A_u4EBA_Milestone" class="headerlink" title="个人 Milestone"></a>个人 Milestone</h2><ul>
<li>小猿搜题团队组建成功，并且获得 5000 万用户量。</li>
<li>「iOS 开发」微信公众号获得了 3 万粉丝，并开始有广告收入。</li>
</ul>
<!--

22 次

100 offer
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=444425913&idx=1&sn=edae69f061b7e963b626ff0564e0d55c#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=210036524&idx=1&sn=6ac23a8a4a518dac51bbf875da788df2#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209774617&idx=1&sn=f36182036013a89567bb150be29440d2#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209555090&idx=1&sn=64986a94516329f65be25166f7f05f39#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=204693407&idx=1&sn=53f7e05318aaad91e09ab8ff7043459b#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=204526037&idx=1&sn=f86643463659011430cd6bbf3538ca13#rd

lagou:
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=443546076&idx=1&sn=2fee1e70380a8c04e0b346a3fb36b3d9#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=440158123&idx=1&sn=9b0452fba8ab687b902cb3110846dbe4#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=400074920&idx=1&sn=cbfcdca750798cc16e92ff7997ed61fb#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209664745&idx=1&sn=eedfa5d8c5f7183997a22d06a4c3904e#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=208301774&idx=1&sn=adffaef537aff67f01db3992be796c89#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=206695843&idx=1&sn=2617a5966f347a98d6b9ef490f0292b4#rd

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=205584984&idx=1&sn=584e2913718833020cfd990465e3afe5#rd



infoQ:
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=421410076&idx=1&sn=8a6671aa72abfadb03cfb8f224523838#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=405922788&idx=1&sn=e1f2a1e5b4ccddd2f0b31eefdafd56ae#wechat_redirect

pgyer:

http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=420641198&idx=1&sn=f43c61cb451db72d4145fbaad089b8ba#rd 

BugTags:

http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209938150&idx=1&sn=4ff4715b21d88a384c747e098fa9c1aa#rd

UPYUN:
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209728624&idx=1&sn=1ab063924d3d8863c7c66a9f820e34c7#rd
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=208075893&idx=1&sn=09164a9954092d12ba2a5eb341cb857b#rd

丰厚资本:

 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209397391&idx=1&sn=8e9ff6100379bd289a901c4aec400e8e#rd

借贷宝:
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=209067756&idx=1&sn=396d17ec6f2aefc6547ae488719ff669#rd

理财工场:
 * http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=208847424&idx=2&sn=d26831cf3d4f41639c8fbf37ba662c55#rd

-->
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5173_u4E8E_u521B_u4E1A"><a href="#u5173_u4E8E_u521B_u4E1A" class="headerlink" title="关于创业"></a>关于创业</h2><p>今年猿题库顺利拿到了 D 轮 6000 万美元的]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[培训机构出来的 iOS 学员怎么了？]]></title>
    <link href="http://blog.devtang.com/2015/12/24/resume-cheat-story/"/>
    <id>http://blog.devtang.com/2015/12/24/resume-cheat-story/</id>
    <published>2015-12-24T14:23:45.000Z</published>
    <updated>2016-02-18T13:13:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E8B_u4EF6_u56DE_u653E"><a href="#u4E8B_u4EF6_u56DE_u653E" class="headerlink" title="事件回放"></a>事件回放</h2><p>前几天在 iOS 开发群里看到有人贴了一个 v2ex 上的帖子（地址： <a href="https://www.v2ex.com/t/244437" target="_blank" rel="external">https://www.v2ex.com/t/244437</a> ） ，大概说收到了 1000 多份某培训机构出来的学员简历。这些简历让他发现了一些问题：</p>
<ul>
<li>面试表现比较差</li>
<li>大多有伪造工作经历的行为</li>
</ul>
<p>以下是他的文章原文：</p>
<blockquote>
<p>公司坐标：杭州。 </p>
<p>由于公司业务发展，需要新招一位 iOS 开发工程师，这周 HR 平均每天给我安排了三场面试。 </p>
<p>一周过去了，这些面试者给我的印象都很糟糕，并且……很蹊跷，今天找 HR 了解了一下。 </p>
<p>结果出现了令我震惊的事情， HR 在「智联」「 51job 」「拉勾」三个渠道发布了招聘，半个月收到了超过一千份 iOS &gt; 简历，而同时招聘的其他技术岗位却很少有人投递简历。 </p>
<p>分析了一下这些简历的特征： </p>
<p>1.户籍绝大多数是某地（非地图炮，仅是数据统计） </p>
<p>2.几乎全部刚从外地来杭州 </p>
<p>3.几乎全部上家公司是外包公司 </p>
<p>4.很多人上家公司不一样，但简历中写的项目却是一样的 </p>
<p>5.简历上宣称的工作年限都是 1 年左右 </p>
<p>其实上面这几条，我都可以「理解」 </p>
<p>但是，这个数量着实让人震惊。 </p>
<p>我有一些推测，怕被喷，先不说了。 </p>
<p>你们怎么看?</p>
</blockquote>
<p>有人把这个问题贴到知乎上，引来了一些知情者的回复，见 <a href="https://www.zhihu.com/question/38703692" target="_blank" rel="external">https://www.zhihu.com/question/38703692</a> 。</p>
<p>原来这些都是培训机构出来的学员，然后为了获得一次面试，就编造了工作公司和经历，并且隐藏了自己的培训经历。</p>
<p>今天就想和大家聊聊这个沉重的话题。</p>
<h2 id="u8BDA_u4FE1_u7684_u6076_u6027_u5FAA_u73AF"><a href="#u8BDA_u4FE1_u7684_u6076_u6027_u5FAA_u73AF" class="headerlink" title="诚信的恶性循环"></a>诚信的恶性循环</h2><p>首先我们说说简历造假吧。在我看来，简历造假还是时常遇到的。我认识礼物说的 CTO，我们 iOS 群里常常有朋友面试时遇到说自己在礼物说工作过的候选人，为什么呢？还不是网上有一堆高仿礼物说的 APP，自己下载下来看看，然后就可以假装是自己做的了。</p>
<p>为什么很多候选人选择造假呢？除了简历不够好之外，造假很多时候确实有用。对于很多小公司来说，面试官自己也不懂如何面试 iOS 开发，那么就特别容易被忽悠。</p>
<p>但是，一个公司里面有 iOS 开发者，然后再稍微懂一些面试技巧的话，简历造假是很容易发现的。关于怎么在面试中鉴别造假，我们在下一节聊。</p>
<p>我们先聊聊看造假会造成什么危机呢？对于面试公司来说，如果他发现面试的效率特别低，或者招进来的人干活不行时，他会怎么办呢？</p>
<p>我觉得他会很直接地开地图炮，把一类人直接刷掉，不再给面试机会。这类人是哪些人？简历雷同的、培训机构培训出来的人。</p>
<p>这样公平吗？对候选人肯定不公平，但是公司招人也需要讲效率的，面试候选人其实成本特别高。</p>
<p>所以造假这个行为，最终伤害的是候选人本人，以及培训机构的信誉。</p>
<h2 id="u5982_u4F55_u5728_u9762_u8BD5_u4E2D_u9274_u522B_u9020_u5047"><a href="#u5982_u4F55_u5728_u9762_u8BD5_u4E2D_u9274_u522B_u9020_u5047" class="headerlink" title="如何在面试中鉴别造假"></a>如何在面试中鉴别造假</h2><p>其实挺简单的，首先面试的时候不要设置固定问题，然后根据候选人的回答情况来深入问细节。</p>
<p>就比如说一个候选人说他做过礼物说，那就有很多可以深入问的，比如问他：</p>
<ul>
<li>礼物说有几个 iOS 开发</li>
<li>大家是如何分工的</li>
<li>你负责的那块最主要的难点在哪里</li>
<li>团队整个协作的过程</li>
<li>在开发的时候有没有遇到需求变更</li>
<li>功能上线后大概的数据是什么样的</li>
<li>你觉得哪些地方还需要改进</li>
<li>你们主要的竞争对手是谁，他们在哪些技术方面比你们做得好</li>
</ul>
<p>一个谎话要编容易，难的是每一个细节都编得面面俱到，所以深入细节问，很容易就会露馅。</p>
<h2 id="u6211_u662F_u57F9_u8BAD_u673A_u6784_u5B66_u5458_u600E_u4E48_u529E"><a href="#u6211_u662F_u57F9_u8BAD_u673A_u6784_u5B66_u5458_u600E_u4E48_u529E" class="headerlink" title="我是培训机构学员怎么办"></a>我是培训机构学员怎么办</h2><p>简单地说，公司招一个人最终级的目的还是把活干好。如果一个培训机构的学员，没有实际的工作能力，单凭几个月的培训就想一劳永逸地找一份好工作，这是不现实的。</p>
<p>互联网技术日新月异，iOS 开发每年技术都在更新，如果指望所有知识都是从培训机构那儿获得，那么早晚都会被淘汰。</p>
<p>所以，即使你当前是培训机构出来的学员，也必须培养自己实际解决问题的能力和自学能力。这样才能一点点地增强自己的实力。</p>
<p>另外说一个残酷的现实，公司一般不会给你大块的上班时间用来学习新知识的。所以大多数学习充电过程只能是在下班后或周末。</p>
<h2 id="u6211_u4EEC_u5E94_u8BE5_u600E_u4E48_u770B_u5F85_u57F9_u8BAD_u673A_u6784_u5B66_u5458"><a href="#u6211_u4EEC_u5E94_u8BE5_u600E_u4E48_u770B_u5F85_u57F9_u8BAD_u673A_u6784_u5B66_u5458" class="headerlink" title="我们应该怎么看待培训机构学员"></a>我们应该怎么看待培训机构学员</h2><p>我自己就招过一个培训机构出来的学员，她还是一个女生，现在工作得挺棒的。她是非计算机专业毕业的，参加培训机构学了 3 个月就来我们公司面试。她能通过面试，很大程度上是因为她不止参加了培训班的课，而且自己在网上学习了计算机数据结构和算法的基础知识，而且是看的国外的课程。</p>
<p>当时面试时我完全没有考查她 iOS 知识，因为她承认只参加了 3 个月的培训。所以我考查了一下她自学数据结构和算法的情况。结果让我觉得她是一个自学能力还不错的女生，所以我就把她招了进来。</p>
<p>刚进来带她做 iOS 费了一些精力，但是很快她就可以上手自己做事情了。现在，我已经完全把小猿搜题的 iOS 端交给她来负责。我想她就是一个培训机构出来学员的成功案例。</p>
<p>我们并不鄙视培训机构的学生，但是我们不认同那些没有自学能力，认为参加 3 个月培训就可以拿高薪的「投机者」。这个行业虽然高薪，但是也很辛苦，如果没有兴趣和毅力，是没办法做好的。</p>
<h2 id="u641E_iOS__u5F00_u53D1_u5230_u5E95_u9700_u8981_u4EC0_u4E48_u6838_u5FC3_u80FD_u529B"><a href="#u641E_iOS__u5F00_u53D1_u5230_u5E95_u9700_u8981_u4EC0_u4E48_u6838_u5FC3_u80FD_u529B" class="headerlink" title="搞 iOS 开发到底需要什么核心能力"></a>搞 iOS 开发到底需要什么核心能力</h2><p>大家看了我上次<a href="/2015/11/26/yykit-auther-interview/">采访的 YYKit 作者的文章</a> 后，或许就能明白，其实一个人核心的能力就是学习能力。有强大的学习能力，那么就可以像 YYKit 作者那样，才接触 iOS 开发一年多就可以开源出大量优秀的作品。</p>
<p>基本上，一个人在一个领域坚持投入大量的时间，很难做得不好。所以你是一个培训机构的学员，苦于找不到工作。与其简历造假拿到面试机会，倒不如再多花花精力，自己多专研一些代码，写一些 App，不要那么急功近利，我想结果都会好很多。</p>
<p>愿培训机构出来的 iOS 学员都能找一份好工作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E8B_u4EF6_u56DE_u653E"><a href="#u4E8B_u4EF6_u56DE_u653E" class="headerlink" title="事件回放"></a>事件回放</h2><p>前几天在 iOS 开发群里看到有人贴了一个 v2]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[涅槃重生:我的技术转管理之路]]></title>
    <link href="http://blog.devtang.com/2015/12/18/from-dev-to-manager/"/>
    <id>http://blog.devtang.com/2015/12/18/from-dev-to-manager/</id>
    <published>2015-12-18T13:32:00.000Z</published>
    <updated>2016-02-27T15:16:19.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/from-dev-to-manager-1.jpg">
<h2 id="u4E00_u4E2A_u7A0B_u5E8F_u5458_u7684_u7406_u60F3"><a href="#u4E00_u4E2A_u7A0B_u5E8F_u5458_u7684_u7406_u60F3" class="headerlink" title="一个程序员的理想"></a>一个程序员的理想</h2><p>我从高中就开始接触计算机并开始编程，我非常喜欢编程，我一直以为我会写一辈子代码。</p>
<p>我从毕业就一直做技术，开始一年是做 Java 语言的服务器开发，开发过网易邮箱和微博的后台，后来转而做 iOS 开发。</p>
<p>因为喜欢，我几乎把我所有的非工作时间也投入到技术中去。当然，并非是把工作带回家，而是专研技术或者从事技术写作。</p>
<p>于是这几年，我积累了超过 150 篇原创技术文章，在 iOS 技术圈子里面也小有名气，也出版了一本《iOS 开发进阶》的书，微博和微信公众号的粉丝数也都超过了 3 万。</p>
<p>我做得很开心。</p>
<p>我一直以为，我会是一个好码农，我会一直在技术上深入下去。</p>
<p>但是，改变有些时候就是来得那么突然。</p>
<h2 id="u6D85_u69C3_u91CD_u751F"><a href="#u6D85_u69C3_u91CD_u751F" class="headerlink" title="涅槃重生"></a>涅槃重生</h2><p>我还记得那一天，2014 年 7 月 17 日，我当时受到邀请，在广州的微信分享 iOS 开发技术。当天晚上，我接到郭常圳（我们的 CTO）的电话，知道要做小猿搜题这个项目，并且这个项目「由我负责」。</p>
<p>于是，我开始了技术转管理之路。</p>
<p>通过从以前的项目组中抽调人手，小猿搜题这个产品技术团队很快组建出来了。我在开发 iOS 版的小猿搜题客户端的同时，也开始了我的管理工作。</p>
<p>现在经过了一年半，我们不但组建成了一支充满战斗力的团队，成收获了不小的成绩：</p>
<ul>
<li>小猿搜题产品一年时间获得了 5000 万的用户。</li>
<li>我们团队在开发上做到了每周一次迭代，两周一次版本发布。</li>
</ul>
<h2 id="u6280_u672F_u7BA1_u7406_u7684_u603B_u7ED3"><a href="#u6280_u672F_u7BA1_u7406_u7684_u603B_u7ED3" class="headerlink" title="技术管理的总结"></a>技术管理的总结</h2><p>在我的工作中，我慢慢总结出在创业公司中做技术管理工作的「方法论」。我把我的技术管理工作分成以下几个部分：管理业务，管理团队，管理技术。</p>
<h3 id="u7BA1_u7406_u4E1A_u52A1"><a href="#u7BA1_u7406_u4E1A_u52A1" class="headerlink" title="管理业务"></a>管理业务</h3><p>做为互联网公司，我们奉行简单直接的沟通，所以我很多时候并不需要涉及人员的管理工作，更多的时候是业务的管理工作。业务的管理工作主要是围绕着一个具体要做的技术开发功能点展开。具体包括：</p>
<ul>
<li>任务分解和分配</li>
<li>制定大概的开发排期</li>
<li>每天了解开发进度</li>
<li>讨论和跟进各种具体的技术问题</li>
<li>协调一些产品需求变更</li>
<li>响应一些市场同事的需求</li>
<li>跟进相关功能上线</li>
</ul>
<p>在这方面，我们主要是采用 <a href="https://www.scrum.org/" target="_blank" rel="external">Scrum</a> 的开发方式，见<a href="/2014/09/13/scrum-introduction/">《适合码农工作时玩的游戏：Scrum》</a>。</p>
<p>我们在整个迭代（Sprint）过程中引入四个会议：计划会议，每日站会，评审会议和回顾会议。通过事先简单的计划，再加上这四个会议中的详细讨论，我基本能够做到：</p>
<ul>
<li>通过计划会议：比较合理的安排开发排期、分配任务。</li>
<li>通过每日站会：每天了解开发进度，会后讨论和跟进各种具体的技术问题</li>
</ul>
<p>对于产品需求变更和市场同事需求的响应，我主要利用自己在 Sprint 执行过程中的时间来展开。我会根据当前需求的大小和紧迫程度，来决定是否插入到当前的 Sprint 中。如果插入到当前的 Sprint 工作量太大，我会适当做一些 Sprint 内容的调整。</p>
<p>跟进相关功能的上线主要是开发快要结束的时期，我会和产品同事一起试用最新的功能，了解 Bug 修复的进度，上线的风险情况。在大部分出现风险的情况下，我们都希望用适度加班的方式解决，所以我们上线当晚有时候会工作得比较晚。在无论如何都搞不定的情况下，我们可能会调整上线时间。</p>
<p>在业务涉及跨部门合作的时候，相关的进度管理会更麻烦一些。因为各部门自己的进度安排不一致，所以就会存在「等着联调」的情况。另外联调时出现问题也容易出现没人主动出来解决的情况。这些都需要负责人更频繁地沟通和推进，以保证按时上线。</p>
<p>在每周的工作中，我的管理业务的工作大概花费是 2 天左右。</p>
<h3 id="u7BA1_u7406_u56E2_u961F"><a href="#u7BA1_u7406_u56E2_u961F" class="headerlink" title="管理团队"></a>管理团队</h3><p>刚刚也说到，互联网公司不怎么需要管人，那么管理团队主要是做什么事情呢？我认为主要是两件事情：招人和带人，所谓的搭班子和带队伍。</p>
<h4 id="u62DB_u4EBA"><a href="#u62DB_u4EBA" class="headerlink" title="招人"></a>招人</h4><p>招聘这事情实在太重要了，所以必须要团队负责人参与。人才的招聘除了从公开的渠道收取简历、从猎头或同事那里得到推荐以外，还包括定向的找一些自己熟悉的前同事或某个领域的知名大牛，这些工作都是非常花费时间的。</p>
<p>在招人上，我们主要用到了找前同事，内部推荐发伯乐奖，以及进行技术分享和开源代码来获得社区影响力的方式。</p>
<p>值得一提的是，我们对于开源社区的贡献也得到了肯定，我们的基础架构组负责人陈恒因为多次为 Hbase 贡献代码，所以成为了 Hbase 的 Committer，而全中国拥有 Hbase 的 Committer 的公司在此之前只有三家，而且中国的 Hbase 的 Committer 不到 10 人。</p>
<p>在每周的工作中，招聘大概会占用我半天到一天的时间。</p>
<h4 id="u5E26_u4EBA"><a href="#u5E26_u4EBA" class="headerlink" title="带人"></a>带人</h4><p>人才招进来了，能否顺利融入团队，团队负责人以及这个人的导师（mentor）非常重要。需要做的事情包括：</p>
<ul>
<li>平时多交流沟通。</li>
<li>在新人遇到问题时，热心地解答。</li>
<li>引导新人熟悉公司的工作方式。</li>
</ul>
<p>一对一沟通来源于 Intel 公司，在最近很火的一本书 <a href="http://item.jd.com/11645500.html" target="_blank" rel="external">《创业维艰》</a> 中里面也提到过。《创业维艰》的作者本·霍洛维茨是被誉为「硅谷最牛的 50 个天使投资人」之一，先后在初期投资了 Facebook、Twitter、Groupon、Skype。</p>
<p>他在书中对一对一沟通介绍到，一对一沟通最主要的意义是：可以使得信息从下而上地传递。从而获得在其它渠道不易获得的信息，保证透明。</p>
<p>适合一对一沟通的内容有很多，包括：</p>
<ol>
<li>不成熟的看法</li>
<li>迫在眉睫的问题</li>
<li>精彩的想法</li>
<li>倾诉焦虑</li>
<li>抱怨</li>
</ol>
<p>这些内容都不适合在别的场景中出现，比如：不成熟的看法，如果在部门的正常会议或邮件中提出，会让人觉得未经过深思熟虑。又比如一些焦虑或抱怨，如果通过一些渠道宣泄给其他同事，其实也是不好的。一对一沟通让这些内容有了一个不错的出口。</p>
<p>5 年前我刚毕业加入网易有道的时候，我的老大，也是我现在创业公司的 CTO 郭常圳就开始和我做一对一沟通。我非常享受每次沟通的过程。现在我也开始和别人做一对一沟通，我也开始关注一对一沟通的技巧。我们认为最大的技巧是：作为管理者，要多听少说，让员工成为沟通的中心。郭常圳有一个特别「老土」的办法，就是：不主动说话。通过这种方式，强迫让员工选择他们想聊的话题。</p>
<p>在《创业维艰》一书中，也介绍了一些适合用来引导的问题：</p>
<ul>
<li>当前产品还有哪些可以提高的地方？</li>
<li>我们部门的最大问题是什么，为什么？</li>
<li>如果有，你觉得工作中有哪一点令你感觉不舒服？</li>
<li>你觉得谁的工作最优秀，为什么？</li>
<li>我们的产品哪方面不尽如人意？</li>
<li>我们错失的最大机遇是什么？</li>
<li>哪些是我们应该做而没有做的？</li>
<li>你自己希望未来在哪些方面能有提高？</li>
<li>有什么我能为你做的事情？</li>
</ul>
<p>我大概保持每个月和每个组内同事都有一次一对一沟通，有很多时候，我是通过「请他们吃饭」来完成的。一对一沟通需要一个舒适的环境，所以在咖啡厅或饭桌上，可能都比在办公室的效果要好一些。</p>
<p>一对一沟通的另一个核心要素是要坦诚，这就像 Scrum 指南中用「游戏规则」来描述内容一样，如果管理者做不到坦诚，那么同事就不会把这当作是一次有效的沟通机会。坦诚的沟通方式是：所有问题都真诚的回答，不掩饰问题，也不回避问题。如果沟通双方能够做到坦诚，即使是一个棘手的问题，那么双方也会从「解决问题」的角度，尽量寻找可能的办法。</p>
<p>除此之外，定期组织一些团队活动，让团队每个人之间建立友谊，也是我努力在做的。这在很多大公司是 HR 部门做的事情，在我们创业公司里面，也变成团队负责人的工作之一了。</p>
<h3 id="u4EC0_u4E48_u662F_u9886_u5BFC_u529B"><a href="#u4EC0_u4E48_u662F_u9886_u5BFC_u529B" class="headerlink" title="什么是领导力"></a>什么是领导力</h3><img src="/images/become-a-tech-leader-book.jpg">
<p>关于管理团队，我也特别喜欢《成为技术领导者》一书中的观点，关于本书，更多的请见<a href="/2015/08/01/become-a-tech-leader-summary/">《成为技术领导者》读书心得》</a>。书中是这么说的：</p>
<blockquote>
<p>所谓领导力，就是创造这样一个环境，每个人都能在其中发挥出更多的能力。</p>
</blockquote>
<p>我想：在强调平等、创新、自由的互联网公司里面，这可能就是领导力最好的定义吧。</p>
<h2 id="u7BA1_u7406_u6280_u672F"><a href="#u7BA1_u7406_u6280_u672F" class="headerlink" title="管理技术"></a>管理技术</h2><p>作为一个技术负责人，产品在技术上的架构是否合理？随着用户量的增长，现有架构能否胜任？当运营活动发生时，突发的流量会有多少，服务器是否能够承受住压力？未来技术上的架构应该如何演进？除了服务器端，客户端应该在哪些技术方案上投入研究力量？这些都是技术负责人需要考虑和决策的。</p>
<p>我同时做过服务器端和移动端的开发工作，不过由于最近几年都是做移动端的开发，所以服务器端的架构技术细节我其实并不是专家。所以我在这方面做得算不上很好。可能是运气好吧，有几次服务器的压力问题，我们都及时发现并且解决了，但是时间都挺紧迫的。现在，我会花时间把服务器端的架构图画出来，然后一块一块考虑，看看有没有更优的方案，并且和服务器端的同学讨论。</p>
<p>在客户端上，我只是对 iOS 开发比较熟悉，对 Android 了解得并不深入。所以我会让技术同学自己提一些技术改进方案，我参与 Review，我想他如果能说得有理有据，还是可以授权他在技术上深入的。</p>
<p>其实每个平台的技术管理可能都需要更多的「授权」，因为具体做事情的人，会比技术管理者更清楚地了解细节。而对细节的深入了解，才是改进技术架构的方案来源。所以，尽量招靠谱的人，那么在管理技术上的工作就只需要遵守「尽量授权」的原则来就可以了。</p>
<p>管理技术还包括公司技术氛围的建立，我主要在以下这些方面下了一些工夫：</p>
<ul>
<li>推进技术 wiki 的使用</li>
<li>推进 iOS 端每周一次的技术分享</li>
<li>推进 Code Review 以及代码质量</li>
</ul>
<p>Wiki 是一个非常好用的知识管理工具，前提是每个同事都参与贡献内容。所以作为一个管理者需要用言行来指导新同事学会用 Wiki。我会主动将重要内容记录在 wiki 上，对于一些同事发的邮件内容，我也会要求他整理到 wiki 上。</p>
<p>iOS 端的技术分享也是需要管理者推进的。我之前在网易有道的时候，这方面的活动基本上是大家自愿的方式来进行。这其实对分享者要求很高，一般的人很难达到这种意识，所以当时有道 iOS 端的技术分享很少。因此，我还是认为「半强制」的分享方式更适合当前团队。</p>
<p>「半强制」的分享规则需要大家认同，在一个相对轻松的环境下达成一致，为此我专门组织了一次交流会，大家相互认识一下，一顿吃喝之后，再约定分享规则。现在看起来，大家其实有很多想分享的内容，在 Wiki 上，很多一两个月才轮到他的人，都已经把分享的主题确定了。</p>
<p>Code Review 也是一个需要推动的事情，我们使用 Git 和 Gerrit，做到了所有的提交必须 review 通过之后，才能 merge 进代码仓库。另外我们也在 wiki 上规定了详细的代码风格要求。Code Review 如果做得好，不但可以在代码风格上达成一致，还能让新同事从中学习到一些良好的编程习惯，一些潜在的 Bug 也可能在 Code Review 中被发现，实在是值得坚持的事情。</p>
<h2 id="u4EA7_u54C1_u8D1F_u8D23_u4EBA"><a href="#u4EA7_u54C1_u8D1F_u8D23_u4EBA" class="headerlink" title="产品负责人"></a>产品负责人</h2><p>除了技术负责人的管理业务，管理团队，管理技术工作外，我另外还是小猿搜题的产品负责人，所以我还承担着技术负责人之外的一些工作。这些工作最主要的就是对产品的管理工作。</p>
<p>产品工作看似简单，实则复杂，而我作为一个工作多年的程序员，在这方面的经验非常少。所以我在参与产品讨论时，一开始都比较惶恐。后来我慢慢发现，产品经理的思维还是有章可循，便开始总结和学习，我看了不少产品经理的书，而郭常圳的多次指导也对我的帮忙意义巨大。其实做产品的原则就那么多，重要的还是多思考和体会，把那些原则融入自己的理解。</p>
<p>「场景化思维」是我学到的第一点，我还记得郭常圳带着我们学习乔布斯推出第一代 iPhone 时的演讲，乔布斯非常会讲故事，在用户具体的场景中介绍自己的产品。好的产品经理会将自己「代入」目标用户的使用场景中，解决用户的主要痛点和问题。做为技术人员，我常常陷入产品逻辑完备的泥潭中，但是「场景化思维」使得我能够重新跳出细节，关注主要功能设计是否合理。</p>
<p>「关注数据」是我学到的第二点，产品经理在打磨细节方面，如果能够关注产品数据，那么就很容易找到改进的方向，并且在后期验证自己的想法。关于这个，详细的请看：<a href="/2015/09/02/why-we-need-monitor-data/">数据的秘密（上）- 为什么要关注数据</a> 和 <a href="/2015/09/03/how-to-monitor-data/">数据的秘密（下）- 如何分析数据</a>。</p>
<p>我曾经犹豫自己是否应该学习写产品稿，郭常圳说不用，他说你只需要多看产品经理的产品稿，多思考和比较，慢慢就会有产品的感觉。我发现这一点还是管用的。以前用一个新的 App，作为开发者，我会关注它的功能在技术上如何实现，而我现在，不光会关注技术实现，还会想它的产品设计思路。打开了这扇窗户后，我就能在日常生活的每一天里，通过思考来提升自己的产品能力。</p>
<p>作为产品负责人，我主要的工作是参与产品稿的评审和美术稿的评审，同时会参与决定未来要做的功能，将其安排到产品工作中。另外，我也会关注产品的各项指标数据，保证重要的产品数据都是看过的。</p>
<p>我每周花在产品评审和美术评审大概是半天到一天，每周花在关注产品各项指标数据上的时间大概是半天到一天。</p>
<h2 id="u6211_u505A_u5F97_u4E0D_u597D_u7684_u5730_u65B9"><a href="#u6211_u505A_u5F97_u4E0D_u597D_u7684_u5730_u65B9" class="headerlink" title="我做得不好的地方"></a>我做得不好的地方</h2><p>做为一个技术转管理的新人，我觉得我的工作还是有挺多问题。</p>
<p>首先，我刚开始还是太迷恋技术了，有一些开发工作我仍然主动参与。但是实践之后发现，因为我的事情太多太杂，使得我很难保证自己承担的开发工作的进度。所以我现在学会主动把任务交给别人做，如果一件事情不是必须我才能做的，我就交给别人。所以现在技术上，我只参与 iOS 端的 Code Review 工作了。我将更多的精力，放在一些不得不由我做的沟通和项目推进方面的工作上。</p>
<p>接着，我有很长一段时间没能很好地安排好产品计划和研发的进度。好的产品计划应该要领先开发一个以上的迭代周期，这样在技术开发当前版本时，下一个版本功能就在设计和评审当中，使得大家的工作都不受影响。而小猿搜题的产品计划有一阵一直没能很舒服地领先技术，这让很多时候开发同事并不舒服。</p>
<p>解决的办法是我们让产品文档的完成时间点也尽量精准，对于一个大的产品功能设计，我们会定好初版（我们内部叫做 1 版本）、详细版（我们内部叫 5 版本）、完善版（我们内部叫 9 版本）的时间点。产品经理需要努力在时间点内保证产出，这样其实反倒使得大家会关注产品设计的主要问题，在细节上不过分纠结。</p>
<p>最后，我在招聘上的成绩也比较一般，没有能够为团队招来很多有经验的人，所以小猿搜题现有团队还是新人居多。新人的好处是容易和团队文化保持一致，但是在经验上，还是需要更多的锻炼。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>小猿搜题从 2014 年 7 月 17 日立项，到 10 月上线，再到元旦正式对外推广，到现在在不到一年的推广时间内，已经积累了超过 5000 万的用户。而我，也随着小猿搜题，从一个纯技术的 iOS 程序员，成长成为它的产品技术负责人，虽然也犯了一些错误，我感觉自己的进步还是很快的。</p>
<p>我也希望我的故事能够激励其他的技术同行，能够勇敢地接受新的挑战。在快速变化的移动互联网时代，快速迭代演进的不止有 App，也包括我们自己，愿大家都能活得精彩！</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/from-dev-to-manager-1.jpg">
<h2 id="u4E00_u4E2A_u7A0B_u5E8F_u5458_u7684_u7406_u60F3"><a href="#u4E00_u4E2A_u7A0B_u5E8F_u54]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[专访 YYKit 作者 ibireme: 开源大牛是怎样炼成的]]></title>
    <link href="http://blog.devtang.com/2015/11/26/yykit-auther-interview/"/>
    <id>http://blog.devtang.com/2015/11/26/yykit-auther-interview/</id>
    <published>2015-11-26T12:47:13.000Z</published>
    <updated>2016-02-27T15:17:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h3><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/news/2015/11/ibireme-interview" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h3 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h3><p>第一次听到 <a href="http://weibo.com/239801242" target="_blank" rel="external">ibireme</a> 这个名字，是看到他在 <a href="http://weibo.com/2477831984/D2ujxj5Vx?type=comment#_rnd1448528368875" target="_blank" rel="external">微博上分享</a> 了 <a href="https://github.com/ibireme/YYText" target="_blank" rel="external">YYText</a> 开源库。当时我第一眼见到 YYText 的功能示意 GIF 图时（下图所示），就被它丰富的功能吸引了。YYText 应该是我见到过的功能最强大的基于 CoreText 的排版框架了。</p>
<p><img src="https://camo.githubusercontent.com/fb454f77c109e6ac671e8fdb3220ade92238715b/68747470733a2f2f7261772e6769746875622e636f6d2f69626972656d652f5959546578742f6d61737465722f417474726962757465732f59595465787420457874656e6465642f5959546578744174746163686d656e742e676966" alt="YYText示意图"></p>
<p>令人惊讶的是，YYText 虽然代码量很大（超过一万行），但它只是 ibireme 的作品之一。ibireme 利用业余时间完成了 <a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYKit</a> 工具库，包括：</p>
<ul>
<li><a href="https://github.com/ibireme/YYModel" target="_blank" rel="external">YYModel</a> — 高性能的 iOS JSON 模型框架。</li>
<li><a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a> — 高性能的 iOS 缓存框架。</li>
<li><a href="https://github.com/ibireme/YYImage" target="_blank" rel="external">YYImage</a> — 功能强大的 iOS 图像框架。</li>
<li><a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="external">YYWebImage</a> — 高性能的 iOS 异步图像加载框架。</li>
<li><a href="https://github.com/ibireme/YYText" target="_blank" rel="external">YYText</a> — 功能强大的 iOS 富文本框架。</li>
<li><a href="https://github.com/ibireme/YYKeyboardManager" target="_blank" rel="external">YYKeyboardManager</a> — iOS 键盘监听管理工具。</li>
<li><a href="https://github.com/ibireme/YYDispatchQueuePool" target="_blank" rel="external">YYDispatchQueuePool</a> — iOS 全局并发队列管理工具。</li>
<li><a href="https://github.com/ibireme/YYAsyncLayer" target="_blank" rel="external">YYAsyncLayer</a> — iOS 异步绘制与显示的工具。</li>
<li><a href="https://github.com/ibireme/YYCategories" target="_blank" rel="external">YYCategories</a> — 功能丰富的 Category 类型工具库。</li>
</ul>
<p>我和一些朋友挑选了一些其中的组件代码阅读，大家都认为质量非常高，大家对它的评语是这样的：</p>
<blockquote>
<p>打算自己撸一个 JSON 转 model 的，专门看了 YYModel 的代码，果然屌。</p>
<p>YYKit 超级好用。 </p>
<p>对比一下，感觉自己一年都没写代码。</p>
<p>怎么会有如此完美的工程师？真想抽一周时间宅在家里把 YYKit 的源码重敲一遍。</p>
</blockquote>
<p>之后我抽空学习了一下 ibireme 的博客（<a href="http://blog.ibireme.com/" target="_blank" rel="external">http://blog.ibireme.com/</a>），上面有多篇介绍他对于 iOS 开发中各种问题的研究，例如他在开发 YYModel 时，<a href="http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/" target="_blank" rel="external">调研和评测</a> 了包括 Mantle 和 MJExtension 在内的多款开源库。这种专业认真的做事态度让我非常佩服，也让我对 YYModel 的质量充满信心。</p>
<p>然后，我有幸得到了 ibireme 的 QQ 和微信号，所以和他交流了多次。这时我才知道 ibireme 是一个 90 后，在优酷从事 iOS 开发工作。而这些所有的开源库，都是他在业余时间完成的。</p>
<p>我想大家很可能对 ibireme 的学习和成长的经历感兴趣，而且 ibireme 的故事很可能会激励更多有激情的 iOS 开发新人，利用业余时间学习、Coding 和分享，最终让国内的 iOS 开发技术氛围更好。所以，我向 ibireme 发出了采访邀请，ibireme 欣然接受了。于是，让我们来一起揭开这位神秘人物的面纱吧。</p>
<h3 id="u91C7_u8BBF"><a href="#u91C7_u8BBF" class="headerlink" title="采访"></a>采访</h3><blockquote>
<p>唐巧：你好 ibireme，能否先向读者简单介绍一下自己？</p>
</blockquote>
<p>ibireme：大家好，我叫郭曜源，是一个 iOS 开发者，现居北京，就职于优酷土豆。喜欢代码，爱好设计与音乐。</p>
<blockquote>
<p>唐巧：我发现 YYKit 是在这个月初上传到 github 上的，但是它的代码量非常大，能否介绍一下每个部分大概花了你多长时间？</p>
</blockquote>
<p>ibireme：Category 等工具类大部分都是这一两年工作和业余时间攒下来的。文本和图片相关的那几个项目是今年年初开始写起的，陆陆续续写了半年多。YYModel 花的时间最少，只有大概两个周末。</p>
<blockquote>
<p>唐巧：为什么选择一次性开源这么多代码，而不是一个一个开源呢？</p>
</blockquote>
<p>ibireme：最初这些代码我都是写在一个工程里，代码量比较多，相互之间也有很多依赖。准备发布时，我觉得这样很不方便别人使用，这才按功能拆开成一个个小的组件，然后一起发布的。</p>
<blockquote>
<p>唐巧：这些开源库在国内外都收到了大量的好评，这个有没有超出你的预期？</p>
</blockquote>
<p>ibireme：发布前我有预期会收到不少关注，但是发布后收到的好评还是大大超出我的预料。最令我惊讶的是 Facebook 和 Uber 等国外的工程师也关注到这个项目，并且还以此向我发出了工作邀请，这让我非常激动。</p>
<blockquote>
<p>唐巧：你对 YYKit 后续的发展上有什么计划吗？</p>
</blockquote>
<p>ibireme：现在只是计划进行一些正常的维护工作，保证稳定性。未来如果有合适的东西，我也会尝试加到里面的，但应该不会有太大改变了。</p>
<blockquote>
<p>唐巧：YYKit 是你的业余作品，我很好奇你是如何保证工作之余还有这么高产的？</p>
</blockquote>
<p>ibireme：最近一年我工作不太忙，很少加班，空闲时间比较多。另外我比较宅，平时喜欢待在家里做一些喜欢的事情。说起来，应该是充足的时间加上个人兴趣让我完成了这些项目吧。</p>
<blockquote>
<p>唐巧：你如何看待 Swift 语言，有没有计划过用 Swift 重写你的 YYKit？</p>
</blockquote>
<p>ibireme：相对于 Objective-C 来说，我觉得 Swift 无疑是更优秀、更现代的语言。目前我对 Swift 研究并不多，工作中也没有用到，但未来我会把时间更多投入到 Swift 中去。YYKit 中不少东西更适合于 C/Objective-C，所以我没有计划用 Swift 重写整个项目。我可能会用 Swift 写一些新的东西，以充分发挥 Swift 的特性。</p>
<blockquote>
<p>唐巧：你在 iOS 开发上是如何快速成长起来的？有没有什么心得可以分享给 iOS 开发新手？</p>
</blockquote>
<p>ibireme：我接触 iOS 开发的时间很早，但是一直都是在工作之余靠着兴趣自学的。14 年我还在人人网时，部门内部有个新项目需要 iOS 开发，我才得以有机会在工作中使用 iOS 相关的技术。全职转为 iOS 开发后，我花费了大量的时间阅读和学习各种开源的代码、研究其中的实现原理、尝试自己实现相关技术、尝试在工作中使用，这使得我在 iOS 开发技术上进步很快。对于 iOS 开发来说，我觉得自学能力是很重要的。主动去研究一些优秀的开源项目、多在工作中实践和学习，这样就能逐步提升个人技术水平了。</p>
<blockquote>
<p>唐巧：你觉得哪些开发者对你影响最大？</p>
</blockquote>
<p>ibireme：可能平时我更喜欢看代码，对于开发者我倒是了解的不多吧。如果要选一位的话，我会选 Linus Torvalds。他的一句话我很喜欢：”Talk is cheap, show me the code”。</p>
<blockquote>
<p>唐巧：在技术领域，你对未来有什么学习规划吗？</p>
</blockquote>
<p>ibireme：在 iOS 方面，我可能会针对 Swift、音频处理和合成等方面投入更多精力。另外我第一份工作是 Java 后台开发，工作时前后端、数据库相关的东西也都接触过，所以如果有时间的话我也会继续学习这些技术，即使不用在工作上，也能开拓眼界吧。</p>
<h3 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h3><p>刚刚 ibireme 在介绍自己学习方法的时候，提到了两点我认为非常关键，一个就是大量地阅读优秀项目的源代码，另一个就是自己动手实践来尝试。</p>
<p>我在很久以前，分享过我认为 iOS 开发者可以提高自己能力的各种方法，见 <a href="/2014/07/27/ios-levelup-tips/">《iOS 开发如何提高》</a>，里面也提到阅读开源代码和多写代码。我感觉 ibireme 将这一点做到了极致，因此他在短短一年多的时间，就能够成长成为在业界有影响力的开源项目作者。</p>
<p>我们处在一个信息爆炸的时代，每一天都有大量的 iOS 开发文章出现，我们对这些文章如饥似渴，但是很多时候又浅尝辄止。像 ibireme 这样，专心阅读几个开源项目，然后自己动手真正实践，或许才是正确的学习方式。</p>
<p>希望 ibireme 的故事能够激励那些渴望成长成为牛人的 iOS 开发新人，也希望在中国能够出现更多像 YYKit 这样的优秀的开源项目，与大家共勉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h3><p>本文为 InfoQ 中文站特供稿件，首发地址为：]]>
    </summary>
    
      <category term="Interview" scheme="http://blog.devtang.com/tags/Interview/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac 应用出现「已损坏」问题，苹果到底犯了什么傻逼错误？]]></title>
    <link href="http://blog.devtang.com/2015/11/21/apps-damaged-bug/"/>
    <id>http://blog.devtang.com/2015/11/21/apps-damaged-bug/</id>
    <published>2015-11-21T14:22:42.000Z</published>
    <updated>2016-02-16T10:26:44.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/apps-damaged-issue.jpg">
<h2 id="u4E8B_u4EF6_u56DE_u987E"><a href="#u4E8B_u4EF6_u56DE_u987E" class="headerlink" title="事件回顾"></a>事件回顾</h2><p>据国外多名网友反映，从 11 月 13 号开始，打开一些 Mac App Store 中下载的软件时，会出现 “已损坏”（Damaged）的提示。受此问题影响的软件较多，包括广为人知的 1Password、Dash、Byword 和 Tweetbot 等。Tweetbot 开发者 Paul Haddad 在 Twitter 上表示这个问题看起来与认证证书到期有关，并猜想目前证书使用 SHA256 加密，或许会和 OS X 老版本不兼容。</p>
<h2 id="u95EE_u9898_u539F_u56E0"><a href="#u95EE_u9898_u539F_u56E0" class="headerlink" title="问题原因"></a>问题原因</h2><p>微博上的 <a href="http://weibo.com/u/1713195262" target="_blank" rel="external">@webfrogs</a> 分享的<a href="http://m.imore.com/heres-whats-happening-mac-app-store-and-damaged-apps" target="_blank" rel="external">这篇文章</a>中详细解答了这个问题产生的原因。我仔细读了一下，给大家分享一下。</p>
<p>每一个 Mac AppStore 下载的软件都有一个证书，证明该软件是合法购买并且没有被篡改的。在以前，该证书是通过 SHA-1 来进行散列验证的，<a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F" target="_blank" rel="external">SHA-1</a> 是一种类似 MD5 的散列算法，比 MD5 更安全，但是计算起来更耗费 CPU 。</p>
<p>最近，苹果更改了证书的算法，使用 SHA-2 来进行散列验证的。这本来应该是对用户透明的，但是，苹果的质量部门却没有发现这个大 Bug。于是影响了大范围的用户。</p>
<p>具体影响的过程是：</p>
<ol>
<li>首先，过期的证书在缓存中没有被清除，系统会要求用户重启来清除证书或重新获得新证书。</li>
<li>然后，一些应用明显地使用的是旧版的 OpenSSL 来验证购买凭证，然后你猜怎么着？旧版的 OpenSSL 不！支！持！SHA-2 算法！</li>
</ol>
<p>由此我们就可以知道应该如何解决该问题了：</p>
<p>方案一：类似 XcodeGhost 事件那样，可以将那些使用旧版 OpenSSL 应用被苹果下架，要求它们升级到最新版的 OpenSSL，但是这个至少需要几天时间。</p>
<p>方案二：苹果将算法退回到 SHA-1。</p>
<p>于是，在愤怒的用户面前，苹果想了想，还是怂了，将算法退回（Roll back）到了 SHA-1。当然，想必他也会要求以后的应用必须使用新的 OpenSSL 库，然后确保没问题后再升级加密算法。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结起来就是：苹果傻逼了，搞了一个大 bug，然后自己回退代码了。这次事故苹果的质量保证部门应该犯有不可推卸的责任。</p>
<p>另外，我居然没受影响，原因是我没有升级 OS X 到最新版，所以逃过了一劫。不过我的一些搞 iOS 开发的小伙们可惨了，好多人挨个把软件重新下载了一遍。</p>
<p>乔布斯离世之后，苹果的软件质量变得越来越不稳定，加上创业太累，这让我这个不喜欢折腾的人越发喜欢等大家测试稳定之后再升级，希望这是我的错觉吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/apps-damaged-issue.jpg">
<h2 id="u4E8B_u4EF6_u56DE_u987E"><a href="#u4E8B_u4EF6_u56DE_u987E" class="headerlink" title="事件回]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Charles 从入门到精通]]></title>
    <link href="http://blog.devtang.com/2015/11/14/charles-introduction/"/>
    <id>http://blog.devtang.com/2015/11/14/charles-introduction/</id>
    <published>2015-11-14T04:00:47.000Z</published>
    <updated>2016-02-16T10:28:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h2><p>本文的内容主要包括：</p>
<ul>
<li>Charles 的简介</li>
<li>如何安装 Charles</li>
<li>将 Charles 设置成系统代理</li>
<li>Charles 主界面介绍</li>
<li>过滤网络请求</li>
<li>截取 iPhone 上的网络封包</li>
<li>截取 Https 通讯信息</li>
<li>模拟慢速网络</li>
<li>修改网络请求内容</li>
<li>给服务器做压力测试</li>
<li>修改服务器返回内容</li>
<li>总结</li>
</ul>
<!--
## Charles 中国特惠

Charles 正版[五折优惠活动](http://item.taobao.com/item.htm?&id=524230901640)（限时：2015 年 11 月 14 日 - 30 日），仅限中国区购买，[点击购买](http://item.taobao.com/item.htm?&id=524230901640)。在活动期结束后，价格将从 169 元上涨到 199 元。
-->
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><img src="/images/charles-logo.png">
<p><a href="http://www.charlesproxy.com/" target="_blank" rel="external">Charles</a> 是在 Mac 下常用的网络封包截取工具，在做<br>移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。</p>
<p>Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p>
<p>除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。</p>
<p>Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。</p>
<p>Charles 主要的功能包括：</p>
<ol>
<li>截取 Http 和 Https 网络封包。</li>
<li>支持重发网络请求，方便后端调试。</li>
<li>支持修改网络请求参数。</li>
<li>支持网络请求的截获并动态修改。</li>
<li>支持模拟慢速网络。</li>
</ol>
<h2 id="u5B89_u88C5_Charles"><a href="#u5B89_u88C5_Charles" class="headerlink" title="安装 Charles"></a>安装 Charles</h2><p>去 Charles 的官方网站（<a href="http://www.charlesproxy.com" target="_blank" rel="external">http://www.charlesproxy.com</a>）下载最新版的 Charles 安装包，是一个 dmg 后缀的文件。打开后将 Charles 拖到 Application 目录下即完成安装。</p>
<h2 id="u5C06_Charles__u8BBE_u7F6E_u6210_u7CFB_u7EDF_u4EE3_u7406"><a href="#u5C06_Charles__u8BBE_u7F6E_u6210_u7CFB_u7EDF_u4EE3_u7406" class="headerlink" title="将 Charles 设置成系统代理"></a>将 Charles 设置成系统代理</h2><p>之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。</p>
<p>启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” -&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示：</p>
<img src="/images/charles-pro-3.png">
<p>之后，你就可以看到源源不断的网络请求出现在 Charles 的界面中。</p>
<p>需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 <code>127.0.0.1:8888</code> 也可达到相同效果。</p>
<h2 id="Charles__u4E3B_u754C_u9762_u4ECB_u7ECD"><a href="#Charles__u4E3B_u754C_u9762_u4ECB_u7ECD" class="headerlink" title="Charles 主界面介绍"></a>Charles 主界面介绍</h2><img src="/images/charles-pro-4.png">
<p>Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。 </p>
<ol>
<li>Structure 视图将网络请求按访问的域名分类。</li>
<li>Sequence 视图将网络请求按访问的时间排序。</li>
</ol>
<p>大家可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 Filter 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。</p>
<p>对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。</p>
<h2 id="u8FC7_u6EE4_u7F51_u7EDC_u8BF7_u6C42"><a href="#u8FC7_u6EE4_u7F51_u7EDC_u8BF7_u6C42" class="headerlink" title="过滤网络请求"></a>过滤网络请求</h2><p>通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，以下几种办法：</p>
<p>方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：<code>http://yuantiku.com</code> , 那么只需要在 Filter 栏中填入 yuantiku 即可。</p>
<p>方法二：在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：</p>
<img src="/images/charles-filter-setting.jpg">
<p>通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。</p>
<p>方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示：</p>
<img src="/images/charles-focus.png">
<p>这种方式可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。</p>
<h2 id="u622A_u53D6_iPhone__u4E0A_u7684_u7F51_u7EDC_u5C01_u5305"><a href="#u622A_u53D6_iPhone__u4E0A_u7684_u7F51_u7EDC_u5C01_u5305" class="headerlink" title="截取 iPhone 上的网络封包"></a>截取 iPhone 上的网络封包</h2><p>Charles 通常用来截取本地上的网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。</p>
<h3 id="Charles__u4E0A_u7684_u8BBE_u7F6E"><a href="#Charles__u4E0A_u7684_u8BBE_u7F6E" class="headerlink" title="Charles 上的设置"></a>Charles 上的设置</h3><p>要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示:</p>
<img src="/images/charles-proxy-setting.jpg">
<h3 id="iPhone__u4E0A_u7684_u8BBE_u7F6E"><a href="#iPhone__u4E0A_u7684_u8BBE_u7F6E" class="headerlink" title="iPhone 上的设置"></a>iPhone 上的设置</h3><p>首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示：</p>
<img src="/images/charles-local-ip.png">
<p>在 iPhone 的 “ 设置 “-&gt;” 无线局域网 “ 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图所示：</p>
<img src="/images/charles-iphone-setting.jpg">
<p>设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单（如下图所示），点击 “Allow” 即可完成设置。</p>
<img src="/images/charles-proxy-confirm.jpg">
<h2 id="u622A_u53D6_Https__u901A_u8BAF_u4FE1_u606F"><a href="#u622A_u53D6_Https__u901A_u8BAF_u4FE1_u606F" class="headerlink" title="截取 Https 通讯信息"></a>截取 Https 通讯信息</h2><h3 id="u5B89_u88C5_u8BC1_u4E66"><a href="#u5B89_u88C5_u8BC1_u4E66" class="headerlink" title="安装证书"></a>安装证书</h3><p>如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。</p>
<p>首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图所示：</p>
<img src="/images/charles-pro-1.png">
<p>需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 SSL proxy，如下图所示：</p>
<img src="/images/charles-ssl-add-host.jpg">
<p>这样，对于该 Host 的所有 SSL 请求可以被截取到了。</p>
<h3 id="u622A_u53D6_u79FB_u52A8_u8BBE_u5907_u4E2D_u7684_Https__u901A_u8BAF_u4FE1_u606F"><a href="#u622A_u53D6_u79FB_u52A8_u8BBE_u5907_u4E2D_u7684_Https__u901A_u8BAF_u4FE1_u606F" class="headerlink" title="截取移动设备中的 Https 通讯信息"></a>截取移动设备中的 Https 通讯信息</h3><p>如果我们需要在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。如下图所示：</p>
<img src="/images/charles-pro-2.png">
<p>按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：<a href="http://charlesproxy.com/getssl" target="_blank" rel="external">http://charlesproxy.com/getssl</a>，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。</p>
<h2 id="u6A21_u62DF_u6162_u901F_u7F51_u7EDC"><a href="#u6A21_u62DF_u6162_u901F_u7F51_u7EDC" class="headerlink" title="模拟慢速网络"></a>模拟慢速网络</h2><p>在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。</p>
<p>在 Charles 的菜单上，选择 “Proxy”-&gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示：</p>
<img src="/images/charles-throttle-setting.jpg">
<p>如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。</p>
<h2 id="u4FEE_u6539_u7F51_u7EDC_u8BF7_u6C42_u5185_u5BB9"><a href="#u4FEE_u6539_u7F51_u7EDC_u8BF7_u6C42_u5185_u5BB9" class="headerlink" title="修改网络请求内容"></a>修改网络请求内容</h2><p>有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下所示：</p>
<img src="/images/charles-edit.png">
<p>我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图所示）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如下图所示：</p>
<img src="/images/charles-execute.png">
<h2 id="u7ED9_u670D_u52A1_u5668_u505A_u538B_u529B_u6D4B_u8BD5"><a href="#u7ED9_u670D_u52A1_u5668_u505A_u538B_u529B_u6D4B_u8BD5" class="headerlink" title="给服务器做压力测试"></a>给服务器做压力测试</h2><p>我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。</p>
<p>我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示：</p>
<img src="/images/charles-repeat-1.png">
<p>接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。</p>
<img src="/images/charles-repeat-2.png">
<p>悄悄说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也拿 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据，上次不小心还把一个钓鱼网站的数据库打挂了，嗯，请叫我雷锋。</p>
<h2 id="u4FEE_u6539_u670D_u52A1_u5668_u8FD4_u56DE_u5185_u5BB9"><a href="#u4FEE_u6539_u670D_u52A1_u5668_u8FD4_u56DE_u5185_u5BB9" class="headerlink" title="修改服务器返回内容"></a>修改服务器返回内容</h2><p>有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。</p>
<p>根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是：</p>
<ol>
<li>Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。</li>
<li>Rewrite 功能适合对网络请求进行一些正则替换。</li>
<li>Breakpoints 功能适合做一些临时性的修改。</li>
</ol>
<h3 id="Map__u529F_u80FD"><a href="#Map__u529F_u80FD" class="headerlink" title="Map 功能"></a>Map 功能</h3><p>Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。</p>
<p>在 Charles 的菜单中，选择 “Tools”-&gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。</p>
<img src="/images/charles-map.png">
<p>对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 <code>ytk1.yuanku.ws</code>（测试服务器）的请求重定向到了 <code>www.yuantiku.com</code>（线上服务器）。</p>
<img src="/images/charles-map-remote.png">
<p>对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图所示），然后稍加修改，成为我们的目标映射文件。</p>
<img src="/images/charles-save-response.png">
<p>下图是一个示例，我将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。</p>
<img src="/images/charles-map-local.png">
<h3 id="Rewrite__u529F_u80FD"><a href="#Rewrite__u529F_u80FD" class="headerlink" title="Rewrite 功能"></a>Rewrite 功能</h3><p>Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。</p>
<p>例如，我们的客户端有一个 API 请求是获得用户昵称，而我当前的昵称是 “tangqiaoboy”，如下所示：</p>
<img src="/images/charles-rewrite-1.jpeg">
<p>我们想试着直接修改网络返回值，将 tangqiaoboy 换成成 iosboy。于是我们启用 Rewrite 功能，然后设置如下的规则：</p>
<img src="/images/charles-rewrite-2.png">
<p>完成设置之后，我们就可以从 Charles 中看到，之后的 API 获得的昵称被自动 Rewrite 成了 iosboy，如下图所示：</p>
<img src="/images/charles-rewrite-3.png">
<h3 id="Breakpoints__u529F_u80FD"><a href="#Breakpoints__u529F_u80FD" class="headerlink" title="Breakpoints 功能"></a>Breakpoints 功能</h3><p>上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。</p>
<p>Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。</p>
<p>下图是我们临时修改获取用户信息的 API，将用户的昵称进行了更改，修改完成后点击 “Execute” 则可以让网络请求继续进行。</p>
<img src="/images/charles-breakpoint.png">
<p>需要注意的是，使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>通过 Charles 软件，我们可以很方便地在日常开发中，截取和调试网络请求内容，分析封包协议以及模拟慢速网络。用好 Charles 可以极大的方便我们对于带有网络请求的 App 的开发和调试。</p>
<p>愿本文帮助大家成为 Charles 的专家，祝大家玩得开心～</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h2><p>本文的内容主要包括：</p>
<ul>
<li>Charles 的简介</li>
<li>如何安装 Ch]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[被误解的 MVC 和被神化的 MVVM]]></title>
    <link href="http://blog.devtang.com/2015/11/02/mvc-and-mvvm/"/>
    <id>http://blog.devtang.com/2015/11/02/mvc-and-mvvm/</id>
    <published>2015-11-02T14:06:39.000Z</published>
    <updated>2016-02-27T01:33:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u88AB_u8BEF_u89E3_u7684_MVC"><a href="#u88AB_u8BEF_u89E3_u7684_MVC" class="headerlink" title="被误解的 MVC"></a>被误解的 MVC</h1><h2 id="MVC__u7684_u5386_u53F2"><a href="#MVC__u7684_u5386_u53F2" class="headerlink" title="MVC 的历史"></a>MVC 的历史</h2><p><a href="http://baike.baidu.com/view/5432454.htm" target="_blank" rel="external">MVC</a>，全称是 Model View Controller，是模型 (model)－视图 (view)－控制器 (controller) 的缩写。它表示的是一种常见的客户端软件开发框架。</p>
<p>MVC 的概念最早出现在二十世纪八十年代的 <a href="http://baike.baidu.com/view/616837.htm" target="_blank" rel="external">施乐帕克</a> 实验室中（对，就是那个发明图形用户界面和鼠标的实验室），当时施乐帕克为 Smalltalk 发明了这种软件设计模式。</p>
<p>现在，MVC 已经成为主流的客户端编程框架，在 iOS 开发中，系统为我们实现好了公共的视图类：UIView，和控制器类：UIViewController。大多数时候，我们都需要继承这些类来实现我们的程序逻辑，因此，我们几乎逃避不开 MVC 这种设计模式。</p>
<p>但是，几十年过去了，我们对于 MVC 这种设计模式真的用得好吗？其实不是的，MVC 这种分层方式虽然清楚，但是如果使用不当，很可能让大量代码都集中在 Controller 之中，让 MVC 模式变成了 Massive View Controller 模式。</p>
<h2 id="Controller__u7684_u81C3_u80BF_u95EE_u9898_u4F55_u89E3_uFF1F"><a href="#Controller__u7684_u81C3_u80BF_u95EE_u9898_u4F55_u89E3_uFF1F" class="headerlink" title="Controller 的臃肿问题何解？"></a>Controller 的臃肿问题何解？</h2><p>很多人试图解决 MVC 这种架构下 Controller 比较臃肿的问题。我还记得半年前 InfoQ 搞了一次<a href="http://www.infoq.com/cn/news/2015/04/symposium-web-mvc" target="_blank" rel="external">移动座谈会</a>，当时 <a href="https://github.com/gavinkwoe/BeeFramework" target="_blank" rel="external">BeeFramework</a> 和 <a href="https://github.com/hackers-painters/samurai-native" target="_blank" rel="external">Samurai-Native</a> 的作者 <a href="http://weibo.com/gavinkwoe" target="_blank" rel="external">老郭</a> 问了我一句话：「什么样的内容才应该放到 Controller 中？」。但是当时因为时间不够，我没能展开我的观点，这次正好在这里好好谈谈我对于这个问题的想法。</p>
<p>我们来看看 MVC 这种架构的特点。其实设计模式很多时候是为了 <code>Don&#39;t repeat yourself</code> 原则来做的，该原则要求能够复用的代码要尽量复用，来保证重用。在 MVC 这种设计模式中，我们发现 View 和 Model 都是符合这种原则的。</p>
<p>对于 View 来说，你如果抽象得好，那么一个 App 的动画效果可以很方便地移植到别的 App 上，而 Github 上也有很多 UI 控件，这些控件都是在 View 层做了很好的封装设计，使得它能够方便地开源给大家复用。</p>
<p>对于 Model 来说，它其实是用来存储业务的数据的，如果做得好，它也可以方便地复用。比如我当时在做有道云笔记 iPad 版的时候，我们就直接和 iOS 版复用了所有的 Model 层的代码。在创业做猿题库客户端时，iOS 和 iPad 版的 Model 层代码再次被复用上了。当然，因为和业务本身的数据意义相关，Model 层的复用大多数是在一个产品内部，不太可能像 View 层那样开源给社区。</p>
<p>说完 View 和 Model 了，那我们想想 Controller，Controller 有多少可以复用的？我们写完了一个 Controller 之后，可以很方便地复用它吗？结论是：非常难复用。在某些场景下，我们可能可以用 <code>addSubViewController</code> 之类的方式复用 Controller，但它的复用场景还是非常非常少的。</p>
<p>如果我们能够意识到 Controller 里面的代码不便于复用，我们就能知道什么代码应该写在 Controller 里面了，那就是那些不能复用的代码。在我看来，Controller 里面就只应该存放这些不能复用的代码，这些代码包括：</p>
<ul>
<li>在初始化时，构造相应的 View 和 Model。</li>
<li>监听 Model 层的事件，将 Model 层的数据传递到 View 层。</li>
<li>监听 View 层的事件，并且将 View 层的事件转发到 Model 层。</li>
</ul>
<p>如果 Controller 只有以上的这些代码，那么它的逻辑将非常简单，而且也会非常短。</p>
<p>但是，我们却很难做到这一点，因为还是有很多逻辑我们不知道写在哪里，于是就都写到了 Controller 中了，那我们接下来就看看其它逻辑应该写在哪里。</p>
<h2 id="u5982_u4F55_u5BF9_ViewController__u7626_u8EAB_uFF1F"><a href="#u5982_u4F55_u5BF9_ViewController__u7626_u8EAB_uFF1F" class="headerlink" title="如何对 ViewController 瘦身？"></a>如何对 ViewController 瘦身？</h2><p><a href="https://www.objc.io/" target="_blank" rel="external">objc.io</a> 是一个非常有名的 iOS 开发博客，它上面的第一课 <a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/" target="_blank" rel="external">《Lighter View Controllers》</a> 上就讲了很多这样的技巧，我们先总结一下它里面的观点：</p>
<ul>
<li>将 UITableView 的 Data Source 分离到另外一个类中。</li>
<li>将数据获取和转换的逻辑分别到另外一个类中。</li>
<li>将拼装控件的逻辑，分离到另外一个类中。</li>
</ul>
<p>你想明白了吗？其实 MVC 虽然只有三层，但是它并没有限制你只能有三层。所以，我们可以将 Controller 里面过于臃肿的逻辑抽取出来，形成新的可复用模块或架构层次。</p>
<p>我个人对于逻辑的抽取，有以下总结。</p>
<h3 id="u5C06_u7F51_u7EDC_u8BF7_u6C42_u62BD_u8C61_u5230_u5355_u72EC_u7684_u7C7B_u4E2D"><a href="#u5C06_u7F51_u7EDC_u8BF7_u6C42_u62BD_u8C61_u5230_u5355_u72EC_u7684_u7C7B_u4E2D" class="headerlink" title="将网络请求抽象到单独的类中"></a>将网络请求抽象到单独的类中</h3><p>新手写代码，直接就在 Controller 里面用 AFNetworking 发一个请求，请求的完数据直接就传递给 View。入门一些的同学，知道把这些请求代码移到另外一个静态类里面。但是我觉得还不够，所以我建议将每一个网络请求直接封装成类。</p>
<p>把每一个网络请求封装成对象其实是使用了设计模式中的 Command 模式，它有以下好处：</p>
<ul>
<li>将网络请求与具体的第三方库依赖隔离，方便以后更换底层的网络库。实际上我们公司的 iOS 客户端最初是基于 <a href="http://allseeing-i.com/ASIHTTPRequest/" target="_blank" rel="external">ASIHttpRequest</a> 的，我们只花了两天，就很轻松地切换到了 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>。</li>
<li>方便在基类中处理公共逻辑，例如猿题库的数据版本号信息就统一在基类中处理。</li>
<li>方便在基类中处理缓存逻辑，以及其它一些公共逻辑。</li>
<li>方便做对象的持久化。</li>
</ul>
<p>大家如果感兴趣，可以看我们公司开源的 iOS 网络库：<a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="external">YTKNetwork</a>。它在这种思考的指导下，不但将 Controller 中的代码瘦身，而且进一步演化和加强，现在它还支持诸如复杂网络请求管理，断点续传，插件机制，JSON 合法性检查等功能。</p>
<p>这部分代码从 Controller 中剥离出来后，不但简化了 Controller 中的逻辑，也达到了网络层的代码复用的效果。</p>
<h3 id="u5C06_u754C_u9762_u7684_u62FC_u88C5_u62BD_u8C61_u5230_u4E13_u95E8_u7684_u7C7B_u4E2D"><a href="#u5C06_u754C_u9762_u7684_u62FC_u88C5_u62BD_u8C61_u5230_u4E13_u95E8_u7684_u7C7B_u4E2D" class="headerlink" title="将界面的拼装抽象到专门的类中"></a>将界面的拼装抽象到专门的类中</h3><p>新手写代码，喜欢在 Controller 中把一个个 UILabel ，UIButton，UITextField 往 <code>self.view</code> 上用 <code>addSubView</code> 方法放。我建议大家可以用两种办法把这些代码从 Controller 中剥离。</p>
<p>方法一：构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。</p>
<p>方法二：用一个静态的 Util 类，帮助你做 UIView 的拼装工作。这种方式稍微做得不太彻底，但是比较简单。</p>
<p>对于一些能复用的 UI 控件，我建议用方法一。如果项目工程比较复杂，我也建议用方法一。如果项目太紧，另外相关项目的代码量也不多，可以尝试方法二。</p>
<h3 id="u6784_u9020_ViewModel"><a href="#u6784_u9020_ViewModel" class="headerlink" title="构造 ViewModel"></a>构造 ViewModel</h3><p>谁说 MVC 就不能用 ViewModel 的？MVVM 的优点我们一样可以借鉴。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。</p>
<p>这样抽象之后，View 只接受 ViewModel，而 Controller 只需要传递 ViewModel 这么一行代码。而另外构造 ViewModel 的过程，我们就可以移动到另外的类中了。</p>
<p>在具体实践中，我建议大家专门创建构造 ViewModel 工厂类，参见 <a href="http://baike.baidu.com/view/1306799.htm" target="_blank" rel="external">工厂模式</a>。另外，也可以专门将数据存取都抽将到一个 Service 层，由这层来提供 ViewModel 的获取。</p>
<h3 id="u4E13_u95E8_u6784_u9020_u5B58_u50A8_u7C7B"><a href="#u4E13_u95E8_u6784_u9020_u5B58_u50A8_u7C7B" class="headerlink" title="专门构造存储类"></a>专门构造存储类</h3><p>刚刚说到 ViewModel 的构造可以抽奖到一个 Service 层。与此相应的，数据的存储也应该由专门的对象来做。在小猿搜题项目中，我们由一个叫 UserAgent 的类，专门来处理本地数据的存取。</p>
<p>数据存取放在专门的类中，就可以针对存取做额外的事情了。比如：</p>
<ul>
<li>对一些热点数据增加缓存</li>
<li>处理数据迁移相关的逻辑</li>
</ul>
<p>如果要做得更细，可以把存储引擎再抽象出一层。这样你就可以方便地切换存储的底层，例如从 sqlite 切换到 key-value 的存储引擎等。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>通过代码的抽取，我们可以将原本的 MVC 设计模式中的 ViewController 进一步拆分，构造出 网络请求层、ViewModel 层、Service 层、Storage 层等其它类，来配合 Controller 工作，从而使 Controller 更加简单，我们的 App 更容易维护。</p>
<p>另外，不知道大家注意到没，其实 Controller 层是非常难于测试的，如果我们能够将 Controller 瘦身，就可以更方便地写 Unit Test 来测试各种与界面的无关的逻辑。移动端自动化测试框架都不太成熟，但是将 Controller 的代码抽取出来，是有助于我们做测试工作的。</p>
<p>希望本文能帮助大家掌握正确使用 MVC 的姿势，在下一节里，我将分享一下我对 MVVM 的看法。</p>
<h1 id="u88AB_u795E_u5316_u7684_MVVM"><a href="#u88AB_u795E_u5316_u7684_MVVM" class="headerlink" title="被神化的 MVVM"></a>被神化的 MVVM</h1><h2 id="MVVM__u7684_u5386_u53F2"><a href="#MVVM__u7684_u5386_u53F2" class="headerlink" title="MVVM 的历史"></a>MVVM 的历史</h2><p><a href="https://en.wikipedia.org/wiki/Model_View_ViewModel" target="_blank" rel="external">MVVM</a> 是 Model-View-ViewModel 的简写。</p>
<p>相对于 MVC 的历史来说，MVVM 是一个相当新的架构，MVVM 最早于 2005 年被微软的 WPF 和 Silverlight 的架构师 John Gossman 提出，并且应用在微软的软件开发中。当时 MVC 已经被提出了 20 多年了，可见两者出现的年代差别有多大。</p>
<p>MVVM 在使用当中，通常还会利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。所以，MVVM 模式有些时候又被称作：<a href="https://en.wikipedia.org/wiki/Model_View_ViewModel" target="_blank" rel="external">model-view-binder</a> 模式。</p>
<p>具体在 iOS 中，可以使用 KVO 或 Notification 技术达到这种效果。</p>
<h2 id="MVVM__u7684_u795E_u5316"><a href="#MVVM__u7684_u795E_u5316" class="headerlink" title="MVVM 的神化"></a>MVVM 的神化</h2><p>在使用中，我发现大家对于 MVVM 以及 MVVM 衍生出来的框架（比如 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>）有一种「敬畏」感。这种「敬畏」感某种程度上就像对神一样，这主要表现在我没有听到大家对于 MVVM 的任何批评。</p>
<p>我感觉原因首先是 MVVM 并没有很大程度上普及，大家对于新技术一般都不熟，进而不敢妄加评论。另外，ReactiveCocoa 本身上手的复杂性，也让很多人感觉到这种技术很高深难懂，进而加重了大家对它的「敬畏」。</p>
<h2 id="MVVM__u7684_u4F5C_u7528_u548C_u95EE_u9898"><a href="#MVVM__u7684_u4F5C_u7528_u548C_u95EE_u9898" class="headerlink" title="MVVM 的作用和问题"></a>MVVM 的作用和问题</h2><p>MVVM 在实际使用中，确实能够使得 Model 层和 View 层解耦，但是如果你需要实现 MVVM 中的双向绑定的话，那么通常就需要引入更多复杂的框架来实现了。</p>
<p>对此，MVVM 的作者 John Gossman 的 <a href="http://blogs.msdn.com/b/johngossman/archive/2006/03/04/543695.aspx" target="_blank" rel="external">批评</a> 应该是最为中肯的。John Gossman 对 MVVM 的批评主要有两点：</p>
<p>第一点：数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</p>
<p>第二点：对于过大的项目，数据绑定需要花费更多的内存。</p>
<p>某种意义上来说，我认为就是数据绑定使得 MVVM 变得复杂和难用了。但是，这个缺点同时也被很多人认为是优点。</p>
<h2 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h2><p>函数式编程（Functional Programming）和响应式编程（React Programming）也是当前很火的两个概念，它们的结合可以很方便地实现数据的绑定。于是，在 iOS 编程中，ReactiveCocoa 横空出世了，它的概念都非常 新，包括：</p>
<ul>
<li>函数式编程（Functional Programming），函数也变成一等公民了，可以拥有和对象同样的功能，例如当成参数传递，当作返回值等。看看 Swift 语言带来的众多函数式编程的特性，就你知道这多 Cool 了。</li>
<li>响应式编程（React Programming），原来我们基于事件（Event）的处理方式都弱了，现在是基于输入（在 ReactiveCocoa 里叫 Signal）的处理方式。输入还可以通过函数式编程进行各种 Combine 或 Filter，尽显各种灵活的处理。</li>
<li>无状态（Stateless），状态是函数的魔鬼，无状态使得函数能更好地测试。</li>
<li>不可修改（Immutable），数据都是不可修改的，使得软件逻辑简单，也可以更好地测试。</li>
</ul>
<p>哇，所有这些都太 Cool 了。当我看到的时候，我都鸡冻了！</p>
<h2 id="u6211_u4EEC_u5E94_u8BE5_u5BA2_u89C2_u8BC4_u4EF7_MVVM__u548C_ReactiveCocoa"><a href="#u6211_u4EEC_u5E94_u8BE5_u5BA2_u89C2_u8BC4_u4EF7_MVVM__u548C_ReactiveCocoa" class="headerlink" title="我们应该客观评价 MVVM 和 ReactiveCocoa"></a>我们应该客观评价 MVVM 和 ReactiveCocoa</h2><p>但是但是，我突然想到，我好象只需要一个 ViewModel 而已，我完全可以简单地做一个 ViewModel 的工厂类或 Service 类就可以了，为什么要引入这么多框架？现有的 MVC 真的有那么大的问题吗？</p>
<p>直到现在，ReactiveCocoa 在国内外还都是在小众领域，没有被大量接受成为主流的编程框架。不只是在 iOS 语言，在别的语言中，例如 Java 中的 RxJava 也同样没有成为主流。</p>
<p>我在这里，不是想说 ReactiveCocoa 不好，也不是想说 MVVM 不好，而是想让大家都能够有一个客观的认识。ReactiveCocoa 和 MVVM 不应该被神化，它是一种新颖的编程框架，能够解决旧有编程框架的一些问题，但是也会带来一些新问题，仅此而已。如果不能使好的驾驭 ReactiveCocoa，同样会造成 Controller 代码过于复杂，代码逻辑不易维护的问题。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>有一些人总是追赶着技术，有什么新技术不管三七二十一立马就用，结果被各种坑。</p>
<p>又有一些人，总是担心新技术带来的技术风险，不愿意学习。结果现在还有人在用 MRC 手动管理引用计数。</p>
<p>而我想说，我们需要保持的是一个拥抱变化的心，以及理性分析的态度。在新技术的面前，不盲从，也不守旧，一切的决策都应该建立在认真分析的基础上，这样才能应对技术的变化。</p>
<h1 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h1><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u88AB_u8BEF_u89E3_u7684_MVC"><a href="#u88AB_u8BEF_u89E3_u7684_MVC" class="headerlink" title="被误解的 MVC"></a>被误解的 MVC</h1><h2 id="MVC]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析一对一沟通]]></title>
    <link href="http://blog.devtang.com/2015/10/25/one-on-one-summary/"/>
    <id>http://blog.devtang.com/2015/10/25/one-on-one-summary/</id>
    <published>2015-10-25T10:06:42.000Z</published>
    <updated>2016-02-16T10:26:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><p>一对一沟通，又被称作一对一会议、One-on-one 等，是互联网公司常用的沟通方式。一对一沟通虽然被广泛使用，但是涉及的文章却很少，我主要通过两本书来获得它的一些知识，这两本书是<a href="https://book.douban.com/subject/5431183/" target="_blank" rel="external">《格鲁夫给经理人的第一课》</a>和<a href="https://book.douban.com/subject/26306686/" target="_blank" rel="external">《创业维艰》</a>。</p>
<p>这两本书的作者都非常有名，<a href="http://baike.baidu.com/view/1659256.htm" target="_blank" rel="external">格鲁夫</a>是 Intel 公司的总裁，成功带领 Intel 公司完成了从半导体存储器到微处理器的转型。《创业维艰》的作者本·霍洛维茨是硅谷的顶级 VC，投资了 Facebook、Twitter 等公司。</p>
<p>除此之外，我本人也是一对一沟通的实践者，从刚毕业踏入职场开始，我就经历着一次又一次的一对一沟通。</p>
<p>在本文中，我们将浅析一对一沟通的细节。</p>
<h2 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h2><p>在<a href="https://book.douban.com/subject/5431183/" target="_blank" rel="external">《格鲁夫给经理人的第一课》</a>一书中，格鲁夫对「一对一沟通」的介绍如下：</p>
<blockquote>
<p>在英特尔，一对一会议通常是由经理人召集他的部属召开的，这也是维系双方从属关系最主要的方法。一对一会议主要的目的在于互通信息以及彼此学习。经过对特定事项的讨论，上司可以将其技能以及经验传授给下属，并同时建议他切入问题的方式；而下属也能对工作中碰到的问题进行汇报。</p>
</blockquote>
<p>在我看来，一对一沟通的意义是可以使得信息从下而上地传递。从而获得在其它渠道不易获得的信息，保证透明。</p>
<p>讲一个我自己的故事。我有一阵子在开发中饱受产品调整之苦，很多时候刚刚做完一个产品功能的开发，然后产品需求就改了。对于一个对代码「有爱」的人来说，刚刚写完的几千行的代码要删掉，这个心情是非常沮丧的。</p>
<p>于是我就在一次和郭老大的一对一沟通中提出了这个问题。郭老大在表达同情之后，邀请我参加了一次产品的讨论会。在产品讨论会中，我看到大家都非常努力地在讨论产品方案，从而了解到，产品同事也非常不容易，他们需要在非常有限的时间内做出完整的产品方案，所以难免出现小的调整。而对于创业公司来说，「按时交付」是第一优先级的事情，所以我在这之后，接受产品调整的心态上就好受了很多。</p>
<p>我想这就是一次成功的一对一沟通。它首先让我的糟糕心情得到了宣泄，另外，它化解了我对于产品同事的抱怨，通过参与产品讨论，我甚至产生了对他们也不容易的「同理心」，能够理解他们也是在不得已的情况下，才调整产品方案的。最终，我们都接受了软件开发中的不完美，为了保证创业中按时交付，快速迭代的做事方式，和产品同事一起努力把事情做好。</p>
<h2 id="u9002_u5408_u8BA8_u8BBA_u7684_u95EE_u9898"><a href="#u9002_u5408_u8BA8_u8BBA_u7684_u95EE_u9898" class="headerlink" title="适合讨论的问题"></a>适合讨论的问题</h2><p>从我刚刚的故事中，大家可以看到，「倾诉焦虑」适合用来做为一对一沟通的内容。其实，适合作为一对一沟通的内容还包括：</p>
<ol>
<li>不成熟的看法</li>
<li>迫在眉睫的问题</li>
<li>精彩的想法</li>
<li>倾诉焦虑</li>
<li>抱怨</li>
</ol>
<p>以上这些内容，除了在一对一沟通中交流之外，很难找到别的渠道来有效解决。比如，对一些公司做事方式的不成熟看法或误解，如果是和同事在私下讨论，可能让误解加深。又比如，在和同事合作中产生的抱怨，如果将抱怨公开，很可能造成不好的影响。</p>
<p>一对一沟通构造了一个渠道，这个渠道自下而上，使得以上这些内容都能够被倾听，从而被解决。</p>
<p>因为这是一个「自下而上」的渠道，所以员工的主动性就非常重要。在一对一沟通中，上司多听少说，让员工成为沟通的中心。上司应该引导员工表达他的核心观点（如果有的话）。如果可能，也可以试试让员工来安排一对一沟通。</p>
<h2 id="u5EFA_u7ACB_u8212_u9002_u7684_u6C9F_u901A_u73AF_u5883"><a href="#u5EFA_u7ACB_u8212_u9002_u7684_u6C9F_u901A_u73AF_u5883" class="headerlink" title="建立舒适的沟通环境"></a>建立舒适的沟通环境</h2><p>你会对一个陌生人敞开心扉吗？显然不会。那如果上司和员工平常极少聊天和沟通，那他们就不太容易讨论尖锐的问题。所以，上司应该尽可能和员工建立友谊。平时多聊聊天，在休息的时候聊些工作无关的话题，组织团队的 Team Building 活动，都有助于大家成为朋友。</p>
<p>另外，如果大家沟通的时候是坐在办公室里，那么员工的心情是不那么放松的，因为办公室始终是一个讨论工作的环境，让人无法放松。可能的话，可以尝试找一个公司的休息区，坐在沙发上沟通，或者直接走出公司，找一个咖啡厅点杯饮料，在咖啡厅里面聊天，都是不错的选择。</p>
<p>如果能请员工吃个饭，然后饭后聊聊天，散散步走一走，那么就更棒了。舒适的沟通环境有助于双方在放松的心情下交流，有助于大家更加平等地对话。</p>
<h2 id="u4FDD_u6301_u771F_u8BDA"><a href="#u4FDD_u6301_u771F_u8BDA" class="headerlink" title="保持真诚"></a>保持真诚</h2><p>沟通要有效，保持真诚是必要的前提，否则员工不可能将心中的问题提出来。</p>
<p>保持真诚需要不敷衍任何员工提出的问题，不管这个问题有多尖锐。如果你也不知道如何解决这个问题，不妨和员工一起讨论讨论，看看员工能不能一起寻找可行的办法。切忌不要讲空话和套话，一旦员工发现这是一个无效的沟通渠道之后，「自下而上」的通道就被关闭了。</p>
<p>保持真诚也需要坦白和诚实，坦白使得沟通双方能够尽可能地保证透明。足够的透明才能让员工理解上司的想法，从而达到双方考虑问题的方式一致，进一步言行一致后，大家就会产生近似的处事方式，上司就可以将事情充分授权给员工了。</p>
<p>但是，坦白也不是说不留秘密，如果一个问题你觉得不方便讨论，就坦白地说不方便讨论，并且如果可能，尽量给出理由。</p>
<h2 id="u9002_u5F53_u5F15_u5BFC"><a href="#u9002_u5F53_u5F15_u5BFC" class="headerlink" title="适当引导"></a>适当引导</h2><p>并不是每一个员工都懂得一对一沟通的重要性，也不是每一个员工都能主动倾述问题，寻求帮助。很多程序员的性格都是比较内向的，有一些甚至不善于表达自己。</p>
<p>所以，虽然员工是一对一沟通的「主角」，但是上司也是需要进行适当的引导。对于上司已经发现的员工工作中的困难，可以适当的主动提出来，以便于更好地讨论，这也会让员工感到很体贴。</p>
<p>如果员工没有问题，一对一沟通也可以用于上司向员工传授工作经验和技巧渠道，这样员工可以向上司学习各种知识。</p>
<p>如果没有什么谈的，适合用来引导的问题也包括：</p>
<ul>
<li>当前产品还有哪些可以提高的地方？</li>
<li>我们部门的最大问题是什么，为什么？</li>
<li>如果有，你觉得工作中有哪一点令你感觉不舒服？</li>
<li>你觉得谁的工作最优秀，为什么？</li>
<li>假如你是我，你会做何调整？</li>
<li>我们的产品哪方面不尽如人意？</li>
<li>我们错失的最大机遇是什么？</li>
<li>哪些是我们应该做而没有做的？</li>
<li>你自己希望未来在哪些方面能有提高？</li>
<li>有什么我能为你做的事情？</li>
</ul>
<h2 id="u6C9F_u901A_u7684_u9891_u7387"><a href="#u6C9F_u901A_u7684_u9891_u7387" class="headerlink" title="沟通的频率"></a>沟通的频率</h2><p>一对一沟通应该多久一次？在《创业维艰》一书中，本·霍洛维茨认为一对一沟通需要保证至少一个月一次。而格鲁夫认为，需要根据部属对工作的熟悉度，而进行不同程度的掌控。如果他处理的是新项目，你应该提高和他沟通的频率；反之，如果他对这个项目已经游刃有余，你可能一个月一次就够了。</p>
<p>另外，格鲁夫还认为，事情变化的速度也是影响一对一沟通频率的因素。比如市场和产品的变化就比技术的变化要快，所以市场部门的一对一沟通可能需要更频繁一些。</p>
<p>所以，并没有不变的沟通频率，但是几个月都不沟通明显是不太合适的。</p>
<h2 id="u6C9F_u901A_u7684_u65F6_u957F"><a href="#u6C9F_u901A_u7684_u65F6_u957F" class="headerlink" title="沟通的时长"></a>沟通的时长</h2><p>一个问题要展开进行讨论和交流，15 分钟肯定是不够的，所以一对一沟通需要留有足够的时间。通常为了保留足够的 buffer，一对一沟通都至少是一个小时，并且可以根据实际讨论的内容有适当地延长。</p>
<h2 id="u6C9F_u901A_u7684_u6548_u679C"><a href="#u6C9F_u901A_u7684_u6548_u679C" class="headerlink" title="沟通的效果"></a>沟通的效果</h2><p>除了能够帮助员工有效地解决问题之外，一对一沟通还有以下效果。</p>
<h3 id="u6210_u529F_u6388_u6743"><a href="#u6210_u529F_u6388_u6743" class="headerlink" title="成功授权"></a>成功授权</h3><p>格鲁夫称「一对一会议有巨大的杠杆率」，因为这都是通过上司和下属间建立起共同的信息基础，以及近似的处事方式来达成的。这也是要达到「成功授权」的唯一途径。</p>
<h3 id="u76F8_u4E92_u5B66_u4E60"><a href="#u76F8_u4E92_u5B66_u4E60" class="headerlink" title="相互学习"></a>相互学习</h3><p>如果上司想作好决策，那么他在会议中「从下属身上学到的东西」也同样很重要。格鲁夫说他对于 Intel 的很多决策想法，都是来自于一对一沟通中员工的意见。格鲁夫是一个程序员出行，他不懂制造和供应链，但是不影响他在一对一沟通中，从员工中学习这方面的知识，从而做出相应的决策。</p>
<h3 id="u5BB6_u5EAD_u751F_u6D3B"><a href="#u5BB6_u5EAD_u751F_u6D3B" class="headerlink" title="家庭生活"></a>家庭生活</h3><p>格鲁夫说，他有两个正值青春期的女儿，他尝试在家里的餐厅和孩子进行一对一沟通，在那个相对私密的场合，他们可以较严肃地谈一些细微且复杂的事情。</p>
<p>所以我惊喜地发现，一对一沟通对于家庭成员之间同样有效。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>一对一使得企业里面的组织，产生了自下而上的沟通渠道，从而能够使得组织内的每一个人更加舒服地工作，让团队凝聚力更强。</p>
<p>本质上来说，一对一沟通就是构建一个私密的、轻松的、真诚的、有效的环境，两个人在一起讨论问题和相互学习。理论上，不管是公司内的管理，还是公司之间的合作，还是朋友之间的相处，还是家庭成员之间的交流，一对一沟通都能够发挥出它的效果。</p>
<p>看了这篇文章，明天你打算和谁来一场「一对一沟通」？</p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/analysis-of-one-to-one-communication#rd" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><p>一对一沟通，又被称作一对一会议、One-on-one 等，是互联网公司常用的沟通方式。一对一沟通虽然被广]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 比 Android 还不安全? - 记一次和阿里资深安全工程师蒸米的交流]]></title>
    <link href="http://blog.devtang.com/2015/10/22/talk-with-zm-about-ios-security/"/>
    <id>http://blog.devtang.com/2015/10/22/talk-with-zm-about-ios-security/</id>
    <published>2015-10-22T14:12:16.000Z</published>
    <updated>2016-02-18T13:15:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><p>10 月 15 日晚上，我参加了 MDCC（ <a href="http://mdcc.csdn.net/" target="_blank" rel="external">http://mdcc.csdn.net/</a> ）大会晚上的英雄宴，宴会上见到了 XcodeGhost 的研究者，阿里巴巴资深安全工程师蒸米。</p>
<p>蒸米是最早在乌云上公开 XcodeGhost 的工作原理的人。在后续 XcodeGhost 的服务器关闭后，蒸米也介绍了通过 DNS 污染来接管 XcodeGhost 木马的技术。让大家对于 iOS 平台的安全有了新的认识。</p>
<p>之前我和蒸米在微博上多次私信交流，这次当面见到真人非常开心。蒸米是一个性格开朗阳光的人，看起来非常年轻，一问之下才知道他 26 岁就提前博士毕业了，毕业之后一直在阿里从事安全方面的工作。</p>
<p>以下是我们讨论的一些总结。</p>
<h2 id="Xcode__u7684_u5B89_u5168"><a href="#Xcode__u7684_u5B89_u5168" class="headerlink" title="Xcode 的安全"></a>Xcode 的安全</h2><p>这次 XcodeGhost 事件之后，让大家把安全的焦点集中在了编译器上。估计大家不会还从迅雷或网盘下载 Xcode 了吧？但是这样就安全了吗？</p>
<p>蒸米在交流中提到，其实仅仅这样 Xcode 也是不安全的。为什么呢？因为我们在 Mac 上总要安装软件吧？有很多 Mac 下的软件并不通过 Mac AppStore 销售，而是以安装包的形式来独立发布。而安装这类 APP 时，常常需要用户输入登陆密码来获得更改系统内容的权限。这个时候，如果是一个恶意软件，偷偷修改了你本地的 Xcode，比如安装一个恶意的插件，你如何防？有些人习惯从一些非法网站去下载盗版的 Mac 软件，这个时候，你的 Xcode 安全也暴露在风险之中。</p>
<h2 id="u7B2C_u4E09_u65B9_u5E93_u7684_u5B89_u5168"><a href="#u7B2C_u4E09_u65B9_u5E93_u7684_u5B89_u5168" class="headerlink" title="第三方库的安全"></a>第三方库的安全</h2><p>这个是我自己的一个脑洞大开的想法，由于某些原因，国外的 Cocoapods 源很慢，所以常常有一些人宣称自己基于国内的服务，建立了镜像源。如果想做一点恶意行为的话，这些人完全是可以修改一些常用的第三方库（例如 AFNetworking），把 XcodeGhost 的代码植入进去。如果真的有人做了，你还能信任这些国内的镜像源吗？</p>
<h2 id="Safari__u4FDD_u5B58_u5BC6_u7801_u7684_u95EE_u9898"><a href="#Safari__u4FDD_u5B58_u5BC6_u7801_u7684_u95EE_u9898" class="headerlink" title="Safari 保存密码的问题"></a>Safari 保存密码的问题</h2><p>蒸米在和我交流中，也提到了对于 Safari 保存密码的安全性问题。就蒸米当场给我的演示可以看出，在设置里面的 Safari -&gt; 密码一栏，经过 Touch ID 验证，就可以将你的所有登录过的帐号密码查询到。而在 iPhone 5 一类没有 Touch ID 的 iOS 设备中，这些密码是被 4 位的锁屏密码保护，这个保护是极其弱的。如果你网上 google 一下，就可以找到专门暴力破解 4 位锁屏密码的工具。</p>
<p>看着蒸米当场的演示，真是把我吓了一大跳。同学们，你们有没有 Touch ID 的 iOS 设备吗？哪一天它要是丢了，你知道意味着你 Safari 所有登录密码可能被盗吗？</p>
<h2 id="u4E3A_u4EC0_u4E48_iOS__u7CFB_u7EDF_u6BD4_Android__u8FD8_u4E0D_u5B89_u5168__3F"><a href="#u4E3A_u4EC0_u4E48_iOS__u7CFB_u7EDF_u6BD4_Android__u8FD8_u4E0D_u5B89_u5168__3F" class="headerlink" title="为什么 iOS 系统比 Android 还不安全 ?"></a>为什么 iOS 系统比 Android 还不安全 ?</h2><p>蒸米在交流中一直强调他的观点，他认为 iOS 系统比 Android 还不安全。这一点让我非常不解，我当即指出：iOS 程序有 sandbox 限制，无法随意做高危险的事情，比如 Android 深受其害的扣费短信一条，iOS 程序很难做到自动发送。因为首先 iOS 程序很难在后台自动启动，另外，自动发送短信也是被系统禁止的。</p>
<p>但是蒸米解释让我觉得也很有道理，他的理由主要有以下几点：</p>
<h3 id="iOS__u7684_u7CFB_u7EDF_u6F0F_u6D1E_u66F4_u591A"><a href="#iOS__u7684_u7CFB_u7EDF_u6F0F_u6D1E_u66F4_u591A" class="headerlink" title="iOS 的系统漏洞更多"></a>iOS 的系统漏洞更多</h3><p>iOS 的系统漏洞其实比 Android 更多，Android 因为是开源的系统，所以相关的漏洞更容易被发现和修复，而 iOS 是封闭的系统，它的漏洞只能指望苹果自己的工程师来修复。</p>
<p>就在我和蒸米交流的当天（10 月 15 日），国内的<a href="http://www.pangu.io" target="_blank" rel="external">盘古团队</a>宣布完成了 iOS 9 的越狱。而这距离 iOS 9 正式发布（9 月 17 日）才刚刚满一个月。蒸米说，其实越狱团队早就完成越狱的技术工作了，只不过需要完成越狱相关的产品以及等一个比较合适的时间点发布。所以，很有可能在 iOS 9 还在 Beta 版的时候，相关的漏洞就已经收集到了。</p>
<p>相对来说，Android 的最新版其实相当安全。不过 Android 的问题是 ROM 更新太慢，由于大多数 ROM 都经过了厂商的定制，使得大多数人无法及时更新到最新的操作系统，这个问题极大地降低了 Android 的安全性。</p>
<h3 id="iOS__u7684_u7CFB_u7EDF_u7248_u672C_u548C_u673A_u578B_u975E_u5E38_u96C6_u4E2D"><a href="#iOS__u7684_u7CFB_u7EDF_u7248_u672C_u548C_u673A_u578B_u975E_u5E38_u96C6_u4E2D" class="headerlink" title="iOS 的系统版本和机型非常集中"></a>iOS 的系统版本和机型非常集中</h3><p>iOS 的系统版本非常集中，一般都是最新发布的 2 个大版本。另外 iPhone 机型也非常少，每年固定出一款。这使得黑客可以针对单一系统或机型挖掘出来的漏洞，得到极其方便地扩散和影响。</p>
<p>还记得早年 iOS 系统上面发面的 PDF 漏洞吗？用户只需要访问一个指定网址，就可以完成越狱过程。如果在未来有一个黑客找到一个类似这样的高级漏洞，那么受影响的很可能是所有的 iOS 用户。</p>
<p>相对来说，Android 的机型分散反但成了它的优势，我们自己开发小猿搜题 App 时，就那么几个界面都适配得要吐血，黑客的恶意程序难保不在一些机型上出现适配问题。除了硬件，Android 的 ROM 也是被修改得千差万别，所以黑客很难有精力把它的恶意程序做到完美适配。</p>
<h3 id="iOS__u7CFB_u7EDF_u66F4_u5BB9_u6613_u8BA9_u4EBA_u653E_u677E_u8B66_u60D5"><a href="#iOS__u7CFB_u7EDF_u66F4_u5BB9_u6613_u8BA9_u4EBA_u653E_u677E_u8B66_u60D5" class="headerlink" title="iOS 系统更容易让人放松警惕"></a>iOS 系统更容易让人放松警惕</h3><p>我们尝试过用 IDA 逆向国内的 iOS App，发现国内的包括腾讯，阿里，百度，网易等，都没有对自己的 iOS App 源码进行混淆。而在 Andorid 端的，不但 50% 的 App 都经过了加壳和代码混淆，而且还有不少这方面的创业公司出现。这次在 MDCC 大会展台中就出现了多家做 Android 安全的公司。</p>
<p>我在交流中问蒸米，我们逆向了支付宝和淘宝的 iOS 客户端，发现代码都没有混淆，为什么呢？蒸米说，我们混淆了支付宝核心支付相关的代码，另外的代码混淆的推进，不是我一个人能做到的，需要等时机成熟。</p>
<p>我想这就是现状，大家对于 iOS 系统更多的时候是放心的，所以反倒容易翻船。就像我上面提到的 Safari 密码保护的问题，有多少人注意到它可能带来的安全问题呢？</p>
<p>XcodeGhost 是不是也是大家对 Mac OS 系统的一种放松警惕的行为？一些朋友在网上下载盗版的 Mac App 是不是一种放松警惕的行为？这些最终都可能成为黑客攻击的关键点。</p>
<p>提一个开放性的问题：如果你逆向了微信 iOS 客户端，你可以做哪些攻击？</p>
<h3 id="Sandbox__u771F_u7684_u5C31_u662F_u7EDD_u5BF9_u5B89_u5168_u5417"><a href="#Sandbox__u771F_u7684_u5C31_u662F_u7EDD_u5BF9_u5B89_u5168_u5417" class="headerlink" title="Sandbox 真的就是绝对安全吗"></a>Sandbox 真的就是绝对安全吗</h3><p>我在反驳蒸米时，提到了系统的 Sandbox 对于 App 的各种限制。蒸米指出，其实有好多方法来突破 Sandbox，比如调用系统的私有 Api（不要问我如何绕过苹果审核），又比如借助一些 iOS 的漏洞。</p>
<p>完美的越狱对漏洞的要求比较高，因为它需要保证即使系统重启，越狱状态也同样能保持。而如果你的目的如果不是完美越狱，而是干一些坏事的话，对漏洞的要求就不是那么高了。</p>
<p>你知道吗？中国的越狱团队还会向苹果上报漏洞，蒸米说这是为了 Reputation，一般是把手里多得觉得不太好用的漏洞报出去，你就可以想像这个封闭系统的质量了。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>我最后问蒸米，是不是可以这样说：「iOS 和 Android 就是俩落难兄弟，都觉得对方弱，其实都差不多，全身都是洞，都不安全？」。蒸米说是的，毕竟开发者不是安全工程师，安全工程师们也不会开发，所以漏洞是在所难免的。</p>
<p>那这个事情就无解了吗？我想很可能是的，我们能做的，就是尽量提高安全意识，尽量小心，毕竟黑客也是会考虑性价比，挑软柿子欺负。最后蒸米向我推荐了 fireeye 的攻击检测网址，上面可以看到全球正在发生的黑客攻击行为 <a href="https://www.fireeye.com/cyber-map/threat-map.html" target="_blank" rel="external">https://www.fireeye.com/cyber-map/threat-map.html</a> ，我想这可能就是现实吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><p>10 月 15 日晚上，我参加了 MDCC（ <a href="http://mdcc.csdn.net]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
</feed>
