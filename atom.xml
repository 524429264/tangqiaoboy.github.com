<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[唐巧的技术博客]]></title>
  <subtitle><![CDATA[记录下自己学习的点滴]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2016-07-09T14:46:24.000Z</updated>
  <id>http://blog.devtang.com/</id>
  
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[技术主导型公司的困境]]></title>
    <link href="http://blog.devtang.com/2016/07/09/lead-by-tech-companys-trap/"/>
    <id>http://blog.devtang.com/2016/07/09/lead-by-tech-companys-trap/</id>
    <published>2016-07-09T14:39:55.000Z</published>
    <updated>2016-07-09T14:46:24.000Z</updated>
    <content type="html"><![CDATA[<p>Google 公司给了全世界的程序员一个理想公司的范例：招最聪明的人、工程师驱动项目、宽松的工作气氛、鼓励创新、20% 的自由时间⋯⋯我早年以为这样的公司一定会成功，但是工作到现在我却发现，那些模仿 Google 文化和工作方式的公司很多却活得很艰难。</p>
<h2 id="u8C4C_u8C46_u835A_u7684_u6545_u4E8B"><a href="#u8C4C_u8C46_u835A_u7684_u6545_u4E8B" class="headerlink" title="豌豆荚的故事"></a>豌豆荚的故事</h2><p>就在几天前，阿里巴巴宣布 <a href="http://tech.sina.com.cn/i/2016-07-05/doc-ifxtsatm1409353.shtml" target="_blank" rel="external">收购豌豆荚</a>，而交易价格并未对外公开。业界传言收购价为 <a href="http://tech.sina.com.cn/i/2016-07-02/doc-ifxtsatn7967833.shtml" target="_blank" rel="external">2 亿美金</a>，但是豌豆荚联合创始人王俊煜并未承认。不管是不是 2 亿美金，一个未公开的收购价很可能是为了避免让大家觉得尴尬，这种尴尬很可能是豌豆荚的收购价格并不乐观。</p>
<p>从前面几轮豌豆荚的融资信息来看，豌豆荚仅仅在 2014 年就获得了 1.2 亿美金的融资，当时估值为 <a href="http://tech.sina.com.cn/i/2016-07-03/doc-ifxtsatn7994939.shtml" target="_blank" rel="external">10 亿美金</a>，如果最终以 2 亿美金卖掉，那么真正归属给股东的回报应该寥寥无几，而众多员工的期权价值应该也就此成为一张废纸。</p>
<p>豌豆荚有类典型的技术主导型公司的气质。豌豆荚创始团队许多来自 Google，王俊煜从实习到毕业一直都在 Google，豌豆荚内部文化极其自由开放、透明及扁平化。</p>
<p>但是技术主导型公司通常还会有另一个特点，就是会「看不起」运营工作，在 <a href="http://tech.sina.com.cn/zl/post/detail/i/2016-07-06/pid_8507905.htm" target="_blank" rel="external">《多面豌豆荚》</a> 一文中，作者写道：</p>
<blockquote>
<p>豌豆荚工程师文化非常强，在公司内部，产品设计师和工程师是项目主导，运营、市场、商务的地位都排在第二位。虽然豌豆荚把产品经理叫做 “产品设计师”，但豌豆荚的产品设计师是几乎不支持运营、市场或商务活动的，这类设计需求全部外包。外包一方面成本很高，另一方面周期比较长，因为设计师不在旁边，沟通成本要高许多。</p>
</blockquote>
<p>作为最早的安卓应用市场，豌豆荚曾经是市场的老大，而它现在已经跌出了第一梯队。﻿豌豆荚在应用内搜索方面的尝试一直不太成功。作为一家技术人才聚集的公司，豌豆荚更喜欢用技术解决问题，应用内搜索看起来更像是一个技术难题，而不是用户需求。随着应用市场业务的萎靡以及新产品没有获得突破，豌豆荚不得已只能卖给阿里。</p>
<h2 id="u6709_u9053_u7684_u6545_u4E8B"><a href="#u6709_u9053_u7684_u6545_u4E8B" class="headerlink" title="有道的故事"></a>有道的故事</h2><p>网易有道是我第一份正式工作的东家，也是我认为文化非常贴近 Google 文化的公司。有道的创始人周枫是清华的年级第一，在清华读书时就是个风云人物。有道在成立之初，聚集了大量清华的同学。有道良好的技术氛围进而吸引了大量高质量的程序员，在我入职有道时，有道员工大部分都由清华北大的同学构成。有道员工里面不乏大量 ACM 世界总决赛获奖选手和 NOI 金牌获奖选手。公司内部重视代码 code review，重视 wiki，重视技术分享，甚至也有 20% 时间的个人项目。我还记得当时利用个人项目时间和黄东旭一起开发了 Mac 版的有道云笔记。</p>
<p>但是，技术上的优势并没有给有道带来商业上的成功。有道搜索在苦苦挣扎一段时间后，直接放弃了搜索业务。有道云笔记一直没能找到合适的用户增长点和盈利模式。有道惠惠做得非常早，但是仍然用户比较小众。现在看来，只有有道词典算是成功的一个产品，但收入应该远远没有达到支撑有道上市的程度。</p>
<p>有道在商业上的坎坷也造成了人员的动荡。早年的大量高质量工程师，待在有道是为了创业成功，以他们的实力很容易挑选新的公司。所以在有道发展下坡的时候，好多员工去了 Google、BAT 等其他一线互联网公司，而我也是在那个时候选择了加入猿题库创业。﻿</p>
<h2 id="u8C46_u74E3_u7684_u6545_u4E8B"><a href="#u8C46_u74E3_u7684_u6545_u4E8B" class="headerlink" title="豆瓣的故事"></a>豆瓣的故事</h2><p>豆瓣也是一个技术气氛浓厚的公司，阿北自己就是程序员出身，所以豆瓣的工程师氛围特别强，强到产品要做一个功能，技术会挑战他，会问为什么要做这个功能。但是豆瓣按自己节奏做事的风格，很快错过了移动互联网的机会。</p>
<h2 id="u6280_u672F_u4E3B_u5BFC_u578B_u516C_u53F8_u7684_u77ED_u677F"><a href="#u6280_u672F_u4E3B_u5BFC_u578B_u516C_u53F8_u7684_u77ED_u677F" class="headerlink" title="技术主导型公司的短板"></a>技术主导型公司的短板</h2><p>豌豆荚、有道、豆瓣，为什么聚集了大量优秀的技术人才还是没能成功？其实从一个侧面说明一个创业项目的成功，技术只是各个条件中的一环而已。除开技术本身，我们还需要在产品，设计，运营，内容，市场推广等多方面努力，才可能在竞争中占据优势。</p>
<p>有道的运营推广在我看来一直是公司的短板，有道背靠网易，习惯于借助网易的大流量来获取用户，间接影响了有道自己在获得用户方面的尝试。</p>
<p>以前听别人说「技术驱动或技术主导」的公司，我会觉得很酷。现在我反倒觉得，一家公司技术太强势，可能就会压制产品或运营的声音，影响整体的竞争力。</p>
<p>看看周围成功的创业企业，也有大量的公司刚开始并没有牛逼的技术，但是毫不影响别人在创业路上的成长。比如滴滴，直到很晚才找到合适的技术合伙人。比如罗永浩，早期的 ROM 团队和硬件团队实力并不强。比如京东，早期用微软的 ASP 技术开发网站。比如现在很火的健身应用 Keep，一直没有很强的技术团队。</p>
<p>但是他们都成功了，现在的滴滴聚集了大量优秀的 iOS 开发者，还拿了苹果 10 亿美金的投资。罗永浩的软硬件团队早已脱胎换骨。京东已经不断地向业界输出着他们的技术积累。我相信 Keep 也会很好地解决掉他们的技术问题。</p>
<p>所以，除了少量像 Google 无人驾驶或者马斯克造火箭这类前沿技术创新项目外，技术在创业之路上，99% 的时候都不是关键因素，所以我们才会看着一家又一家顶着技术光环公司的陨落。</p>
<p>猿题库其实也算是一家顶着技术光环的公司，我们给高于大部分互联网公司的 offer，努力把以前在有道做的好的技术实践给传承下来。但是我们更明白，商业的成功才是最重要的，所以我们更看重按时交付产品，更关注用户数据。当产品上线时间和代码质量产生直接冲突时，我们会选择按时上线产品而做一些 dirty &amp; quick 的技术实现。更进一步地，我认为好的代码质量其实也是为按时上线服务的，我们写好的代码，只是为了以后在修改需求或者增加人手的时候，更节省时间，最终的结果还是减少了开发时间，保证了按时上线。</p>
<p>技术是一家互联网公司成功的基础，但是除了技术本身，产品方向、UI&amp;UE、市场推广、运营活动、内容建设同样重要。作为技术人员，我们不应该抱有技术改变一切的优越感，而应该是以一个谦卑的姿态，让技术更好地为产品服务，因为只有产品的成功才算是一家企业真正的成功。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Google 公司给了全世界的程序员一个理想公司的范例：招最聪明的人、工程师驱动项目、宽松的工作气氛、鼓励创新、20% 的自由时间⋯⋯我早年以为这样的公司一定会成功，但是工作到现在我却发现，那些模仿 Google 文化和工作方式的公司很多却活得很艰难。</p>
<h2 id]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[永远的致胜联盟 - 读《独裁者手册》]]></title>
    <link href="http://blog.devtang.com/2016/07/07/the-dictators-handbook-summary/"/>
    <id>http://blog.devtang.com/2016/07/07/the-dictators-handbook-summary/</id>
    <published>2016-07-07T14:24:17.000Z</published>
    <updated>2016-07-07T14:28:11.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/dictators-handbook-book.jpg">
<h1 id="u8BFB_u4E66_u5FC3_u5F97"><a href="#u8BFB_u4E66_u5FC3_u5F97" class="headerlink" title="读书心得"></a>读书心得</h1><p>我们古代有句名言「水能载舟，亦能覆舟」，意思是一国之君应该尊重民意，执政为民，这样才能造就国家的富强。但是本书通过大量现代社会中的独裁国家的例子来告诉我们，其实独裁者的政治安全与人民的幸福生活并没有什么直接关系。这些独裁者的安危只与一个有关系：他是否能够构建好「致胜联盟」。</p>
<p>很有意思的是，本书中的大量例子来自「民主国家」美国。因为作者看来，独裁国家和民主国家的统治者在本质上都是一样的，都是追求服务于「致胜联盟」，所以我们在本书中看到了一个统一的关于政治生存的理论。</p>
<p>在我介绍本书的理论前，我们看看这个发生在美国的贝尔市的政治丑闻吧。</p>
<blockquote>
<p>罗伯特·里佐是贝尔小城的前市政经理，该城人口大约为36600人，位于洛杉矶周边，是一座主要由西班牙裔和拉丁裔构成的贫困小城。年人均收入远低于加州和全美的平均水平。超过四分之一的劳动人口生活在贫困线以下。</p>
<p>罗伯特·里佐做了17年的市政经理。罗伯特·里佐在1993年被聘任时的年薪是72000美元，经过17年到他2010年夏天被迫下台时，他的年薪达到了令人震惊的78万美元。</p>
<p>罗伯特·里佐作为市政经理的薪酬与美国其他政府官员相比如何呢？美国总统的年薪是40万美元。加州州长的年薪是20多万美元。与贝尔市紧邻的洛杉矶市市长年薪刚过20万美元。</p>
<p>我们自然会认为罗伯特·里佐肯定一直在设法窃取钱财，2010年夏天贝尔市丑闻发生时，加州总检察长承诺将对罗伯特·里佐是否违法展开调查。他的举动含蓄表达了一个清楚的看法：没有人会每年付给一座小城的市政经理近80万美元。然而，事情的真相比预想的要复杂得多。 </p>
<p>整件事其实是一种精明的政治操作，是由贝尔市的选民以及代表他们的市议员们间接批准的，再沾一点点盗窃的边。 </p>
</blockquote>
<p>罗伯特·里佐是如何做到这一点的呢？结论就是他构建了一个小的「致胜联盟」。他首先发起了一个投票，那场投票的目的是决定是否将贝尔市由“一般城市”转变为“宪章城市”，啥叫“宪章城市”呢？就是城市的政策由市议员决定，而不是由加州来决定。当然，罗伯特·里佐为此解释说：这可以给贝尔市更多的自治权，以摆脱遥远的州政府。</p>
<p>这样的投票其实很难被人理解其背后的影响，所以全市只吸引了400人来参与投票。于是，这个投票被通过后，罗伯特·里佐和市议员利用“宪章城市”的自治权，制定了很多政策，使得他们可以获得大量利益。于是，里佐和这些市议员合法地领取着高昂薪水。</p>
<p>最终，加州总检察长甚至无法对他们定罪，因为一切都是合法的。最终找的罪名竟然是他们拿了薪水，但是没有开相应的会议。所以，假如罗伯特·里佐每月再和这些议员「聚一聚」，那么真还拿他没办法了。</p>
<p>在本书的理论中，作者将政治分为三个维度和五个基本法则。</p>
<p>先介绍三个维度，对领导人而言，政治情势可以被分解为三种人群：名义选择人集团、实际选择人集团和致胜联盟。</p>
<ul>
<li>名义选择人集团：包含了所有在选择领导人时至少具有某些法定发言权的人。在美国，指的就是所有合格选民，即所有年满18周岁的公民。</li>
<li>实际选择人集团：真正选择领导人的是这个集团。在沙特阿拉伯的君主政体下，指的就是皇室的高级成员；在英国则指的是支持多数党议员的选民。</li>
<li>致胜联盟：最重要的集团。它是实际选择人集团的一个子集，构成了一个致胜联盟。他们的支持对于一个领导人的政治生存至关重要。</li>
</ul>
<p>领导人有五个基本法则可用于在任何体制下获得成功： </p>
<ul>
<li>法则1：让你的致胜联盟越小越好。</li>
<li>法则2：让你的名义选择人集团越大越好。</li>
<li>法则3：掌控收入的分配。</li>
<li>法则4：支付给你的核心支持者刚好足够确保他们忠诚的钱。</li>
<li>法则5：不要从你的支持者的口袋里挪钱去改善人民的生活。</li>
</ul>
<p>以下是一些解释：</p>
<ul>
<li>法则1：越小的致胜联盟越好提供利益输送。</li>
<li>法则2：一个很大的选择人集团提供了充足的替代支持者，让不可或缺者时刻谨记必须保持忠诚、规规矩矩，不然就会被别人取代。</li>
<li>法则3：有钱才能给致胜联盟输送利益。在刚刚那个贝尔市的故事中，罗伯特·里佐将城市的房产税提高了50%。而巴基斯坦总统阿西夫·阿里·扎尔达里的财富估计高达40亿美元，尽管他统治着一个人均国民收入几乎全球垫底的国家。</li>
<li>法则4：钱少了不够收买忠诚，钱多了就浪费了，而且把支持者的胃口给调大了。</li>
<li>法则5：人民根本就不是威胁，致胜联盟才是真正的威胁。</li>
</ul>
<p>在介绍完政治的三个维度和五个基本法则后，作者从多个角度来验证了他的理论。这些角度包括：</p>
<ul>
<li>上台（第3章）：如果反叛者要成功，通常都是需要原有政府领导人无法构造忠诚的致胜联盟导致的。而这一点具体的原因，可能是财政危机或安全危机。</li>
<li>掌权（第4章）：本章比较了民选领导人和独裁者在维护核心支持者这件事情上的难度。最终指出，因为很难构建小的致胜联盟，所以民选领导人更容易下台。而独裁者开始的时候比较容易被人推翻，但是一旦独裁者构建成功致胜联盟，那么就很难下台了。本章还讨论了公司 CEO 在掌权上可以做的尝试，很多故事都可以在最近的<a href="http://wiki.mbalib.com/wiki/%E4%B8%87%E7%A7%91%E8%82%A1%E6%9D%83%E4%B9%8B%E4%BA%89" target="_blank" rel="external">万科事件</a>中得到印证。</li>
<li>窃贫济富（第5章）：本章主要是讲的如何获得金钱。政治的5个基本法则中，第3条就是掌控收入的分配。如果无法获得足够的金钱，就无法构建致胜联盟，本章介绍了各种获取金钱的渠道。</li>
<li>获取与花费（第6章）：本章讨论可以把钱花在哪些地方，包括：教育、医疗、清洁的饮用水、基础设施建设、自由（出版自由、言论自由、集会自由等）。非常有意思的是，在独裁国家，领导人除了限制自由之外（这一点很好理解），也会限制教育、医疗或基础设施建设，因为这都有助于推翻独裁者的统治。</li>
<li>腐败使人有权（第7章）：对于独裁国家，腐败是一种提供私人报酬的方式，并且这种方式同时可以让动摇的联盟成员随时可能失去特权并被检控。对于民主国家，腐败的表现形式更加多样化，更多以扭曲的公共政策的形式出现，例如为富人的一些健康问题提供更多研究资金、为富人提供更为温和的税收政策等。</li>
<li>对外援助（第8章）：对于独裁国家的援助，很多时候都进了独裁者的口袋，而援助国很多时候对此是知情的，援助国对此睁一只眼闭一只眼的原因是：他在谋求某种政治交换。</li>
<li>反叛中的人民（第9章）：对于人民来说，反对独裁是非常正常的。但是作者指出，如果人民还能够发出反叛或抗议的声音，就说明政府还是相对温和的。真正的独裁者是不会让人有一丝抗议的声音。本章也详细解释了法则5，为什么人民无法构成有效的威胁。</li>
<li>战争、和平与世界秩序（第10章）：对于民主国家，战争和对外援助都是为了同一目的，只是一个更强势，另一个更温和。从另一个角度说明战争更多时候无关公平正义，只是政治行为。</li>
</ul>
<p>最后，在第11章，作者讨论了一些办法来解决前面提到的独裁问题，最直接的办法就是扩大致胜联盟的规模，使得独裁者无法为海量的联盟成员提供私人报酬，所以只能提供面向所有人的公共服务地方式来获得选票。</p>
<p>书中引用了大量的事例，涉及美国，俄罗斯，还有一些独裁国家，也涉及一些上市公司的治理，很多故事从作者的角度看，又是另外一番景象。</p>
<p>最后，我个人认为，本书将政治生存作为论述基础是成立的，因为<a href="https://zh.wikipedia.org/wiki/%E9%9C%80%E6%B1%82%E5%B1%82%E6%AC%A1%E7%90%86%E8%AE%BA" target="_blank" rel="external">马斯洛的需求理论</a>的最底层除了生理需求就是安全，如果一个人的政治生涯不能拥有安全感，那确实很难谈更高一层的理想。但是，我也不认为此理论就能将政治中所有人性的部分忽视，就像书中也把新加坡的李光耀作为一个特例来解读，这本身就说明本书的理论不是完美的。</p>
<p>这是一本非常有意思的书，推荐给大家，我也画了本书的思维导图（如下所示）。</p>
<img src="/images/dictators-handbook.jpg">
<hr>

<h1 id="u8BFB_u4E66_u7B14_u8BB0"><a href="#u8BFB_u4E66_u7B14_u8BB0" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>以下是更加详细的读书笔记。</p>
<h2 id="u7B2C1_u7AE0_uFF1A_u7EDF_u6CBB_u7684_u89C4_u5219"><a href="#u7B2C1_u7AE0_uFF1A_u7EDF_u6CBB_u7684_u89C4_u5219" class="headerlink" title="第1章：统治的规则"></a>第1章：统治的规则</h2><p>本章从美国一个小城市：贝尔市的政治丑闻说起，介绍贝尔市的市长：罗伯特·里佐 通过购建支持者小联盟，从而在这个城市大肆敛财的故事。</p>
<p>所以本书认为，独裁者的统治逻辑就是这样：</p>
<ol>
<li>政治就是获得和维持政治权力。它与“我们，人民”的普遍幸福无关。</li>
<li>确保政治生存的最好方式是只依靠少数人来上位和在位。这意味着，那些拥有一批同伙可以依靠的独裁者—常常寿终正寝—比民主人士更容易长年掌权。</li>
<li>当这个同伙小集团明白外面还有大把人排队等着取而代之大吃公家饭，最高领导层就具有了如何花钱、如何征税的巨大自由裁量权。</li>
<li>依靠一个支持者小联盟，领导人可以放手大肆提高税率，正如贝尔市那样。</li>
</ol>
<h2 id="u7B2C2_u7AE0_uFF1A_u653F_u6CBB_u7684_u6CD5_u5219"><a href="#u7B2C2_u7AE0_uFF1A_u653F_u6CBB_u7684_u6CD5_u5219" class="headerlink" title="第2章：政治的法则"></a>第2章：政治的法则</h2><blockquote>
<p>为了正确理解政治，我们必须修正一个特别的假设：我们必须停止认为领袖们能够独自领导。 </p>
</blockquote>
<p>所有独裁者都是需要一个核心的幕僚来帮助他做事情的，所以构建这个忠于自己的小联盟致关重要。</p>
<h3 id="u8DEF_u6613_u5341_u56DB_u7684_u6545_u4E8B"><a href="#u8DEF_u6613_u5341_u56DB_u7684_u6545_u4E8B" class="headerlink" title="路易十四的故事"></a>路易十四的故事</h3><p>本章中，作者把路易十四的故事作为例子，来看他是如何构建致胜联盟的。</p>
<blockquote>
<p>他的父王路易十三死后，年仅四岁的路易十四登基。在早期，实际权力掌握在摄政的他母亲手中。她的亲信横征暴敛。到1661年路易十四23岁开始亲政时，法国已处于破产边缘。</p>
<p>国家破产的前景让初掌大权的路易十四身处险境，因为保守派贵族、包括军队将领看到他们的财富和特权在逐渐干涸。这一情况促使这些政治上重要但薄情寡义的朋友开始另找他人来确保他们的财富和特权。面对这样的危机，路易十四必须做出改变，否则将丧失统治权。 </p>
</blockquote>
<p>在以前，国家的高层是在贵族中产生的。但是路易十四做了一件事情：他改变了以前提拔人才的方式，通过从平民中提拔更多人才，特别是军队人才，路易十四成功地增强了致胜联盟的竞争，同时又使得这些平民对他更加忠诚。</p>
<blockquote>
<p>通过提拔众多新人，路易建立了一个对他感恩的新阶层。在这一过程中，他更完整地集中了自己的权威，提升了对宫廷里不少老贵族年金的决定权。这样，他就建立起了一个“绝对”控制的体系，它的成功依赖于军队和新贵族的忠诚，也依赖于限制老贵族的权力，将他们的福祉直接转化为他的福祉。 </p>
</blockquote>
<p>这种改革确实非常有效。最终，路易十四在位 72 年，直到1715年寿终正寝。</p>
<h3 id="u653F_u6CBB_u7684_u4E09_u4E2A_u7EF4_u5EA6"><a href="#u653F_u6CBB_u7684_u4E09_u4E2A_u7EF4_u5EA6" class="headerlink" title="政治的三个维度"></a>政治的三个维度</h3><p>对领导人而言，政治情势可以被分解为三种人群：名义选择人集团、实际选择人集团和致胜联盟。</p>
<ul>
<li>名义选择人集团：包含了所有在选择领导人时至少具有某些法定发言权的人。在美国，指的就是所有合格选民，即所有年满18周岁的公民。</li>
<li>实际选择人集团：真正选择领导人的是这个集团。在沙特阿拉伯的君主政体下，指的就是皇室的高级成员；在英国则指的是支持多数党议员的选民。</li>
<li>致胜联盟：最重要的集团。它是实际选择人集团的一个子集，构成了一个致胜联盟。他们的支持对于一个领导人的政治生存至关重要。</li>
</ul>
<blockquote>
<p>根本上讲，名义选择人就是领导人的潜在支持者；实际选择人则指那些其对领导人的支持确实有重要影响的人；而致胜联盟只包括那些领导人不可或缺的关键支持者。这三种人可简单概括为：可相互替代者、有影响者以及不可或缺者。 </p>
<p>我们的出发点是意识到：任何一个有能力的领导人都希望掌握尽可能多的权力，并尽可能长久地掌握权力。设法利用可相互替代者、有影响者和不可或缺者来达到自己的目的，这就是统治的行为、艺术和科学。</p>
</blockquote>
<h3 id="u653F_u6CBB_u76845_u4E2A_u57FA_u672C_u6CD5_u5219"><a href="#u653F_u6CBB_u76845_u4E2A_u57FA_u672C_u6CD5_u5219" class="headerlink" title="政治的5个基本法则"></a>政治的5个基本法则</h3><p>领导人有5个基本法则可用于在任何体制下获得成功： </p>
<ul>
<li>法则1：让你的致胜联盟越小越好。</li>
<li>法则2：让你的名义选择人集团越大越好。一个很大的选择人集团提供了充足的替代支持者，让不可或缺者时刻谨记必须保持忠诚、规规矩矩，不然就会被别人取代。</li>
<li>法则3：掌控收入的分配。巴基斯坦总统阿西夫·阿里·扎尔达里的财富估计高达40亿美元，尽管他统治着一个人均国民收入几乎全球垫底的国家。</li>
<li>法则4：支付给你的核心支持者刚好足够确保他们忠诚的钱。</li>
<li>法则5：不要从你的支持者的口袋里挪钱去改善人民的生活。</li>
</ul>
<h2 id="u7B2C3_u7AE0_uFF1A_u4E0A_u53F0"><a href="#u7B2C3_u7AE0_uFF1A_u4E0A_u53F0" class="headerlink" title="第3章：上台"></a>第3章：上台</h2><p>本章从领导人上台的角度，来解释上一章提到的三个维度和五个基本法则。</p>
<p>本章讲了很多故事，基本上都是印证了：如果反叛要成功，通常都是需要原有政府领导人无法构造忠诚的致胜联盟导致的。而这一点具体的原因，可能是财政危机或安全危机。</p>
<h3 id="u8D22_u653F_u5371_u673A"><a href="#u8D22_u653F_u5371_u673A" class="headerlink" title="财政危机"></a>财政危机</h3><p>领导人没有钱了。比如由于自然灾难，造成税收减少。比如俄国政府禁酒，造成税收减少1/3。</p>
<blockquote>
<p>饮用伏特加在俄国大众特别是军队中极为盛行。伏特加如此受欢迎且消费量巨大，它构成了俄国政府岁入的三分之一。一旦禁止伏特加买卖，沙皇的收入立刻锐减。而由于战争，他的开销却在持续增长。沙皇很快就没有能力继续收买忠诚。结果就是他的军队拒绝镇压罢工群众和示威者。</p>
</blockquote>
<h3 id="u5B89_u5168_u5371_u673A"><a href="#u5B89_u5168_u5371_u673A" class="headerlink" title="安全危机"></a>安全危机</h3><p>如果领导人因为身体原因快挂了，致胜联盟就会由于安全感缺失，需要寻找新的同盟者。</p>
<blockquote>
<p>王朝式规则在民主国家司空见惯的原因与在独裁国家和君主制国家毫无二致。有谁比家族成员还能更好地保护家族财富和威望？民选官员花小钱赚大钱，享受权力，他们与奥古斯都皇帝或卡洛·甘比诺一样，渴望让自己的子孙享有一样的好处，保护他们的遗产。</p>
</blockquote>
<p>书中还举了阿尔及利来的本·贝拉的愚蠢故事作为例子。</p>
<blockquote>
<p>1965年6月12日，本·贝拉宣布一周之后将举行政治局会议，会上将讨论三个重大事项：（1）改组内阁；（2）撤换军队领导人；（3）清算军中反对派。他随后离开阿尔及尔前往奥兰。 </p>
<p>这一宣示无疑等于告诉他的核心支持者，他将撤换掉他们中的一些人。由于他并没有透露打算具体清除谁，共同的危机感使所有人都起念要除掉他。 </p>
</blockquote>
<h2 id="u7B2C4_u7AE0_uFF1A_u638C_u6743"><a href="#u7B2C4_u7AE0_uFF1A_u638C_u6743" class="headerlink" title="第4章：掌权"></a>第4章：掌权</h2><blockquote>
<p>爬上高位所需的技能与维持大权所需的本领完全不同。</p>
</blockquote>
<p>我们中国也有一句俗话，叫「打江山不易，守江山更难」。对于一个刚刚上台的新领导人，通常都需要调整致胜联盟，使其更加忠诚。韩信帮刘邦打下天下后，韩信本身的存在就成了一个威胁，因为他在军事上太有才能，并且掌握军队大权。范蠡在这一点上就非常聪明，懂得越王勾践「只可共患难不可共富贵」。</p>
<blockquote>
<p>一名老谋深算的新领导人会迅速采取行动将他们当中的一些人清除掉，替换成那些所获利益更能确保其未来忠诚度的人之后，一名领导人的未来权位才有保障。 </p>
</blockquote>
<p>不光是国家领导人符合这种规律，企业的CEO也一样。同国家不同，企业的实际选择人集团很多时候就是公司的董事会成员，而董事会成员因为拥有多数公司股份，加上上市公司的限制，CEO 很难构建致胜联盟。不过，本书中的惠普公司 CEO 的故事中，我们看到了 CEO 菲奥莉娜 通过并购重建董事会成员，以提高致胜联盟的例子。</p>
<blockquote>
<p>也许是为了获得留下来的几位原董事会成员的支持，或也许只是巧合，董事会成员们的报酬发生了显著变化。在菲奥莉娜成为惠普的首席执行官之前，董事会成员获得的报酬（也就是私人好处）在105700美元至110700美元之间。随着菲奥莉娜上台和董事会规模变小，这一数字略微缩减为100000美元至105000美元之间，并在2000年至2003年之间保持不变。但到了2004年，根据惠普公司委托声明书里公布的数据，董事会成员拿到的钱在200000美元至220000美元之间。同一时期，惠普的年化股息稳定在每股0.32美元，惠普的股票表现显著跑输主要股指。事实再清楚不过了：惠普的股价表现低劣、股息不变，而董事们的报酬却翻倍。 </p>
</blockquote>
<p>最近万科的事件当中，王石在投资中引入新的大股东，如果从构建致胜联盟来看，也是非常正确的。新引入的大股东和公司高管很容易处于蜜月期，从而在决策中达成一致。</p>
<blockquote>
<p>一个联盟的最重要的三个特征是：（1）忠诚；（2）忠诚；（3）忠诚。成功的领导人让周围充满自己信赖的朋友和家人，而将任何有野心的支持者清除掉。</p>
<p>当然，有些时候拥有一些能干的顾问是必不可少的。拜占庭、莫卧儿、中国、伊斯兰王国以及许多其他国家的君主想出了一种很有创意的方法来防止这些顾问成为敌手：他们全都在不同时期仰赖宦官。</p>
<p>就算到了现代，选择无法登顶的亲密顾问这一原则仍然有效。萨达姆·侯赛因作为伊斯兰国家伊拉克的总统，却挑选了一名基督徒塔里克·阿齐兹作为二号人物，这不是偶然的。 </p>
</blockquote>
<p>作者也在本章比较了民选领导人和独裁者在维护核心支持者这件事情上的难度。最终指出，因为很难构建小的致胜联盟，所以民选领导人更容易下台。而独裁者开始的时候比较容易被人推翻，但是一旦独裁者构建成功致胜联盟，那么就很难下台了。</p>
<h2 id="u7B2C5_u7AE0_uFF1A_u7A83_u8D2B_u6D4E_u5BCC"><a href="#u7B2C5_u7AE0_uFF1A_u7A83_u8D2B_u6D4E_u5BCC" class="headerlink" title="第5章：窃贫济富"></a>第5章：窃贫济富</h2><p>本章主要是讲的如何获得金钱。政治的5个基本法则中，第3条就是获得掌控收入的分配。如果无法获得足够的金钱，就无法构建致胜联盟。在这方面，书中提到了一些办法。</p>
<h3 id="u7EE7_u627F_u8D22_u5BCC"><a href="#u7EE7_u627F_u8D22_u5BCC" class="headerlink" title="继承财富"></a>继承财富</h3><p>对于民选国家，财政可以从上一任领导班子中获得。但对于独裁者来说，通常这部分金钱是保密的，所以比较难找到。所以，「知道钱在哪里」在独裁国家尤其重要。利比里亚在多伊被推翻后，因为没有人有足够的资源控制全国，每个派别在小范围内收买支持者，所以全国陷入了内战。</p>
<h3 id="u5F81_u7A0E"><a href="#u5F81_u7A0E" class="headerlink" title="征税"></a>征税</h3><p>征税面临三个限制：</p>
<ul>
<li>第一，征税会削弱人们工作的热情。</li>
<li>第二，一些税收方面的负担不可避免地会落到领导人的关键支持者身上。</li>
<li>第三，收税需要专业知识和资源。收税的成本限制了领导人能够榨取什么并影响到征税方法的制定。 </li>
</ul>
<p>一般来讲，第一点限制了独裁国家的税收，第二点限制了民主国家的税收。</p>
<h3 id="u5F00_u91C7_u8D44_u6E90"><a href="#u5F00_u91C7_u8D44_u6E90" class="headerlink" title="开采资源"></a>开采资源</h3><p>相比于征税，直接从自然资源中获得财富要容易得多。资源丰富的国家使独裁统治者有能力大规模地回报支持者并聚集起庞大的财富。但是，因为基本法则五，所以这些钱并不会用于改善人民的生活。</p>
<blockquote>
<p>拥有丰富可开采自然资源的国家系统性地落后于资源稀缺的国家。资源丰富的国家经济增长较差，容易发生内战，比资源稀缺国家更具有独裁性。 </p>
<p>为了确保人民无法协同造反、夺取国家控制权，领导人竭力让联盟以外的人保持贫困、无知和散漫状态。具有讽刺意味的是，原本可以用来解决各种社会问题的石油反倒给领导人提供了将这些问题故意变得更糟的政治动机。 </p>
</blockquote>
<p>在本书中，作者举了尼日利亚的例子，尼日利亚据称拥有世界第十大的石油储备。从1970年到2000年，尼日利亚累计获得3500亿美元的石油收入。但尽管拥有巨大的石油财富，但尼日利亚的人均年收入从1970年的1113美元降至2000年的1084美元，该国成为世界上最穷的国家之一。</p>
<h3 id="u501F_u94B1_26amp_3B_u503A_u52A1_u51CF_u514D"><a href="#u501F_u94B1_26amp_3B_u503A_u52A1_u51CF_u514D" class="headerlink" title="借钱&amp;债务减免"></a>借钱&amp;债务减免</h3><p>通过向别的国家借钱或债务减免来获得财富，这通常都伴随着一些政治条件的交换。</p>
<h2 id="u7B2C6_u7AE0_uFF1A_u83B7_u53D6_u4E0E_u82B1_u8D39"><a href="#u7B2C6_u7AE0_uFF1A_u83B7_u53D6_u4E0E_u82B1_u8D39" class="headerlink" title="第6章：获取与花费"></a>第6章：获取与花费</h2><p>本章讨论可以把钱花在哪些地方，包括：教育、医疗、清洁的饮用水、基础设施建设、自由（出版自由、言论自由、集会自由等）。</p>
<p>非常有意思的是，在独裁国家，领导人除了限制自由之外（这一点很好理解），也会限制教育、医疗或基础设施建设。因为这都有助于推翻独裁者的统治。</p>
<blockquote>
<p>不论是独裁者还是民主领导人都面临相似的问题：什么范围的教育才是适量的？对于那些依赖极少数支持者的领导人来说，答案显而易见。教育机会不能太广泛，以至于普通人，也就是可相互替代者因受到教育而质疑政府的权威。</p>
<p>考察领导人对教育的兴趣，有一个更好的衡量办法，就是看顶尖大学在世界上的分布情况。除了几个特例之外，没有任何一个非民主国家拥有排名世界200强的大学。那些人口较少、依赖大量核心支持者的国家，比如以色列、芬兰、挪威、荷兰、比利时、加拿大，无一不拥有多所大学进入世界200强。</p>
</blockquote>
<p>看到这里我顺便查了一下，中国的清华大学、北京大学排在全球<a href="http://www.qianmu.org/ranking/1528.htm" target="_blank" rel="external">第25名和第41名</a>。</p>
<h2 id="u7B2C7_u7AE0_uFF1A_u8150_u8D25_u4F7F_u4EBA_u6709_u6743"><a href="#u7B2C7_u7AE0_uFF1A_u8150_u8D25_u4F7F_u4EBA_u6709_u6743" class="headerlink" title="第7章：腐败使人有权"></a>第7章：腐败使人有权</h2><p>对于独裁国家，腐败是一种提供私人报酬的方式，并且这种方式同时可以让动摇的联盟成员随时可能失去特权并被检控。</p>
<blockquote>
<p>尽管私人报偿可以直接由政府财政拨给警察，补偿警察忠诚表现的最简单方式就是给予他们自由腐败的空间。工资这么少，他们必定会意识到腐败不仅可以接受也是必须的。然后他们会加倍效忠于政权：首先，他们会感谢政权给他们敛财的机会；其次，他们会明白，如果他们三心二意，将很可能失去特权并被检控。</p>
</blockquote>
<p>对于民主国家，腐败的表现形式更加多样化，例如以扭曲的公共政策的形式出现。例如为富人的一些健康问题提供更多研究资金、为富人提供更为温和的税收政策等。</p>
<blockquote>
<p>富裕人群和共和党候选人总的来说赞成政府对癌症、阿尔茨海默症以及其他老年病的医学研究提供支持，这些老人恰好构成了美国最富有的年龄层。</p>
</blockquote>
<p>本文讨论了两个小致胜联盟的团体：国际足联和国际奥委会的丑闻，并且指出在这种小团体中，腐败几乎是无法避免的，唯一的办法是扩大致胜联盟的数量。</p>
<p>当独裁者通过腐败给予了致胜联盟合理的回报之后，剩下的钱就是他的自由裁量的资金了。他可以把这个钱存在自己秘密的银行帐号上，也可以用于改善人民的生活。不过文章也指出，很多时候改善人民的生活并不是那么容易的事情。</p>
<blockquote>
<p>赫鲁晓夫计划实施一项农业改革。尽管出发点是善良的，赫鲁晓夫的农业计划和实施却是一场灾难。为了取悦赫鲁晓夫，并出于对达不到期望所带来的政治后果的可能担忧，地方官员们承诺尽力去完成他对于提高产量的要求。以苏联原始的农业技术来说，他们的承诺当然不可能实现。赫鲁晓夫的善意理念的结果就是，农民甚至不得不连种牛都杀掉以完成他们的肉类生产配额。</p>
</blockquote>
<p>这一点和中国的大跃进时期遇到的问题如出一辙。</p>
<h2 id="u7B2C8_u7AE0_uFF1A_u5BF9_u5916_u63F4_u52A9"><a href="#u7B2C8_u7AE0_uFF1A_u5BF9_u5916_u63F4_u52A9" class="headerlink" title="第8章：对外援助"></a>第8章：对外援助</h2><p>对于独裁国家的援助，很多时候都进了独裁者的口袋，而援助国很多时候对此是知情的，援助国对此睁一只眼闭一只眼的原因是：他在谋求某种政治交换。</p>
<blockquote>
<p>很难相信援助机构会天真到不明白他们的资金遭误用。也许真相存在于美国国际开发署的另一个目标上—“增进美国外交政策的利益”。也许美国更感兴趣的是在对抗全球恐怖主义的战略中拥有一个可靠的盟友，以及在打击印度洋的索马里海盗方面获得帮助。 </p>
</blockquote>
<p>由于援助很多时候并没有改善人民的生活，所以援助国的形象甚至都是负面的。</p>
<blockquote>
<p>2002年，皮尤研究中心在42个国家展开了一项民意调查。其中一个问题是问人们对美国的看法。在巴基斯坦，69%的受访者表示对美国极其厌恶。在埃及，这个数字是79%。在其他40个国家，平均只有11%的人对美国持有极端负面的评价。然而2002年巴基斯坦和埃及从美国平均获得了16亿美元的经济和军事援助，而其他40个国家平均只获得9700万美元的援助。这一模式被详细的统计分析所证实。获得大量美国援助的国家的人民看来很仇视美国。</p>
</blockquote>
<h2 id="u7B2C9_u7AE0_uFF1A_u53CD_u53DB_u4E2D_u7684_u4EBA_u6C11"><a href="#u7B2C9_u7AE0_uFF1A_u53CD_u53DB_u4E2D_u7684_u4EBA_u6C11" class="headerlink" title="第9章：反叛中的人民"></a>第9章：反叛中的人民</h2><p>对于人民来说，反对独裁是非常正常的。但是作者指出，如果人民还能够发出反叛或抗议的声音，就说明政府还是相对温和的。真正的独裁者是不会让人有一丝抗议的声音。</p>
<blockquote>
<p>谨慎老到的独裁者都将反叛扼杀在萌芽状态。这就是为什么我们一再重申，只有那些愿意做真正肮脏勾当的人才适合盘算成为独裁者。心慈手软的人一眨眼工夫就会被人搞掉。 </p>
</blockquote>
<p>如果军队不对人民的抗议采取措施，通常都表明，独裁者的致胜联盟出现了动摇。「安全部队拿不准是否能保住长期的特权，拒绝镇压群众，两面下注。」这种做法使得安全部队最终是站在胜者的一边的，这是一种更为自保的行为。</p>
<blockquote>
<p>近代以来不少重大政治历史事件，从法国大革命到苏联及其卫星国的崩溃，都缘于政权的核心支持者不愿在关键时刻镇压人民。近年来的所谓“颜色革命”（格鲁吉亚2003年的玫瑰革命、乌克兰2004—2005年的橙色革命以及2005年吉尔吉斯斯坦的郁金香革命），突尼斯的茉莉花革命以及埃及革命，都展现了同一现象。 </p>
</blockquote>
<h2 id="u7B2C10_u7AE0_uFF1A_u6218_u4E89_u3001_u548C_u5E73_u4E0E_u4E16_u754C_u79E9_u5E8F"><a href="#u7B2C10_u7AE0_uFF1A_u6218_u4E89_u3001_u548C_u5E73_u4E0E_u4E16_u754C_u79E9_u5E8F" class="headerlink" title="第10章：战争、和平与世界秩序"></a>第10章：战争、和平与世界秩序</h2><p>对于民主国家，战争和对外援助都是为了同一目的，只是一个更强势，另一个更温和。</p>
<blockquote>
<p>对民主领导人而言，战争不过是达到对外援助想要达到的目标的另一种方式。对外援助收买受援国的政策让步，战争则强加政策让步。</p>
</blockquote>
<p>对于美国来说，中东政策的核心就是能源政策，为的是给美国经济运转带来稳定的能源供给。</p>
<blockquote>
<p>如果说能源政策不是美国中东政策的一个主要决定因素甚至是最主要决定因素，那就太天真了，但这并不意味着是拿士兵的生命去换石油财富。美国的目标是保护石油的供应，因为石油为世界经济机器的运转提供了能源。联盟的目标是经济稳定而不是私人回报。</p>
</blockquote>
<p>由于战争的胜负决定着民主国家领导人的政治安全，所以民主国家更喜欢打肯定赢的战争。</p>
<blockquote>
<p>民主国家专挑软柿子捏毫不稀奇。回顾过去近200年，民主国家赢得了93%由它们挑起的战争。相比之下，非民主国家只赢下60%由它们发起的战争。</p>
</blockquote>
<h2 id="u7B2C11_u7AE0_uFF1A_u600E_u4E48_u529E"><a href="#u7B2C11_u7AE0_uFF1A_u600E_u4E48_u529E" class="headerlink" title="第11章：怎么办"></a>第11章：怎么办</h2><p>本章讨论了一些办法来解决前面提到的独裁问题，最直接的办法就是扩大致胜联盟的规模，使得独裁者无法为海量的联盟成员提供私人报酬，所以只能提供面向所有人的公共服务地方式来获得选票。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/dictators-handbook-book.jpg">
<h1 id="u8BFB_u4E66_u5FC3_u5F97"><a href="#u8BFB_u4E66_u5FC3_u5F97" class="headerlink" title]]>
    </summary>
    
      <category term="books" scheme="http://blog.devtang.com/tags/books/"/>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[美团到底为什么从 AppStore 下架]]></title>
    <link href="http://blog.devtang.com/2016/06/26/why-meituan-is-removed-from-appstore/"/>
    <id>http://blog.devtang.com/2016/06/26/why-meituan-is-removed-from-appstore/</id>
    <published>2016-06-26T15:08:39.000Z</published>
    <updated>2016-06-26T15:28:34.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/meituan.jpg">
<h2 id="u6545_u4E8B_u80CC_u666F"><a href="#u6545_u4E8B_u80CC_u666F" class="headerlink" title="故事背景"></a>故事背景</h2><p>6 月 23 日（上周四）晚上，美团公司旗下的所有 App（包括美团团购、美团外卖、猫眼电影等 13 款）被苹果下架。一时间谣言四起，网上传得最多的原因是美团没有支付牌照，被实名举报，所以被下架了。而美团对外称是由于技术原因下架，正在和苹果沟通。</p>
<p>6 月 24 日上午，美团公司的全线产品重新上架成功。而美团和苹果公司均没有对外详细透露此次下架原因。</p>
<p>但是，此次事件里面反映出很多有意思的细节，值得和大家分析一下。</p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><h3 id="u5FD8_u8BB0_u7EED_u8D39"><a href="#u5FD8_u8BB0_u7EED_u8D39" class="headerlink" title="忘记续费"></a>忘记续费</h3><p>首先我们来分析一下美团是否是因为忘记续费而被下架。做 iOS 开发的应该都知道，当我们的开发者帐号快要到期时，iTunesConnect 后台的顶部会出现黄色的警告提示，另外开发者的邮箱也会收到相应的邮件提醒。</p>
<p>美团旗下有 13 款应用，按照应用发版的频率，肯定会有工程师看到 iTunesConnect 后台的警告。因此，忘记续费这种事情实在是不太可能发生的。</p>
<h3 id="u724C_u7167_u95EE_u9898"><a href="#u724C_u7167_u95EE_u9898" class="headerlink" title="牌照问题"></a>牌照问题</h3><p>我们再来看看网上传得最多的理由：牌照问题。美团确确实实没有支付牌照，但是，如果真的是因为这个理由被全线下架，那么为什么仅仅过了一天又全线上架了？</p>
<p>美团到现在也没有获得支付牌照，它旗下的 13 款应用在恢复上架后也没有做明显的功能改动。所以如果它因为这个理由被下架，那么理应在获得牌照，或者关闭相应功能后才能重新上架。</p>
<p>我查了一下，在恢复上架后，美团的应用最后更新时间是 6 月 20 日，美团外卖的最后更新时间是 6 月 2 日。这就说明这些 App 并没有做任何功能改动就重新上架了。</p>
<img src="/images/meituanwaimai-updatetime.jpg">
<p>因此，牌照问题这个理由也是站不住脚的。</p>
<h3 id="u4E0B_u67B6_u7406_u7531_u731C_u6D4B"><a href="#u4E0B_u67B6_u7406_u7531_u731C_u6D4B" class="headerlink" title="下架理由猜测"></a>下架理由猜测</h3><p>那么，还有什么可能的下架理由吗？我突然想起来我以前在网易有道听到过的一个故事。</p>
<blockquote>
<p>有一家公司的 App 有个小问题，苹果的审核人员想让他们做一个修改，但是，苹果发现这家公司留的 Agent 帐号里的电话号码打不通（或者没人接），于是苹果就霸气地把人家的 App 直接下架了。这家公司当然慌了，赶紧联系苹果，于是这个小修改迅速被执行了，App 被重新上架。</p>
</blockquote>
<p>美团有可能遇上了类似的遭遇吗？我感觉是很有可能的。因为苹果在应用市场一贯强势的态度，让各大互联网公司都不敢怠慢。</p>
<p>而这种理由，也是最最可能不被苹果和美团公开的。因为对于苹果来说，因为联系不上就把人家全线 App 下架明显做法不太厚道。而对于美团来说，因为不敢得罪苹果，加上自己失误在先，也会选择不公开原因。</p>
<p>于是，技术原因就成了对外的公关说辞了。</p>
<h2 id="u6211_u89C1_u8FC7_u7684_u4E0B_u67B6_u4E8B_u4EF6"><a href="#u6211_u89C1_u8FC7_u7684_u4E0B_u67B6_u4E8B_u4EF6" class="headerlink" title="我见过的下架事件"></a>我见过的下架事件</h2><p>在我的 iOS 开发经历中，除了上面讲的那个沟通不畅带来的下架外，我还知道两次下架事件。</p>
<p>一次下架事件是关于抄袭的。2012 年 9 月，大众点评向苹果举报食神摇摇抄袭大众点评内容，于是食神摇摇被苹果 App Store 下架。这次算是公司维护知识产权的一次正常博弈。</p>
<p>另一次下架事件是关于人人网的。2013 年，人人网旗下的游戏因为在 AppStore 恶劣地刷榜行为，被苹果全线下架。AppStore 的刷榜行为其实到现在也没有停息过，而且做得更加隐蔽，我们公司也深受其害，而且我们向苹果举报也不管用，我本周会另外撰文介绍那些不为人知的刷榜手段。</p>
<h2 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h2><p>这个事情还有一点比较奇怪的是，我私下认识一些美团的 iOS 开发，连他们都不知道这件事情的背后原因，让这件事情更加神秘了。</p>
<p>另外，我了解到像微信这种海量用户的 App，会被苹果的审核团队特别照顾。除了能够获得快速的审核外，审核员也会和微信团队有更加密切的交流，以便微信能够快速响应审核意见。</p>
<p>我个人认为，除了微信以外，像美团这种在中国区 AppStore 总榜前十的应用，也理应受到这样的审核照顾。这种野蛮的下架，对于中国区的 iPhone 用户来说，也是一种伤害。</p>
<p>就在发稿前，美团在 AppStore 排名总榜第五（下图）。</p>
<img src="/images/meituan-rank.jpg">
<p>苹果现在更加重视中国市场了，而应用审核时更加良好的沟通，就是对于中国市场和开发者最大的激励，期望 AppStore 中国区越来越好。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/meituan.jpg">
<h2 id="u6545_u4E8B_u80CC_u666F"><a href="#u6545_u4E8B_u80CC_u666F" class="headerlink" title="故事背景"></a>故事背景]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我与 InfoQ 的故事]]></title>
    <link href="http://blog.devtang.com/2016/06/26/my-story-about-infoq/"/>
    <id>http://blog.devtang.com/2016/06/26/my-story-about-infoq/</id>
    <published>2016-06-26T13:28:29.000Z</published>
    <updated>2016-06-26T13:28:44.000Z</updated>
    <content type="html"><![CDATA[<p>如果你也喜欢写作，这个真实的故事或许能够帮助你继续坚持下去。</p>
<p>我最早听说 <a href="http://www.infoq.com/cn" target="_blank" rel="external">InfoQ</a> ，是因为在上面发现了很多关于敏捷开发的文章。可以说，InfoQ 是最早推广敏捷软件开发的社区。之后 InfoQ 的内容范围开始扩展，除了敏捷外，服务器开发，移动开发的内容也都有了。</p>
<p>在我心目中，InfoQ 网站上的文章一直是「高大上」的，直到有一天，我的老大常圳看到我常常写博客，推荐我向 InfoQ 投稿时，我才发现，或许我可以把「向 InfoQ 投稿」作为一个长远的目标。</p>
<p>我最早的投稿文章都是偏 iOS 开发工具类的，那个时候网上的 iOS 文章很少，有一些好用的工具并不是那么普及，于是我就将我熟悉的 <a href="http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles" target="_blank" rel="external">Charles</a>, Reveal, <a href="http://www.infoq.com/cn/articles/crashlytics-crash-statistics-tools" target="_blank" rel="external">Crashlytics</a> 等工具整理成文章发表到了 InfoQ 上。很感谢 InfoQ 的水哥和杨赛两位编辑，他们对于我这个新手非常 Nice，对于文章内容也提了很多有价值的意见。这些文章在 InfoQ 上的发表给了我最初的信心。</p>
<p>于是我开始写一些更难的 iOS 技术文章，包括分析 Tagged Pointer 实现的：<a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="external">《深入理解Tagged Pointer》</a>、block 的实现原理等。</p>
<p>最终，我发现这些文章已经足够汇集成一本书了，于是我就出版了<a href="http://item.jd.com/11598468.html" target="_blank" rel="external">《iOS 开发进阶》</a>。所以，如果没有 InfoQ 最初的鼓励，应该就没有这本书的出版。</p>
<p>也正是因为我在 iOS 领域的文章得到了 InfoQ 和读者的认可，也才使得我更加大胆地表达意见。包括推广 ReactiveCocoa 的文章：<a href="http://www.infoq.com/cn/articles/reactivecocoa-ios-new-develop-framework" target="_blank" rel="external">《ReactiveCocoa - iOS开发的新框架》</a>，以及警示大家避免过于崇拜 MVVM 和函数式编程的文章：<a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm" target="_blank" rel="external">《被误解的MVC和被神化的MVVM》</a>，以及关于 Swift 的<a href="http://www.infoq.com/cn/articles/swift-brain-gym-monad" target="_blank" rel="external">一些思考</a>。</p>
<p>现在的我更加自信，我可以明确地表达出自己的技术观点，包括对于 Core Data 的厌恶，对于 Realm 的警慎，对于 React Native 的悲观，对于 Xib 的漠视，对于自动化测试的遗憾。这些观点在新人口中说出很可能会被认为无知，而我有信心坚持自己的观点。</p>
<p>我在快速成长，InfoQ 也是。现在的 InfoQ ，已经成长为极客邦，旗下除了 <a href="http://www.infoq.com/cn" target="_blank" rel="external">InfoQ</a>，还包括 <a href="http://git.geekbang.org/" target="_blank" rel="external">GIT</a>，<a href="http://ego.geekbang.org/" target="_blank" rel="external">EGO</a> 和 <a href="http://www.stuq.org/" target="_blank" rel="external">StuQ</a>。而 InfoQ 主办的 QCon 、ArchSummit 已经成为全中国最有名的技术会议。在今年，InfoQ 开始涉足垂直领域，上周刚刚结束的<a href="http://gmtc.geekbang.org/" target="_blank" rel="external">全球移动技术大会（GMTC）</a> 就是一次成功的移动端会议。</p>
<p>现在，InfoQ 不但有网站了，也有微信公众号，里面的推送内容有相当一部分都是移动开发相关的，例如：</p>
<ul>
<li>携程移动 App 架构优化之旅（编号 21）</li>
<li>全栈工程师谈微博 iOS 客户端架构与优化之路（编号 22）</li>
<li>京东无线服务端架构演进历程（编号 23）</li>
<li>滴滴 iOS 客户端的架构演变之路（编号 24）</li>
<li>偷师饿了么：怎样用 HTTP/2 优化 iOS APP 网络层次架构？（编号 25）</li>
<li>被误解的 MVC 和被神化的 MVVM（我的投稿，编号 28）</li>
</ul>
<img src="/images/infoq-wexin.jpg">
<p>这些文章都是非常有阅读价值的，长按上面的二维码，关注 InfoQ 后，在 InfoQ 的微信公众号回复相应编号，就可以看到相关文章。</p>
<p>感谢 InfoQ 一直以来对我的帮助，如果你也希望像我一样成为技术作者，那么可以从尝试给 InfoQ 投稿做起，相信你一定会收获很多。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果你也喜欢写作，这个真实的故事或许能够帮助你继续坚持下去。</p>
<p>我最早听说 <a href="http://www.infoq.com/cn" target="_blank" rel="external">InfoQ</a> ，是因为在上面发现了很多关于敏捷开发]]>
    </summary>
    
      <category term="writing" scheme="http://blog.devtang.com/tags/writing/"/>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么提交 AppStore 总有事故发生]]></title>
    <link href="http://blog.devtang.com/2016/06/19/appstore-accident/"/>
    <id>http://blog.devtang.com/2016/06/19/appstore-accident/</id>
    <published>2016-06-19T12:23:24.000Z</published>
    <updated>2016-06-19T12:32:05.000Z</updated>
    <content type="html"><![CDATA[<p>6 月 18 日上午，百度云 iOS 版出现了线上事故，他们在提交 AppStore 审核的时候，把名字给弄错了。用户更新 App 之后，看到的 App 名字是 netdisk_iPhone，如下图所示。此后，百度在当天紧急提交了一个加急版本，修复了该问题。</p>
<img src="/images/baidu-bug-1.jpg">
<p>百度云在 AppStore 总榜中排名 50 名左右，这次事故虽然不太影响用户使用，但是确实会给用户感觉到一些困扰。比如因为它的名字实际上不存在，所以当它想获取 PUSH 消息权限时，弹出来的对话框是如下图这样。用户很可能会觉得奇怪，从而点击 “不允许”。</p>
<img src="/images/baidu-bug-2.jpg">
<p>在大厂里面，不止百度犯过错误，大约在一年前，新浪微博的客户端不小心把调试选项给加包到了正式功能中。于是大家都乐坏了，各种给自己加 VIP 效果，当然，服务器端的验证逻辑还是存在的，所以倒也并没有产生非常大的事故。下图是当时新浪微博事故 App 的截图。</p>
<img src="/images/sina-bug.jpg">
<p>也不能光说别人，其实我们公司前段时间也出现了一个线上事故。猿辅导 App 不小心把测试版给提交到 AppStore 上了，但是由于测试服务器地址不是对外网公开的，于是更新了的同学就无法正常使用 App 了。这个事故大概影响了我们将近一天时间，线上服务完全连不上，算是比较严重的了。</p>
<p>我见过的最最严重的事故，大概是两年前，某个上市公司出的金融类应用，在打包的时候，不小心把源代码打进了 IPA 里面。这个行为恰好被喜欢解 IPA 随意翻翻的 BeeFramework 的老郭看到了，于是大家一起围观了一下它的代码。好在大家都是圈内人，没什么恶意，所以也没有公开此事。不然，用这个代码随意做一些社交机器人或者抓取机器人还是挺容易的。</p>
<p>好了，关键来了。如何防止这类事故发生呢？我觉得做到以下几点应该就可以了：</p>
<ol>
<li>不需要到线上的调试代码，需要用 DEBUG 宏在代码里面明确禁掉。</li>
<li>将整个工程的配置，用 shared scheme 的方式，放在版本管理之下，所有的配置改动，都需要进行 review。</li>
<li>使用自动打包的脚本，不依赖人工进行打包操作。</li>
<li>在正式上线前，用苹果的 TestFlight 进行测试。TestFlight 的测试包可以做到和线上的包完全一致，所以像以上提到的所有问题，都可以在这一个环节发现。</li>
</ol>
<p>百度云的这次事故，很可能的原因是被开发误删除了配置中的 App Name，如果采用上面的步骤，那么在第二步和第四步中，将会发现这个问题。</p>
<p>大家有什么更好的办法吗？欢迎回复讨论。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>6 月 18 日上午，百度云 iOS 版出现了线上事故，他们在提交 AppStore 审核的时候，把名字给弄错了。用户更新 App 之后，看到的 App 名字是 netdisk_iPhone，如下图所示。此后，百度在当天紧急提交了一个加急版本，修复了该问题。</p>
<im]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WWDC 2016 随想]]></title>
    <link href="http://blog.devtang.com/2016/06/14/wwdc-2016-notes/"/>
    <id>http://blog.devtang.com/2016/06/14/wwdc-2016-notes/</id>
    <published>2016-06-14T14:32:50.000Z</published>
    <updated>2016-06-19T12:32:09.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/wwdc-2016.jpg">
<p>今天凌晨 1 点钟，熬夜看了今年的 WWDC，一些随想分享给大家。</p>
<h2 id="u82B1_u7D6E"><a href="#u82B1_u7D6E" class="headerlink" title="花絮"></a>花絮</h2><p>我为了半夜起来看 WWDC，特意提前 10 点钟就睡觉了。我睡觉前特意带上 Apple watch，并且设置好震动闹钟，免得到时候闹钟吵到家人。结果这傻 watch 在我睡着后先是提醒我看每周运动摘要，然后过半小时又震动提醒我已经静止太久应该活动一下，你妹啊！</p>
<p>不准笑！说你呢！！</p>
<h2 id="u65F6_u5149"><a href="#u65F6_u5149" class="headerlink" title="时光"></a>时光</h2><p>因为刚刚说的原因，结果我到 12 点都还没有睡着，我在迷迷糊糊中躺到了快一点钟，watch 震动了，于是我翻身走到客厅，打开电脑，连上直播地址。对了，还有一些朋友不知道直播地址，大家可以记一下，每年直播地址都是固定的：<wwdc.apple.com> 。</wwdc.apple.com></p>
<p>我还记得我刚毕业那阵子，也是熬夜看 WWDC，那个时候我还和老婆租的房子住，并且和校友一起合租的一个两居室。想想也就过去几年，现在自己有了更大的房子住，而整个移动互联网也成就了大量的百亿市值的公司。Tim Cook 在直播中提到，AppStore 是 8 年前出现的，再次感叹到移动互联网真的是好年轻啊。</p>
<h2 id="u5185_u5BB9"><a href="#u5185_u5BB9" class="headerlink" title="内容"></a>内容</h2><p>这次的 WWDC keynote 主要分成 4 个部分，其实就是四个平台：watchOS, tvOS，macOS（原来叫 OS X）, iOS。整个分享中规中矩，分别给大家介绍一下我觉得值得关注的改进吧。</p>
<h3 id="watchOS"><a href="#watchOS" class="headerlink" title="watchOS"></a>watchOS</h3><p>watchOS 推出了 watchOS 3，据说启动速度更快了，但是不知道耗电是不是也是更多了。关于这个，后续有一个 session 主题分享<a href="https://developer.apple.com/videos/play/wwdc2016/227/" target="_blank" rel="external">《Architecting for Performance on watchOS 3》</a>，感兴趣的朋友可以关注。</p>
<p>增加了 scribbles 功能，其实就是一种手写输入，手写居然还支持中文，我当时就在想：你倒是写一个复杂一点的字试试看呢？我对此功能不太看好。</p>
<p>别的改进都很小，比如增加了滑动更换主题，快速报警，现场还花大力气介绍一款叫 breathe 的应用，而这个应用就是指导你深呼吸的。不知道大家喜不喜欢，反正我是不会用的。</p>
<h3 id="tvOS"><a href="#tvOS" class="headerlink" title="tvOS"></a>tvOS</h3><p>这部分直接跳过吧，原因你懂的。</p>
<h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>OS X 更名为了 macOS，可以支持通过 apple watch 解锁电脑了。哦耶，我的手表终于不再只是用来看时间了 ! </p>
<p>剪切版支持从手机上复制，在电脑上粘贴，这个还是挺有用的，我平常都是用 QQ 或微信的文件传输助手做类似的事情。</p>
<p>optimize storage 功能可以把老文件自动存在云端，据说可以节省大概 100G 的空间。不过我猜想，iCloud 的免费空间应该不够用吧？是不是得花钱买些容量才行。</p>
<p>apple pay 可以在 PC 的浏览器上直接支付，点击支付时，需要在手机上确认授权。整个体验类似于拿微信或支付宝扫二维码付款。</p>
<p>siri 可以在 mac 上使用了，并且 siri 的结果可以 pin 在一个列表中，并可以拖动到别的地方。我有一阵子很喜欢用 iPhone 上的 siri，不过还是不太稳定。mac 上一般办公室是不太方便用 siri 的，家里的话要是没有培养出习惯，估计也不太会使用。所以这个功能到底实用性有多大还不确定。</p>
<p>增加了一个名为 picture in picture 的功能，其实就是看视频的时候可以固定住视频。</p>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p>介绍了 10 个特性，我选一些有意思的介绍吧。</p>
<p>Siri 可以和微信整合，这个很赞，你可以直接用 siri 控制发信息给微信中的好友。</p>
<p>系统的 Map 整合了大量的应用，比如可以在上面看大众点评的评价，可以直接叫滴滴打车。如果做得好，Map 很可能成为一个重要的打车入口，想到这儿就能明白为什么苹果投了滴滴 10 亿美金了。不过就苹果系统 Map 的那个糟糕体验，我不确定我是否能够接受它。反正我已经喜欢上了高德地图里面的郭德纲和林志玲的声音，离线的地图和导航也很适合中国这种按流量计费的移动网络环境。相比而言，系统自带的 Map 有些不接地气。</p>
<p>homekit 与智能家居的整合，整体的效果非常酷，但整个还需要依赖生态产业的配合。当前来看，国内的小米在这方面做得比苹果还是要快一些。</p>
<p>电话功能终于支持恶意电话提醒了，现场提到用的是腾讯的解决方案。嗯，360 估计是没有翻身的可能了。另外，phone  extension 似乎可以做更多的事情。</p>
<p>iMessage 可以发更多的内容，tap to replace to emoji 功能的交互设计还是挺有意思的，省却了选择 emoji 的时间。不过现场演示出现了 Bug，还是挺尴尬的。另外，大家都已经习惯了微信，而且 iMessage 只能和 iPhone 用户发，我觉得这些功能做得再有意思，也没有多大用。大家的直觉还是用微信来社交。</p>
<h3 id="u4E2D_u56FD_u5143_u7D20"><a href="#u4E2D_u56FD_u5143_u7D20" class="headerlink" title="中国元素"></a>中国元素</h3><p>这次 WWDC 中多次提到了中国，以及中国的互联网产品，包括微信，大众点评，滴滴。中国为苹果的赢收增长做出了巨大的贡献，我们也能看到苹果越来越重视中国区的需求了。比如恶意来电提醒，就是一个特别针对中国区用户的设计。</p>
<h3 id="Developer"><a href="#Developer" class="headerlink" title="Developer"></a>Developer</h3><p>这次 Tim Cook 专门介绍了针对开发者做的 iPad 版的 Swift Playground，其实这哪是一个 Playground 啊，这就是一个学习编程的 3D 游戏！整个 App 设计得非常用心，效果看起来也非常棒，下面是这个应用的界面，大家感受一下。</p>
<img src="/images/ipad-swift-playground.png">
<p>不过 Tim Cook 毕竟是做销售出身的，他不明白，其实我们真正关心的是，Swift 3 什么时候推出啊！结果他在 keynote 上啥都没说，让我们以为 Swift 3 没戏了，结果，我们事后又发现 Swift 3 的内容安静地躺在苹果的官方网站上：<a href="https://developer.apple.com/swift/" target="_blank" rel="external">https://developer.apple.com/swift/</a> 。</p>
<p>所以说，Tim Cook 还是不了解我们， iPad 版的 Swift Playground 太酷，那也就是给小孩学编程入门用的，大量的程序员还是关心的是 Swift 啥时候稳定，Xcode 有啥有意思的功能不，这些都被 Cook 给忽视了。</p>
<p>还算我眼睛尖，我在他的一页大量的 feature list 中，看到了下面的一行字：</p>
<p><img src="http://ww4.sinaimg.cn/mw690/65dc76a3jw1f4u663wkc6j20bv05ct9e.jpg" alt=""></p>
<p>这意味着，Xcode 终于官方支持插件了！妈妈再也不用担心升级 Xcode 的时候插件失效了！我今天翻了一下日程，WWDC 中专门有一个 session 做相关的介绍，是：<a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="external">《Using and Extending the Xcode Source Editor》</a></p>
<h2 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h2><p>最后看完 WWDC，已经是零辰 3 点钟了，有一点点失落。今年的内容惊喜不多，但是，我终归是又一次熬夜观看了直播。希望自己能保持这样对技术的激情，也希望苹果明年的 WWDC 能有一些惊喜。</p>
<p>哦，我整理了一个后续值得观注的 session 列表，分享给大家：</p>
<blockquote><p>Improving Existing Apps with Modern Best Practices<br><a href="https://developer.apple.com/videos/play/wwdc2016/213/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/213/</a></p>
<p>What’s New in Cocoa Touch<br><a href="https://developer.apple.com/videos/play/wwdc2016/205/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/205/</a></p>
<p>What’s New in Foundation for Swift<br><a href="https://developer.apple.com/videos/play/wwdc2016/207/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/207/</a></p>
<p>What’s New in UICollectionView in iOS 10<br><a href="https://developer.apple.com/videos/play/wwdc2016/219/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/219/</a></p>
<p>Typography and Fonts<br><a href="https://developer.apple.com/videos/play/wwdc2016/803/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/803/</a></p>
<p>Advanced Testing and Continuous Integration<br><a href="https://developer.apple.com/videos/play/wwdc2016/409/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/409/</a></p>
<p>Debugging Tips and Tricks<br><a href="https://developer.apple.com/videos/play/wwdc2016/417/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/417/</a></p>
<p>Getting Started with Swift ( 有最新 Swift 3 的内容）<br><a href="https://developer.apple.com/videos/play/wwdc2016/404/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/404/</a></p>
<p>Going Server-side with Swift Open Source<br><a href="https://developer.apple.com/videos/play/wwdc2016/415/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/415/</a></p>
<p>Introduction to Xcode ( 看看 Xcode 8 的新功能有啥）<br><a href="https://developer.apple.com/videos/play/wwdc2016/413/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/413/</a></p>
<p>Swift API Design Guidelines<br><a href="https://developer.apple.com/videos/play/wwdc2016/403/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/403/</a></p>
<p>Understanding Swift Performance<br><a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/416/</a></p>
<p>Using and Extending the Xcode Source Editor（了解 Xcode 编辑器的插件功能）<br><a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/414/</a></p>
<p>What’s New in LLVM<br><a href="https://developer.apple.com/videos/play/wwdc2016/405/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/405/</a></p>
<p>What’s New in Swift<br><a href="https://developer.apple.com/videos/play/wwdc2016/402/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/402/</a></p>
<p>What’s New in Xcode App Signing<br><a href="https://developer.apple.com/videos/play/wwdc2016/401/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/401/</a></p>
<p>Concurrent Programming With GCD in Swift 3<br><a href="https://developer.apple.com/videos/play/wwdc2016/720/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/720/</a></p>
<p>NSURLSession: New Features and Best Practices<br><a href="https://developer.apple.com/videos/play/wwdc2016/711/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/711/</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/wwdc-2016.jpg">
<p>今天凌晨 1 点钟，熬夜看了今年的 WWDC，一些随想分享给大家。</p>
<h2 id="u82B1_u7D6E"><a href="#u82B1_u7D6E" class="headerlink" ti]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给程序员的管理入门课程 -《格鲁夫给经理人的第一课》]]></title>
    <link href="http://blog.devtang.com/2016/06/06/high-output-management-summary/"/>
    <id>http://blog.devtang.com/2016/06/06/high-output-management-summary/</id>
    <published>2016-06-06T15:50:00.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5E8F"><a href="#u5E8F" class="headerlink" title="序"></a>序</h2><img src="/images/high-output-management-book.png">
<p><a href="http://item.jd.com/11232323.html" target="_blank" rel="external">《格鲁夫给经理人的第一课》</a> 最早出版于 2007 年，书原名为《High Output Management》。本书的作者格鲁夫是 Intel 的前 CEO，领导了 Intel 从一家濒临倒闭的存储器公司，转型为微处理器公司，并且在个人 PC 开始流行时，成功和微软缔结 Wintel 联盟，主宰了整个 PC 电脑时代。</p>
<p>格鲁夫是一个技术出身的管理者，在本书中，我们甚至看到他多次用编译器来举例，所以这本书也非常适合有技术背景的读者。</p>
<p>本书主要分为四大部分：</p>
<ul>
<li>第一部分「早餐店的生产线」：用早餐店的经营故事，来类比企业的经营管理，介绍了一些数据分析、产品预测、产品检验的办法，提出了管理杠杆率以及关注于产出的管理原则。</li>
<li>第二部分「打好团体战」：展开论述管理杠杆率，并且讨论了开会、决策和规划。</li>
<li>第三部分「推动组织的巧手」：从企业组织架构入手，谈混合型组织，双重报告，CUA 模型，以及文化价值观。</li>
<li>第四部分「谋事在人」：讲人员管理。涉及激励、工作成熟度、绩效评估、招人与留人、报酬与培训。</li>
</ul>
<h2 id="u7B2C_u4E00_u90E8_u5206_uFF1A_u65E9_u9910_u5E97_u7684_u751F_u4EA7_u7EBF"><a href="#u7B2C_u4E00_u90E8_u5206_uFF1A_u65E9_u9910_u5E97_u7684_u751F_u4EA7_u7EBF" class="headerlink" title="第一部分：早餐店的生产线"></a>第一部分：早餐店的生产线</h2><p>本部分用早餐店的经营故事，来类比企业的经营管理。介绍了一些数据分析、产品预测、产品检验的办法。</p>
<h3 id="u7B2C_u4E00_u7AE0_uFF1A_u201C_u751F_u4EA7_u201D__u5305_u542B_u4EC0_u4E48_uFF1F"><a href="#u7B2C_u4E00_u7AE0_uFF1A_u201C_u751F_u4EA7_u201D__u5305_u542B_u4EC0_u4E48_uFF1F" class="headerlink" title="第一章：“生产” 包含什么？"></a>第一章：“生产” 包含什么？</h3><p>格鲁夫认为，一个早餐店的生产线，就包含了一个现代软件开发管理中的各种问题。一个合格的早餐店的生产线，可以在预定的时间内，用最低的成本，做出顾客需要的产品。而现代软件的开发流程，也是希望在一个预定的时间内，用最低的成本，开发出符合产品经理定义的、合格的应用或服务。</p>
<p>这个过程，涉及一些最基本的项目管理工作：找出限制步骤，然后优化流程，形成一个最佳的策略。</p>
<p>在经营早餐店的故事中，限制步骤可能是人员数量、一些机器的产能、或者库存量。通过分析这些限制步骤的成本和收益，你就可以找出一个最价收益的方案。</p>
<p>软件开发中的项目管理也是这样，你的限制步骤可能是人员数量、开发时间、产品功能点、测试时间、或者技术实现方案。找到限制步骤后，通过优化限制步骤就可以优化整个流程。</p>
<h3 id="u7B2C_u4E8C_u7AE0_uFF1A_u4ECE_u65E9_u9910_u5E97_u7684_u5E93_u5B58_u8C08_u8D77"><a href="#u7B2C_u4E8C_u7AE0_uFF1A_u4ECE_u65E9_u9910_u5E97_u7684_u5E93_u5B58_u8C08_u8D77" class="headerlink" title="第二章：从早餐店的库存谈起"></a>第二章：从早餐店的库存谈起</h3><p>格鲁夫认为，我们应该确定和监控早餐店的核心指标，对于一个早餐店来说，核心指标包括：销售预测、原料库存、设备状况、人员情况、品牌评价（用户反馈），并且每天检视这些指标。</p>
<p>另外，作者提到，指标应该有相互的限制，这样避免过度反应。就像软件开发中的软件质量与开发时间一样，不能只追求质量而不管开发时间，也不能只追求时间还不管质量。</p>
<p>其实作者在这章强调的就是数据分析的重要性，在数据分析上，作者介绍了一些方法，包括：</p>
<ul>
<li>先行指标，用于揭示未来信息的指标，例如 NPS，机器故障记录。</li>
<li>线性指标，用于分析进度的指标。</li>
<li>趋势指标，用于分析变化趋势的指标。</li>
<li>重复印证表，用于修正预测行为，提高预测准备性的指标。</li>
</ul>
<img src="/images/hom-1.png">
<img src="/images/hom-2.png">
<p>作者接着提到了计划生产。这个事情是预期未来的销售额而提前生产（放到库存）的一种行为。这里面合理地预测未来是核心，否则要么就会造成没有商品可卖，要么就会造成库存过高。刚刚提到的「重复印证表」可以比较好地帮助我们做预测的调整。</p>
<p>作者接着提到了检验质量。检验质量应该在生产的每个环节都做，但是越早的环节，检验的成本越低。就像我们修复程序的 Bug 这件事情一样，如果我们刚刚写完代码就收到相应的 Bug 报告，那么修复的成本会小很多。但如果我们写完过了一周才收到 Bug 报告，那么我们就需要花精力先回顾当时的逻辑，才能进一步找到有问题的代码。</p>
<p>作者提到了一些检验质量的办法，用于节省检验本身的精力成本。</p>
<p>第一种检验办法是：海关与监视器。海关简单来说就是所有的东西都必须检查，监视器简单来说就是抽样检查。根据具体产品出问题的概率，以及出问题的危害程度，我们可以结合海关的检验方法和监视器的检验方法。</p>
<p>第二种检验办法是：随机检验。随机检验的量应该随着检验结果的好坏有所调整，使得检验有针对性。</p>
<p>本章的最后，作者提出了管理杠杆率的概念，并且用下面的漫画来做了解释。作者认为，通过定义管理的「产出」，我们可以专注于那些提高产出的管理活动，那些高投入产出比的管理活动被作者称作「管理杠杆率」高，进而应该被优先安排和执行。</p>
<img src="/images/hom-3.png">
<h2 id="u7B2C_u4E8C_u90E8_u5206_uFF1A_u6253_u597D_u56E2_u4F53_u6218"><a href="#u7B2C_u4E8C_u90E8_u5206_uFF1A_u6253_u597D_u56E2_u4F53_u6218" class="headerlink" title="第二部分：打好团体战"></a>第二部分：打好团体战</h2><p>本部分介绍了管理的一些经验技巧，涉及管理杠杆率、开会、决策和规划。</p>
<h3 id="u7B2C_u4E09_u7AE0_uFF1A_u7BA1_u7406_u6760_u6746_u7387"><a href="#u7B2C_u4E09_u7AE0_uFF1A_u7BA1_u7406_u6760_u6746_u7387" class="headerlink" title="第三章：管理杠杆率"></a>第三章：管理杠杆率</h3><p>作者首先在本章定义了经理人的产出：</p>
<blockquote>
<p>经理人的产出 = 他直接管辖部门的产出 + 他间接影响所及部门的产出</p>
</blockquote>
<p>格鲁夫介绍了他一天的工作，能够看出来工作内容非常杂乱，也非常多，而且做不完。他说：</p>
<blockquote>
<p>我的一天通常结束在我觉得累而决定回家休息的时候，而不是事情做完了。</p>
<p>像家庭主妇一样，经理人永远有忙不完的事情。</p>
</blockquote>
<p>因为事情永远做不完，所以我们更需要关注于工作的产出，把最高优先级的事情找出来优先安排和执行。</p>
<h4 id="u7BA1_u7406_u5DE5_u4F5C_u7684_u5206_u7C7B"><a href="#u7BA1_u7406_u5DE5_u4F5C_u7684_u5206_u7C7B" class="headerlink" title="管理工作的分类"></a>管理工作的分类</h4><p>我们从格鲁夫一天工作的介绍中，能看出来他的工作分为几类：</p>
<ul>
<li>信息收集类。看邮件、看报告、开会、和同事聊天、看用户反馈、看产品数据、试用公司产品等。</li>
<li>传递信息。培训或者分享观点。</li>
<li>决策。通过、制定或者否决一些方案。</li>
<li>给予提示。传递一些观点。</li>
<li>为人表率。提供行为示范。</li>
</ul>
<p>在信息收集方面，作者鼓励在使用传统的邮件和口头直接沟通外，多增加一些非正式的沟通机会。比如多随意在公司里走走，找不同的人聊聊天等等。</p>
<p>在决策方面。作者认为决策分为两类：「未雨绸缪型」和「亡羊补牢型」，前者是在规划未来，后者是在补救当前问题。</p>
<p>关于给予提示，作者认为他与决策的差别在于，给予提示很多时候并没有明确的方案，他是希望让对方通过提示来做一些调整，而调整的具体的细节需要对方自己思考。</p>
<p>除了以上四类（信息收集、信息传递、决策、给予提示）工作，作者也提到，管理者的所有行为，同时也在以「榜样」的作用被员工效仿。例如管理者随意迟到，员工就会随意迟到。管理者做事情认真，员工也会有认真工作的压力。</p>
<h4 id="u7BA1_u7406_u6760_u6746_u7387"><a href="#u7BA1_u7406_u6760_u6746_u7387" class="headerlink" title="管理杠杆率"></a>管理杠杆率</h4><p>在介绍完管理工作的分类后，格鲁夫给大家介绍了他的管理杠杆率公式：</p>
<blockquote>
<p>  经理人的产出<br>= 组织产出的总和<br>= 杠杆率 A <em> 管理活动 A + 杠杆率 B </em> 管理活动 B ……</p>
</blockquote>
<p>与管理杠杆率相关的因素有很多，包括时效：一个员工有离职情绪时，及时沟通的时效就很重要。一个重要会议要开时，提前准备内容的时效就很重要。</p>
<p>另外，格鲁夫指出，也有很多管理活动的杠杆率是负的，例如：经理人情绪低下，影响员工士气。经理人越权干涉别人的工作，影响别人积极主动性。经理人做出错误决策，浪费人力物力。</p>
<p>格鲁夫指出，高杠杆率的事情包括：</p>
<ul>
<li>当一个经理人可以同时影响多个人的事情</li>
<li>当经理人一个简单动作或简短谈话，会对别人产生长远影响的时候</li>
<li>当经理人的技术、知识或信息，对一群人造成影响的时候</li>
</ul>
<p>作者也列出了一些具体的高杠杆率的事情：</p>
<ul>
<li>关注用户的反馈，特别是抱怨。</li>
<li>绩效评估。</li>
<li>传授知识、技能或价值观给部署。</li>
<li>授权。</li>
</ul>
<h4 id="u6388_u6743"><a href="#u6388_u6743" class="headerlink" title="授权"></a>授权</h4><p>关于授权，作者做了展开的介绍：</p>
<blockquote>
<p>没有完备监督计划的授权等于渎职。你绝对不能完全地抽身，即使你已经授权，你还是得负成败责任。<br>全程监督整个被授权的案子是确保结果尽如人意的唯一方法。监督不是干涉，而是通过不时的检查，来确定活动的进行一如预期。<br>因为监督你熟悉的工作比较容易，所以如果有机会，你应该把自己熟悉的工作授权给他人。但切记先前举的例子—理智叫你松手，但情感上你可能老大不愿意。</p>
</blockquote>
<p>监督的办法可以用上一部分提到的检验产品质量的原则：越早检验成本越小。例如对开发工作不熟悉的员工，让他们在写代码前就先给你讲讲他打算如何规划，就比让他写完你再检查要好得多。</p>
<p>监督的另外一个技巧也是检验产品质量的原则提到的：注意检验的频率。对于新人，要增加频率。对于信任的人，可以降低频率。另外，监督的方法要具有多样性，对不同的人采用不同的方法。</p>
<p>监督并不是说经理人一定需要替员工考虑好事情的方方面面，因为这毕竟需要付出大量的精力。对于某些事情，经理人只需要提出一些细节问题来测试员工的思考是否全面，则可以一定程度上评估出事情的靠谱程度。对于经理人不熟悉的领域，也可以用此办法。</p>
<p>关于这方面的知识，我在指导 iOS 开发新人的时候体会很深。通常指导新人的常用办法，就是将自己熟悉的工作交给新人完成。因为这些工作非常好通过监督（Code Review + 定期讨论）来保证质量，所以风险可控，而我自己也会从中学习到指导别人的各种技巧和经验。</p>
<p>最重要地，我需要打破我的舒适区，因为我需要放弃自己非常熟悉的工作内容，转而做一些新的陌生的事情。而新人的代码质量和编写速度往往是比我自己直接写要慢得多的，我需要有耐心地等待他们犯错，然后通过 Code Review 和讨论来让他们学习到相应的编程知识。</p>
<p>学会指导新人通常是一个有经验的程序员转向更高职位的第一个挑战，不管是他是转向偏管理的岗位还是继续在技术岗位上深挖，都需要先将手中的工作交出去，才能够承担更重要，更有挑战的事情。</p>
<h4 id="u63D0_u9AD8_u6548_u7387"><a href="#u63D0_u9AD8_u6548_u7387" class="headerlink" title="提高效率"></a>提高效率</h4><p>作者提出了一些提高效率的办法：</p>
<ul>
<li>找出限制步骤：重要的、紧急的事情优先安排。这样的情况下有空余，再安排别的事情。</li>
<li>类似的工作放在一起做。例如将邮件处理，QQ 信息回复的事情稍做积累再统一回复。</li>
<li>安排好日程表。对一些事情说不，对日程表的事情留上 Buffer。</li>
<li>建立指标。尽量估计自己在每件事情上的花费，尽管这件事情很难，也可能不太准，但是总是会有所帮助，而且有经验了之后，估计时间会越来越准。</li>
<li>存货法。留一些重要不紧急的事情，使自己不太忙的时候，可以做这些事。比如对于我来说，学习产品知识，试用各种 App 的功能，分析各种 UI 设计就是一个「存货」。</li>
<li>标准化。对一些经常做的事情，制定标准化的流程就可以提高效率。这就类似我们制定的产品评审流程，上线流程一样。标准化了之后，就不用每次想应该怎么做了，按步就班地开展即可。</li>
</ul>
<p>老被人打断怎么办？作者认为「躲起来让人找不出」或者「叫别人不要在某些时段打扰」的办法都不太好，他介绍了很多有用的办法，包括：</p>
<ul>
<li>标准化。把一些常见的问题归类总结。如果一类问题有归类总结了，也就意味着它能够被授权给员工来处理了，也很容易被进一步用于员工指导别人。</li>
<li>类似的工作放在一起做。每天固定时间处理员工的问题，或者固定在一对一沟通中处理相关问题。</li>
<li>运用指标。有指标就可以改进流程。看看自己花费在解决临时问题上的时间以及常见问题，然后就可以看看能够优化这些时间。</li>
</ul>
<h3 id="u7B2C_u56DB_u7AE0_uFF1A_u7BA1_u7406_u5FC5_u7ECF_u4E4B_u8DEF_uFF1A_u5F00_u4F1A"><a href="#u7B2C_u56DB_u7AE0_uFF1A_u7BA1_u7406_u5FC5_u7ECF_u4E4B_u8DEF_uFF1A_u5F00_u4F1A" class="headerlink" title="第四章：管理必经之路：开会"></a>第四章：管理必经之路：开会</h3><p>格鲁夫将会议分为两类：过程导向会议和任务导向会议。</p>
<ul>
<li>过程导向会议：关于知识技能和信息交流，通常是例行的。</li>
<li>任务导向会议：会产生决策的，通常不是例行的。</li>
</ul>
<h4 id="u8FC7_u7A0B_u5BFC_u5411_u4F1A_u8BAE"><a href="#u8FC7_u7A0B_u5BFC_u5411_u4F1A_u8BAE" class="headerlink" title="过程导向会议"></a>过程导向会议</h4><p>过程导向会议又可分为以下三类：一对一会议、部门会议，以及运营总结会议。过程导向会议要尽量规律化。</p>
<p>关于一对一会议，我之前专门写过文章：<a href="http://blog.devtang.com/2015/10/25/one-on-one-summary/">《浅析一对一沟通》</a></p>
<p>关于部门会议，作者的经验是经理人要注意大家讨论的主题和效率，事先讨论的主题需要明确，最好大家在开会前能做好准备。经理人要尽量让讨论是自由的，避免成为自己主宰的「一言堂」。部门会议的议题应该尽量让部属来负责，经理人的责任只是保证讨论不要偏题即可。</p>
<img src="/images/hom-4.png">
<p>运营总结会议是让那些通常没有机会开部门会议的同事提供互动的机会，让他们有机会彼此学习及分享经验。</p>
<h4 id="u4EFB_u52A1_u5BFC_u5411_u4F1A_u8BAE"><a href="#u4EFB_u52A1_u5BFC_u5411_u4F1A_u8BAE" class="headerlink" title="任务导向会议"></a>任务导向会议</h4><p>过程导向的会议一般有固定的开会时间和频率，其效果也多是交流信息为主。而任务导向会议一般没有固定的开会时间和频率，会议结束后一般也需要产出一份会议的讨论结果用于后续执行。</p>
<p>这种需要决策的会议通常需要控制人数，如果超过 8 个人，很可能比较难以推动达成意见的一致。</p>
<h4 id="u4E92_u8054_u7F51_u516C_u53F8_u5B9E_u9645_u7684_u60C5_u51B5"><a href="#u4E92_u8054_u7F51_u516C_u53F8_u5B9E_u9645_u7684_u60C5_u51B5" class="headerlink" title="互联网公司实际的情况"></a>互联网公司实际的情况</h4><p>就我的感受，互联网公司其实为了追求效率，还是希望尽量少开会，我参与的会议主要分几类：</p>
<ul>
<li>Scrum 相关的会议：包括计划会议、每日站会、评审会议和回顾会议。我们的技术和产品工作都用 Scrum 的方式来管理。</li>
<li>过稿会议：产品的过稿会议，UI 稿的过稿会议。</li>
<li>一些临时性的，需要讨论的会议，类似格鲁夫提到的任务导向会议。</li>
</ul>
<p>如果把一对一沟通算作会议，那么这也是我常参与的。但是因为一对一沟通的场地经常是在非办公室的区域，所以我其实不觉得这是一种会议。</p>
<h3 id="u7B2C_u4E94_u7AE0__u4E0D_u6325_u821E_u6743_u6756_u7684_u51B3_u7B56"><a href="#u7B2C_u4E94_u7AE0__u4E0D_u6325_u821E_u6743_u6756_u7684_u51B3_u7B56" class="headerlink" title="第五章 不挥舞权杖的决策"></a>第五章 不挥舞权杖的决策</h3><p>由于在互联网公司，科技类知识更新速度非常快，而相对于一线的技术人员，管理者并不能拥有更多决策所需要的专业知识，因此我们需要将具体的决策，下放到一线的员工手中。</p>
<p>格鲁夫在书中描述了一种理想的决策方式：</p>
<ul>
<li>先是充分地讨论和表达意见</li>
<li>然后是在意见充分被表达之后的决策</li>
<li>最后是一旦最后决策产生，那些少数不同意的同事，都应该在之后执行过程中全力支持。</li>
</ul>
<img src="/images/hom-5.png">
<h3 id="u7B2C_u516D_u7AE0__u89C4_u5212_u662F_u4E3A_u4E86_u660E_u5929"><a href="#u7B2C_u516D_u7AE0__u89C4_u5212_u662F_u4E3A_u4E86_u660E_u5929" class="headerlink" title="第六章 规划是为了明天"></a>第六章 规划是为了明天</h3><blockquote>
<p>在你规划行动方案之前，一定记得先问自己：有什么事情我如果 “今天” 做了，可以让 “明天” 更好，或者至少让 “明天” 不会更糟。</p>
</blockquote>
<p>在本章，格鲁夫首先介绍了 Intel 在流程规划上的一些方法，但是个人感觉比较偏制造业，因为讲的都是处理原材料，库存与订单之单的矛盾。</p>
<p>接着，格鲁夫介绍了目标管理，包括需要做到：1、有明确的目标。2、有向目标前进的具体方案。</p>
<blockquote>
<p>当你将计划落实为白纸黑字时，看起来最抽象笼统的总结即为你的战略，而你用来实行战略的行动即为战术。</p>
</blockquote>
<p>对于这章，我自己倒是有一些总结。就我在互联网公司的经验来说，我们做规划和目标管理主要是分为以下几类：产品规划、开发规划、运营规划、人员规划。</p>
<h4 id="u4EA7_u54C1_u7684_u89C4_u5212"><a href="#u4EA7_u54C1_u7684_u89C4_u5212" class="headerlink" title="产品的规划"></a>产品的规划</h4><p>我们通常需要计划出未来至少 3 个版本的产品迭代计划。然后，对于这些产品计划，安排相应的产品 PRD 稿的撰写和评审、UI 稿的制作和评审、技术评审、开发测试及最后的上线。</p>
<h4 id="u5F00_u53D1_u7684_u89C4_u5212"><a href="#u5F00_u53D1_u7684_u89C4_u5212" class="headerlink" title="开发的规划"></a>开发的规划</h4><p>开发的规划主要是通过 Scrum，将产品和美术稿已经 Ready 的待做事项以 backlogs 的方式放在 Scrum 的管理中。然后在每一个迭代冲刺（Sprint）中，我们从 backlog 里面选取部分工作到当个 Sprint 中。</p>
<p>每一个 Sprint 是包括完整的开发和测试工作，服务器端通常在 Sprint 快结束时，就需要完成上线操作。客户端由于版本发布过于频繁对于用户也有一些打扰，所以我们通常两周对外发布一次版本。</p>
<h4 id="u8FD0_u8425_u7684_u89C4_u5212"><a href="#u8FD0_u8425_u7684_u89C4_u5212" class="headerlink" title="运营的规划"></a>运营的规划</h4><p>大型的运营活动如果需要产品和开发的介入，就也需要相应的规划。通常情况下，我们认为提前一个半月开始是相对充裕的方式。运营花大概两周做活动的策划，剩下的一个月用于技术的排期。</p>
<h4 id="u4EBA_u5458_u7684_u89C4_u5212"><a href="#u4EBA_u5458_u7684_u89C4_u5212" class="headerlink" title="人员的规划"></a>人员的规划</h4><p>作为团队管理者，我们还需要在人员上做相应的规划。这包括：</p>
<ul>
<li>人员的招聘。预估未来业务增长对于人力的需求，以便提前做好相应的招聘工作。</li>
<li>人员的培养。新人的培养、重要岗位人员的培养。</li>
<li>人员的激励或开除。对一些表现优秀的人员，给予更多的关注和沟通。对一些表现不佳的人员，除了需要明确地指出他们的问题外，也需要根据改进情况选择后续的处理方案。</li>
</ul>
<h2 id="u7B2C_u4E09_u90E8_u5206_uFF1A_u63A8_u52A8_u7EC4_u7EC7_u7684_u5DE7_u624B"><a href="#u7B2C_u4E09_u90E8_u5206_uFF1A_u63A8_u52A8_u7EC4_u7EC7_u7684_u5DE7_u624B" class="headerlink" title="第三部分：推动组织的巧手"></a>第三部分：推动组织的巧手</h2><p>本部分介绍一些实践经验，作者从早餐店的发展作为故事，引出企业管理中涉及的混合型组织架构，从这种架构带来的问题出发，提出了双重报告这种解决方案，由从双重报告需要的企业文化出发，介绍了影响人们行为的 CUA 模型，最后得出高 CUA 因素的工作，需要员工用文化价值观来指导行为。</p>
<p>比较可惜的是，对于如何增强大家的文化价值观，格鲁夫并没有展开讨论，只是说领导应该以身作则。</p>
<h3 id="u7B2C_u4E03_u7AE0__u5F53_u65E9_u9910_u5E97_u5F00_u59CB_u7E41_u884D"><a href="#u7B2C_u4E03_u7AE0__u5F53_u65E9_u9910_u5E97_u5F00_u59CB_u7E41_u884D" class="headerlink" title="第七章 当早餐店开始繁衍"></a>第七章 当早餐店开始繁衍</h3><blockquote>
<p>在实务中，这种有关管理上集权及分权的分歧到处可见，几已成为今日管理上最重要的课题之一。</p>
</blockquote>
<p>本章只讲了一个故事，当早餐店做得越来越好时，分店越来越多，带来的管理上的复杂度也越来越大。不管是采购，还是人事，还是资产，我们都需要专门雇佣人员来负责。</p>
<p>但是除了这个故事外，本章并没有涉及任何解决方案的内容。</p>
<h3 id="u7B2C_u516B_u7AE0__u6DF7_u8840_u578B_u7EC4_u7EC7"><a href="#u7B2C_u516B_u7AE0__u6DF7_u8840_u578B_u7EC4_u7EC7" class="headerlink" title="第八章 混血型组织"></a>第八章 混血型组织</h3><blockquote>
<p>斯隆总结他在通用汽车数十年的经验时说：好的经营管理，是中央集权和地方分权间的折中产品。</p>
</blockquote>
<p>本章讨论了两种组织形式：「任务导向组织」和「功能导向组织」。</p>
<img src="/images/hom-6.png">
<p>任务导向组织是以具体的完成某件事情为目标而形成的组织。功能导向组织是以完成某个细分功能而形成的组织。这两种组织各有优缺点，很多时候需要以混合的形式存在于一家公司，而具体如何混合，在不同的公司差异相当大。</p>
<p>拿互联网公司来举例，我所在的猿题库是更偏向「任务导向组织」的公司，我们公司旗下有三款产品：猿辅导、猿题库、小猿搜题。这三个产品下面，各种有着完整并且独立的运营、产品、开发、测试、UI 团队。而我之前工作的网易有道，就是一家更偏向「功能导向组织」的互联网公司，因为在网易有道，有着全公司统一的测试团队、UI 团队。还有一些公司，他们甚至将全公司的移动端开发都集中成一个移动开发团队。</p>
<p>两种组织方式各有优缺点，我们来看看作者格鲁夫的分析。</p>
<h4 id="u529F_u80FD_u5BFC_u5411_u7EC4_u7EC7"><a href="#u529F_u80FD_u5BFC_u5411_u7EC4_u7EC7" class="headerlink" title="功能导向组织"></a>功能导向组织</h4><p>「功能导向组织」的部门更像是内部的分包商，相比外部的外包商，内部的分包商因为同属于一家公司，所以提供的服务会更好，而且还有：</p>
<ul>
<li>规模经济。以运维为例，全公司统一的运维部门，有利于在公司内部建一统一的运维规范和运维系统，节省运维成本。</li>
<li>根据需求，转移或分配企业资源。以测试为例，全公司统一的测试团队，在某些产品有更多临时测试需求时，更好地调配人员。</li>
<li>共享知识。全公司统一的测试团队、UI 团队有利于他们更加方便地交流相关的专业技术，测试团队可能在测试流程上更加优化，UI 团队可能在全公司范围内统一 UI 设计规范和准则。</li>
</ul>
<p>但是，「功能导向组织」的缺点也很明显，包括：</p>
<ul>
<li><p>不同部门之间会争抢「功能导向组织」的资源。比如测试团队如果是公共的话，每个部门都会为自己的产品争取尽量多的测试资源，但是谁能够证明自己的优先级肯定比别人的高呢？所以这其中会产生更多的沟通和决策成本。</p>
</li>
<li><p>责任心减弱。这一条并不是格鲁夫总结的，而是我自己感受到的。拿移动开发团队举例，如果移动开发团队是「功能导向组织」，那么某个移动开发者对于一个临时的开发工作很可能并不能做到付出 100% 的全力，因为他很可能只在这个项目做两个月。那么他很可能着眼于「把当前的工作做完」，而不是「整个产品本身的利益」来考虑问题。</p>
</li>
</ul>
<p>举一个具体的例子，当一个产品设计对一种特殊情况考虑不完整时，一个「功能导向组织」的开发者很可能基于按时「把当前的工作做完」这个目标，而选择忽视这些未定义的产品细节，按照「怎么方便就怎么开发」的方式来做，因为产品没定义清楚本来是产品的责任，与他无关。如果他找产品讨论这些细节，很可能使得实现方案变得更加复杂，对于他「把当前的工作做完」这个目标产生冲突。</p>
<p>但是，如果是一个「任务导向组织」的开发者，因为他会长久地负责这个项目的开发，这个项目的好坏最终会决定大家的绩效，他当前没有处理好这个产品细节，以后很可能也会是他来再次重构相应的代码。那么他就有更大的可能去和产品沟通和协调，确定这些未定义的产品细节。</p>
<h4 id="u4EFB_u52A1_u5BFC_u5411_u7EC4_u7EC7"><a href="#u4EFB_u52A1_u5BFC_u5411_u7EC4_u7EC7" class="headerlink" title="任务导向组织"></a>任务导向组织</h4><p>「任务导向组织」的优点是什么呢？优点是需求更加明确，决策更加灵活，人员也更加有凝聚力。</p>
<p>「任务导向组织」也有缺点，主要是这种方式会使得大家在共享专业知识上更加困难。对此，我们公司增加了很多全公司范围内的技术分享会，通过这些分享活动，我们希望增加大家在技术上的交流。</p>
<p>那么，猿题库公司的具体混合型组织是什么样的呢？我们的「功能导向组织」仅包括：运维团队、算法研究团队、数据分析团队、财务和行政团队。而我们将产品、运营、测试、客户端开发、Web 前端开发、UI 设计人员都分拆放到了「任务导向组织」中，而我们按产品将「任务导向组织」分为了三个：猿辅导团队、猿题库团队、小猿搜题团队。</p>
<h3 id="u7B2C_u4E5D_u7AE0__u53CC_u91CD_u62A5_u544A"><a href="#u7B2C_u4E5D_u7AE0__u53CC_u91CD_u62A5_u544A" class="headerlink" title="第九章 双重报告"></a>第九章 双重报告</h3><p>格鲁夫在本章中，推荐用双重报告来解决混合型组织的管理问题。混合型组织中，一个人如果在一个「任务导向组织」，那么他很可能在专业技能上无法得到 Leader 的指导，格鲁夫希望通过让这个人在专业技能上报告给一个专业技能上的 Leader，使得这个人在专业技能上有所成长。</p>
<p>但是，格鲁夫也提到，这种双重报告很多时候是模糊不清的，「含混是解决问题之道」。所谓的含混，就是指专业技能的 Leader 在实际上并没有明确的权力。有些时候，双重报告的存在形式是一些「同级群体」或「同级委员会」，这些群体可能由于一些专业问题自发地形成，但是自主地决策解决一些 Leader 无法解决的问题。</p>
<p>我自己就亲自经过多次「同级群体」决策。例如，苹果规定 2016 年 6 月 1 日之后的应用必须支持 IPv6，这意味着我们可能需要升级全公司共用的网络库，于是我就在群里面发起了这个问题的讨论，一些人（主要是相关产品的 iOS 负责人）自发地参与了这个讨论，然后大家讨论出了一些方案和结论。</p>
<p>这种「同级群体」决策的成功，更大程度上不是某个规则的作用，因为我们很难明确出哪些事情需要跨部门讨论，也很难明确出这些讨论的负责人。所以，我们只能用一些企业文化或者做事方式影响大家。</p>
<p>所以，我感觉格鲁夫在本章其实并不是强调双重报告，而是强调在「任务导向组织」中，还应该有一只看不见的手，让大家在织织之间，产生协同、讨论和决策。</p>
<p>格鲁夫在本章中没有描述清楚这只看不见的手，他只把它称作「企业文化」，而这正是他在下一章将要展开阐述的内容。</p>
<h3 id="u7B2C_u5341_u7AE0__u6BCF_u4E2A_u4EBA_u90FD_u542C_u547D_u4E8E_u4E09_u4E2A__u201C_u957F_u5B98_u201D"><a href="#u7B2C_u5341_u7AE0__u6BCF_u4E2A_u4EBA_u90FD_u542C_u547D_u4E8E_u4E09_u4E2A__u201C_u957F_u5B98_u201D" class="headerlink" title="第十章 每个人都听命于三个 “长官”"></a>第十章 每个人都听命于三个 “长官”</h3><p>格鲁夫通过一个故事（故事中涉及买轮胎、遵守交通规则、主动帮助车祸的人）来说明一个人的行为，受三方面的影响：</p>
<ul>
<li>自由市场因素：大家简单地以自己的利益作为行为指导，例如挑选商品时大多只会考虑价格和质量。</li>
<li>契约义务：通过事先达成的一致，然后履行契约义务。例如我们上班，就是和公司的一种契约义务。</li>
<li>文化价值观：一种为了组织利益，牺牲自我短期利益的行为，通常这种行为长远来看对个人也是有利的。</li>
</ul>
<p>格鲁夫引入了 CUA 指标来帮助我们选择用以上哪方面的因素来指导人们的行为。CUA 分别指：工作环境的复杂性（Complexity）、不确定性（Uncertainty）、指令的模糊度（Ambiguity）。</p>
<p>程序员的工作就充满了复杂性，因为程序员需要不断地学习新知识，代码的逻辑和架构也可能很复杂。而市场的工作充满了不确定性，很多时候上司也无法帮你想出有新意的市场推广方案。</p>
<p>格鲁夫认为，如果一个工作的  CUA 因素高，而个人关注的是团体利益，那么就只能用文化价值观来作为行为的指导。但是如果个人关注的是自身利益，那么就会如下图显示的那样，情况变得「一筹莫展」。</p>
<img src="/images/hom-7.png">
<p>格鲁夫举了一个例子，当海滩上发生灾难时，每个人都只顾及保全自己的性命，而救援工作需要极高的 CUA 因素，所以现场只会是一片混乱。</p>
<p>按这个理论思考，我们就能理解为什么要做火灾演习了，多次火灾演习可以极大地减少火灾发生的 CUA 因素，因为大家在演习中对于火灾已经有着明确的处理方案了，需要做的只是按之前演习中的契约行动就行了。</p>
<p>格鲁夫认为该理论对于指导新人也有意义：</p>
<blockquote>
<p>让我们把这套理论套用在某个刚进公司的新人身上。由于初来乍到，他无疑比较关心自身的利益。因此，你应该给他明确的工作架构，降低复杂性及不确定性。</p>
</blockquote>
<p>另外，该理论对于空降的高管也有意义：</p>
<blockquote>
<p>对于空降的高管来说，就像起用任何新人一样，一开始他还是比较关心自身利益。但身为高级经理，他难免会被指派管理一个有问题的部门—毕竟这是我们从外面找人的原因。此时对这个经理人而言，他面临的不仅是烫手山芋，还有环境里很高的 CUA；同时，他也尚未建立起属于这个企业的价值观与行事准则。在此状况下，大家只能求老天保佑他能赶紧忘却私利，以大我为前提，并设法降低 CUA。如果他做不到这些，恐怕很快就会被撤掉。</p>
</blockquote>
<p>文化价值观也不是银弹，在 CUA 因素低的时候，选择用自由市场因素或契约义务，都比文化价值观来得有效。所以，根据具体工作的 CUA 值，选择具体的控制模式，是经理人需要关注的。</p>
<p>不过话说回来，我仔细想了想互联网企业里面的各种职位，不管是产品、技术、还是运营，似乎都是高 CUA 因素的职位，所以文化价值观应该是互联网公司管理员工的基本方式。</p>
<p>很可惜，格鲁夫在本章中并没有详细介绍如何增强大家的文化价值观，他只是认为，管理者自己的行为示范，比把文化价值观挂在口头上有效。但是本书的第四部分，详细讨论了企业管理中人的问题。</p>
<h2 id="u7B2C_u56DB_u90E8_u5206_uFF1A_u8C0B_u4E8B_u5728_u4EBA"><a href="#u7B2C_u56DB_u90E8_u5206_uFF1A_u8C0B_u4E8B_u5728_u4EBA" class="headerlink" title="第四部分：谋事在人"></a>第四部分：谋事在人</h2><p>本部分涉及激励、工作成熟度、绩效评估、招人与留人、报酬与培训。</p>
<h3 id="u7B2C_u5341_u4E00_u7AE0__u6FC0_u52B1_u90E8_u5C5E_u53C2_u52A0_u6BD4_u8D5B"><a href="#u7B2C_u5341_u4E00_u7AE0__u6FC0_u52B1_u90E8_u5C5E_u53C2_u52A0_u6BD4_u8D5B" class="headerlink" title="第十一章 激励部属参加比赛"></a>第十一章 激励部属参加比赛</h3><p>格鲁夫将员工的问题分为不能和不为两类：</p>
<ul>
<li>不能：能力不够。</li>
<li>不为：能力够，但是不够努力。</li>
</ul>
<p>针对这两类问题，他提出了培训和激励两种解决方案。在本章作者并没有讲培训，主要详细讨论了激励相关的问题。</p>
<p>作者认为，激励应该和马斯洛的需求金字塔理论相符。</p>
<img src="/images/hom-8.png">
<p>在「归属感与认同感」这一层，我们应该让同事们都喜欢当前的工作环境和同事关系，认同当前公司做的事情。同事之间的合作应该是愉快和融洽的，同事中还会有自己欣赏的牛人，有自己的好朋友可以一起吃饭、聊天。</p>
<p>只有产生了归属感与认同感，员工才会追求更高一层的「地位与尊重」。我们给那些表现优秀的员工更重要的事情，更高的职位，使得他能够在这一层上产生明确的目标。很多公司都会做职业发展的内部评级，其实就是给大家一个明确的地位与尊重的目标，让大家为此努力。</p>
<p>但是，「地位与尊重」的目标一旦达到，人们工作的动力又会下降。一些更牛的人，就会追求马斯洛需坟金字塔的顶端：「自我实现」。「自我实现」这一层的需求的差异性在于：</p>
<blockquote>
<p>一旦某个人受激励的来源是自我实现，他工作的动力将不再受局限。这是自我实现有别于其他激励模式最重要的特点。其它的激励来源一旦在需求满足之后便不再生效，但是自我实现将不断激励个体向上突破。</p>
</blockquote>
<p>有两种自我实现的动力可以促使个体将能力发挥到极致：精益求精型和成就导向型。</p>
<p>精益求精型的例子是音乐家、运动员，也包括程序员。拿程序员来说，一个程序员如果不断追求写出更牛逼的代码，那么他可以像<a href="http://baike.baidu.com/view/15099717.htm" target="_blank" rel="external">阿里的多隆</a>那样，成为合伙人级别的重要人物。</p>
<p>成就导向型的人常常怀有达成任务的决心，对于困难，他们喜欢挑战自我。其实做很多事情，刚开始都是需要面对失败的。成就导向型可以坦然地面对失败，然后再次挑战目标。</p>
<p>对于较高需求层次的人，失败的恐惧大多数是来自于内心而不是外界，如果不能克服自我内心的恐惧，那么这个人就会从自我实现的层次往下降。</p>
<blockquote>
<p>一般而言，在较高的需求层次时，恐惧通常源自内在而非外在的威胁。人们经常因为过不了自己那一关而导致行动上的退却。但如果老是如此，这个人很快就会从自我实现的层次往下降落。</p>
</blockquote>
<p>在具体实施激励时，格鲁夫认为，一个好的激励应该是目标明确的，并且这个目标应该是比较难以达到的，这样大家才会全力以付，发挥出尽量大的潜力。</p>
<blockquote>
<p>如果我们想要让员工都能提升自我实现需求的层次，便必须先创造出一个讲求产出的环境。</p>
</blockquote>
<p>另外，可以合理使用一些竞赛，让大家把竞技场上的争胜的心态应用到工作中。</p>
<blockquote>
<p>工作的概念天生就不如竞技，我们干脆将运动场上的竞争精神融入工作。最好的方法便是先制定游戏规则，并让员工有衡量他们表现的尺度。</p>
</blockquote>
<p>关于竞赛，我自己也有一些真实的感悟。我们公司很多人中午都会去游泳，之前大家都自己随便游，后来有一个同事说，我们分成两组，搞接力赛吧。虽然这是一个没有任何奖励的比赛，但是大家因为比赛，就会不自觉得更加努力游泳，连续多日下来，大家的体力都上升了很多。</p>
<p>关于激励，格鲁夫最后总结道：</p>
<blockquote>
<p>经理人的角色在此便极为明显：他应当是个教练，身为教练，首先必须不居功，团队的成功来自于队员对教练指导的信赖；其次，他的训练必须严格。通过当一个铁面教头，他努力激发出队员的潜能，并刺激团队做出最佳表现。一个教练应该曾经是个好选手，因此他了解竞赛的规则以及选手在练习及比赛时可能面临的问题。</p>
</blockquote>
<h3 id="u7B2C_u5341_u4E8C_u7AE0__u5DE5_u4F5C_u6210_u719F_u5EA6"><a href="#u7B2C_u5341_u4E8C_u7AE0__u5DE5_u4F5C_u6210_u719F_u5EA6" class="headerlink" title="第十二章 工作成熟度"></a>第十二章 工作成熟度</h3><blockquote>
<p>令人惊讶的是，即使较早建立起的管理理论多半靠直觉，后来的实证科学也并没有办法将它们推翻，或是证实某种管理风格确实较其他的更胜一筹。研究学者似乎必须下没有所谓最佳管理风格的定论。</p>
</blockquote>
<p>格鲁夫首先通过英特尔在轮换经理人上的故事，引出了用「工作成熟度」（Task Relevant Maturity，TRM）来评估个人或部门。</p>
<p>根据工作成熟度的不同，格鲁夫建议用不同的办法来指导：</p>
<ul>
<li>工作成熟度低时，指导应该是明确和具体的。包括做什么事情，何时完成，如何着手等。</li>
<li>工作成熟度中时，指导应该从具体的事情，转移到沟通、情绪上的支持与鼓励。</li>
<li>工作成熟度高时，指导只需要关注努力方向是否正确上。</li>
</ul>
<p>格鲁夫说，我们在指导小孩的时候，也是符合这套理论的。刚孩子还小的时候，我们只会说做什么，不做什么；等他们长大一些之后，我们变成一些叮嘱和指导；等他们成人之后，我们基本上不再管教他们了。</p>
<p>指导的时候，我们应该注意建立共同的价值观。我们在猿题库也在这方面做了很多具体的尝试，比如我们强调：按时发布产品、代码质量、信息尽量共享、指导新人比日常开发工作更重要。这些都是在努力建立共同的价值观。</p>
<blockquote>
<p>一旦员工了解了组织的营运价值观，又具有较高的工作成熟度时，主管便可以开始分权，进而提高自身的管理杠杆率。</p>
</blockquote>
<p>格鲁夫在本章中也讨论了一个非常有意思的话题，管理者是否应该与员工建立友谊。他对此有两个观点：</p>
<ol>
<li>我们不应该把友谊相关的社交活动与工作上的指导混为一谈。因为社交活动并不能直接在工作上产生帮助，当然，友谊对工作是有一些间接帮助的，因为它使得你们之间在沟通的时候会更加有效一些。</li>
<li>命令朋友其实是一件不愉快的事情。当你需要批评或直接命令朋友时，友谊可能会是一个阻碍。格鲁夫举了一个例子：当你需要给你的朋友打很低的绩效时，你是否感觉到非常难受？</li>
</ol>
<p>对此我个人的感受是，适当的友谊还是非常有必要的，对于一些同事，经过一段时间的合作，我们其实是能够比较清楚地判断出来他们的潜力。如果我们认为他们的潜力是足够大的，在建立友谊的同时，在工作上也给予更多的指导，应该是一个更好的做法。</p>
<p>另外，建立共同的「就事论事」的价值观也是非常有必要的。大家是朋友，但是工作上应该批评就批评，如果大家有着对事不对人的共同价值观，批评就不是那么不可接受了。</p>
<h3 id="u7B2C_u5341_u4E09_u7AE0__u518D_u96BE_u4E5F_u5F97_u505A_uFF1A_u7EE9_u6548_u8BC4_u4F30"><a href="#u7B2C_u5341_u4E09_u7AE0__u518D_u96BE_u4E5F_u5F97_u505A_uFF1A_u7EE9_u6548_u8BC4_u4F30" class="headerlink" title="第十三章 再难也得做：绩效评估"></a>第十三章 再难也得做：绩效评估</h3><p>格鲁夫认为绩效评估是一个高杠杆率的工作，可以使得优秀的员工得到激励，从而更加努力。但是绩效评估又是一个非常难的事情，因为很容易产生冲突和争议。</p>
<p>绩效评估大致可以分成两部分：评估部属的绩效，以及将评估的结果告诉部属。作者认为，一个有效的评估报告应该包括：优点（需要有实例证明），缺点（需要有实例证明），如果在未来提高绩效。其实对于很多公司来说，绩效评估都是含混过去的。我现在所在的公司也没有详细到格鲁夫描述的那样的绩效评估报告。</p>
<p>不过，格鲁夫介绍了如何向一个完全不合格的员工传达绩效评估，我感觉很有价值。格鲁夫用解决问题的阶段来描述不合格员工的状态。</p>
<img src="/images/hom-9.png">
<p>这些阶段具体解释如下：</p>
<ul>
<li>忽视：表现不佳的员工最初会忽视问题。所以你需要找到具体的证据，让他无法抵赖。</li>
<li>否认：当员工开始否认问题时，事情其实已经有进展了，因为至少问题被提出来了。</li>
<li>责怪别人：责怪别人是一种很有效的防卫机制，因为员工可以以此为理由拒绝承担责任。所以这一步是关键，如果让他意识到不是别人的问题，那么就很容易进入到担起责任阶段。责怪别人到担起责任涉及的是克服心理障碍的问题，而从担起责任到寻找解决方案是能力问题，后者要简单得多。</li>
<li>担起责任：承认问题。</li>
<li>找出对策：双方一起找出问题的解决方案，并且实施。</li>
</ul>
<p>格鲁夫把阶段分得很多，其实我倒觉得关键的阶段就是从否认责任到承担责任的过程，这个过程中，经理人需要收集到足够多的证据，尽量客观地沟通，另外强调就事论事的工作态度，才可能帮助员工克服心理障碍。</p>
<p>另外，即使到了最后的「找出对策」阶段，大家也可能无法达成一致，这个时候，格鲁夫建议不必在这阶段强求一致，只要员工承诺按经理的方案实施即可。我们不应该强求说服别人，因为这更多是一种心理上的需求。</p>
<blockquote>
<p>你当然希望看到部属心悦诚服地同意你的看法，但如果他不是完全同意，只要他愿意采取改进行动，你就不该再在这上面伤脑筋。不要混淆了情绪问题和工作的需要。为了完成任务，你最需要的是部属愿意施行你决定的行动方案，至于他是否与你抱持同样的想法则是其次。期望别人凡事都和你想得一样其实并不是件好事，在工作上我们主要追求的是绩效，而并不是心里舒不舒服</p>
</blockquote>
<p>我们在做绩效评估时，也应该把重点放在那些重要的员工身上，他们已经非常优秀了，所以找出他们的问题将会相对困难，但是他们在未来很可能承担更重要的工作，所以把心思花在他们身上是值得的。</p>
<p>格鲁夫在本章的最后建议，应该提前把评估报告发给员工阅读，之后再组织讨论，这样会使得员工对评价有所思考，之后的讨论更加有效率。</p>
<h3 id="u7B2C_u5341_u56DB_u7AE0__u62DB_u4EBA_u4E0E_u7559_u4EBA"><a href="#u7B2C_u5341_u56DB_u7AE0__u62DB_u4EBA_u4E0E_u7559_u4EBA" class="headerlink" title="第十四章 招人与留人"></a>第十四章 招人与留人</h3><p>关于招人，格鲁夫提到，仅仅靠一小时的面试，根本就不足以客观地评价面试者的水平。对此我是非常同意的。但是企业的成本有限，确实也没办法花费更多时间来考查面试者了，所以这是一件非常难，但是又不得不做的事情。</p>
<p>关于如何招人，其实无非就是建立一套方法论，然后希望以「较大概率」招到满意的员工。我听过很多别的公司的方法论，大家的面试方法都差别很大，但是我觉得都是做到了刚刚说的原则。我自己长久以来针对程序员、产品经理、产品实习生面试分别都有总结，在此就不展开介绍书中的办法了。</p>
<p>关于留人，书中提到最麻烦的就是重要的优秀员工想离开。对待想离职的优秀员工，第一步需要做到的是足够的倾听。</p>
<blockquote>
<p>你应该马上放下手上的事情，请他到办公室坐下来谈，问他为什么要辞职。让他畅所欲言，千万不要和他起任何争执。相信我，你的爱将已经在不止一个失眠的夜里将这套词儿演练过千百遍。等到他讲完所有他要辞职的理由（没有一个会是好理由），你再多问他一些问题。先让他说个够，因为当他讲完了事先准备好的那一套词儿后，真正的理由也许才会显现。千万不要争辩，不要说教，也不要动气。</p>
</blockquote>
<p>倾听之后，找到离职真正的原因，只能站在对方立场上考虑，如果是薪水问题，看看是否合理，该调整的话就调整。如果是工作内容，看看能否做一些公司内部的工作变动来帮助他找到更喜欢的工作。如果是当前公司的一些具体的问题，看看能不能做一些改进。但是，这些做法的前提都是：这是一个优秀的、重要的员工。如果是一个表现普通的员工提出的不合理要求，那么倾听之后可能也只能做一些形式上的挽留了，因为我们不能破坏公司的薪酬体系来挽留他。</p>
<h3 id="u7B2C_u5341_u4E94_u7AE0__u62A5_u916C_u7684_u8BF1_u60D1"><a href="#u7B2C_u5341_u4E94_u7AE0__u62A5_u916C_u7684_u8BF1_u60D1" class="headerlink" title="第十五章 报酬的诱惑"></a>第十五章 报酬的诱惑</h3><p>大部分人的薪资都是结合他的工作表现+工作年限的综合评价，这其实是建立员工稳定期望和公平的一个方案。在我们公司，有一些优秀的应届生能够比一些老员工贡献更多的产出，但是我们确实无法一下子就给他老员工那样的薪水，大部分的时候，我们会给他超出同样工作年限的人的薪水。</p>
<p>以工作年限作为薪资的重要衡量手段，算不上特别公平，但是确实也没有特别好的办法。不过，当前互联网公司已经有一些创业公司开始打破这样的规则，他们给那些工作一两年的优秀员工非常高的薪水，因为事实上，这些员工的产出和那些工作五六年的员工差别不大，但是从性价比上讲，他们比那些工作五六年的员工要价少得多，所以多给一些也没关系。</p>
<p>在互联网公司抢人的时候，这种策略被大量的采用了。这造成了互联网人才薪资水平的差异被进一步缩小，大部分人的年薪都集中在某一个很小的范围区间。而那些工作多年的人，如果不能进一步提升自己的能力，就会陷入薪资基本停止不前的怪圈。</p>
<p>在本章，作者也提到，一般职务的提升都会面临工作内容的巨大变化，很多人处理不好，反倒会表现得很差劲，这便是著名的 <a href="http://baike.baidu.com/subview/39071/14321969.htm" target="_blank" rel="external">彼得原理</a>。</p>
<blockquote>
<p>一名称职的教授被提升为大学校长后无法胜任；一个优秀的运动员被提升为主管体育的官员，导致无所作为。对一个组织而言，一旦相当部分人员被推到其不称职的级别，就会造成组织的人浮于事，效率低下，导致平庸者出人头地，发展停滞。</p>
</blockquote>
<p>但是，对此我们又有什么办法呢？我们不提拔优秀的员工，难道提拔糟糕的员工吗？所以除了对提拔的员工悉心培养之外，也没什么好办法。</p>
<p>如果一个员工实在对新工作不感兴趣，作者建议还是让他回到以前表现优秀的岗位上。虽然刚开始有一些难堪，但总比他主动离职要好得多。</p>
<h3 id="u7B2C_u5341_u516D_u7AE0__u522B_u7B49_u706B_u70E7_u7709_u6BDB_u624D_u57F9_u8BAD"><a href="#u7B2C_u5341_u516D_u7AE0__u522B_u7B49_u706B_u70E7_u7709_u6BDB_u624D_u57F9_u8BAD" class="headerlink" title="第十六章 别等火烧眉毛才培训"></a>第十六章 别等火烧眉毛才培训</h3><p>作者认为经理人应该是培训的责任人，不应该把培训交给外面的公司负责。因为经理人本身在公司内部具有权威性和可信度，他的培训内容更容易被理解，另外，每个公司的做事方式和文化都不太一样，自己参与培训才能够把正确的做事方式传递给大家。</p>
<p>设计培训课程花费的精力相当大，我当前就在设计产品实习生的培训课程，还好我之前有一些总结，否则第一次课可能都会耗费我大量时间。就算这样，我也不知道培训能否一直按计划进行下去。不管怎么样，只要开始了，总归是有产出的，而且我相信多做几次之后，我就可以建立起优秀的、系统的培训课程。</p>
<h3 id="u6700_u540E_u7684_u95EE_u9898_u5217_u8868"><a href="#u6700_u540E_u7684_u95EE_u9898_u5217_u8868" class="headerlink" title="最后的问题列表"></a>最后的问题列表</h3><p>作者在最后留了一些很棒的问题，值得大家回答一翻。</p>
<blockquote>
<p>如果你能从下列各项检验中拿到100分以上，以这本书的标准，你算是个杰出的经理人了。<br>★ 试着将你工作中的操作分为编制流程、组装及测试三个步骤。【10分】<br>★ 针对你手头开展的方案，找出限制步骤，并依此设计你的工作流程。【10分】<br>★ 找出你工作中最适合进行验货、线上检验与最终检验的地方。决定这些检验应该采用“海关”还是“监视器”的方式。然后考虑在什么时机下，你可以升格至“随机检验”。【10分】<br>★ 找出至少6项以上的新产出指标。这些指标应该要能衡量产出的质与量。【10分】<br>★ 将这些新的指标变成工作上的例行事项，并在部门会议中定期审视。【20分】<br>★ 你现在正寻找的最重要的战略（行动计划）是什么？描述你面临的环境需求以及计划进度。如果计划能成功地执行，是否能将你或你的公司带到理想中的境界？【20分】<br>★ 简化你最烦琐、最耗时的工作。至少让原有的步骤减少30%。【10分】<br>★ 找出什么是你真正的产出？你所管理的部门及影响力所及的部门的产出元素为何？按重要顺序排列。【10分】<br>★ 实际在公司中走动走动。然后，列出这次“出巡”中和你有关的事项。【10分】<br>★ 找一些借口让你一个月可以在公司内巡视一次。【10分】<br>★ 描述下一次你授权给部属时会如何督导。你将以什么为标准？怎么做？督导的频率是怎样的？【10分】<br>★ 列出你可以利用零碎时间进行的项目。【10分】<br>★ 列出和每一个部属“一对一会议”的时间表。（在会议之前向他们解释会议的目的，并要求他们作准备。）【20分】<br>★ 找出你上星期的日程表，将做的活动分为高、中、低杠杆率三类。设法多做一些高杠杆率的活动。（有哪些活动该减少或干脆不做？）【10分】<br>★ 预测下周有哪些事要瓜分你的时间。有多少时间要花在开会上？其中有多少是过程导向会议？多少是任务导向会议？如果后者占去的时间超过25%，你该如何设法删减？【10分】<br>★ 列出你的组织在未来三个月中最重要的三个目标，并一路验收成果。【20分】<br>★ 在与部属充分讨论过以上目标后，要他们也“依葫芦画瓢”—制定他们的目标并一路验收。【20分】<br>★ 写出“悬而未决”需作决策的事项。找出其中三项，试着运用决策制定过程的架构以及“六点问题”的方法。【10分】<br>★ 依据马斯洛的需求理论评估你自己的需求层次。并为部属找出他们所属的层次。【10分】<br>★ 给部属勾画他们的跑道，并找出每一个人的绩效指标。【20分】<br>★ 列出你给部属各种形式的工作所给予的相关回馈。他们是否能借着这些回馈来测量自己的进度？【10分】<br>★ 将你部属的工作成熟度分为低、中、高三类。并针对个人选出最适当的管理风格。并在你的管理风格及最适当的管理风格之间作比较。【10分】<br>★ 评估你上一次收到的或你对部属所作的绩效报告。这些报告对提高绩效有多大的影响？在上司告诉你报告内容或你告诉部属时，你们的沟通形式是怎样的？【20分】<br>★ 如果有哪一份报告不够理想，重做。【10分】</p>
</blockquote>
<h2 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h2><p>我整理这份笔记花费了好几周，我从本书中收获巨大，希望你能从这篇总结中也有所收获，祝大家玩得开心～</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5E8F"><a href="#u5E8F" class="headerlink" title="序"></a>序</h2><img src="/images/high-output-management-book.png">
<p><a href="http:]]>
    </summary>
    
      <category term="books" scheme="http://blog.devtang.com/tags/books/"/>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[技术演讲中最容易被忽视的问题]]></title>
    <link href="http://blog.devtang.com/2016/06/05/tech-talk-notes/"/>
    <id>http://blog.devtang.com/2016/06/05/tech-talk-notes/</id>
    <published>2016-06-05T08:08:35.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/tech-talk.jpg">
<p>我在国内的大大小小技术会议（比如 QCon, ArchSummit，MDCC，SwiftCon 等）中做过不少演讲，也听过很多别人的演讲。作为一个一路走过来的技术演讲者，我见过很多优秀的演讲者，也见过很多干货满满的分享因为嘉宾的演讲水平问题而搞砸。关于演讲的技巧的文章很多，我想找一个侧面，分享一下技术演讲中最容易被忽视的三个问题。</p>
<h2 id="u8D85_u65F6"><a href="#u8D85_u65F6" class="headerlink" title="超时"></a>超时</h2><p>一个演讲，刚开始准备的时候，通常都会感觉要准备 45 分钟好难，于是就会紧张起来，紧张会使得我们准备过度。而大部分演讲者都不会在正式演讲前完整地模似真实的现场演练一遍。加上演讲现场通常都会因为场下黑压压的人群，以及耀眼的灯光而产生兴奋，兴奋有可能产生两种极端，一种是以非常快地语速把 PPT 讲完，但是大部分认真准备的演讲嘉宾都会由于过度兴奋而深入到演讲的细节中忘记了时间，从而把本来就准备过多的 PPT 更加充分阐述。于是，超时随之而来。</p>
<p>一般像 QCon 这种专业的技术会议，对付超时也是相当专业的，台下的工作人员会在演讲只剩 5 分钟的时候，在台下举牌子让你注意到时间。但是这个时候，你会发现一切都晚了，PPT 只讲了一半，而时间只剩下 5 分钟，除了蒙逼还能干嘛？我见到过一次在 QCon 的超时就是这样，一位来自某一线互联网公司的技术人员，用 5 分钟的时间，把他准备的另外几十页 PPT 翻完了，大家甚至都来不及读完他在 PPT 上的写的所有文字，而基本上他除了翻完，也没有什么办法了。</p>
<p>对付超时怎么办？</p>
<p>第一步：控制 PPT 页数。通常情况下，一页 PPT 演讲时间花费大概是一分钟，一个 45 分钟的演讲一般也要留 10 分钟提问，所以准备 30 - 35 分钟的分享就够了，这样对应的页数大概是 30 - 40 页。当然，如果你的 PPT 中还有大量非摘要的、可以快速翻过的动效内容，页数可以适当增加（比如我在 SwiftCon 中演讲的 PPT 就有 60 页，但其实很多都是动画效果）。</p>
<p>第二步：提前试讲。其实这是最简单的办法，在公司内部直接把自己的演讲主题讲一遍，这样就能够精确地知道会花费多少时间了。如果不方便在公司的分享会上讲，也可以拉几个同事给他们私下分享。如果拉不到同事，自己找个小黑屋，开个计时器，完整地给自己讲一遍，也都是准确了解时间花费的办法。我在 SwiftCon 中的演讲，事先就试讲了 6 次，当然后面很多次是为了打磨内容，而不是了解时间花费。</p>
<h2 id="u5E72_u8D27_u592A_u591A"><a href="#u5E72_u8D27_u592A_u591A" class="headerlink" title="干货太多"></a>干货太多</h2><p>有人问：干货太多是问题吗？我想说：是的，问题很大！</p>
<p>我还记得有一次 InfoQ 给演讲嘉宾做培训，当时的演讲培训师给大家提了一个问题：如果让你的演讲在趣味性和技术性中做选择，你会选择哪个？现场有一半选择了前者，另一半选择了后者。我当时选择的是后者，因为我觉得，一个技术演讲，讲得没意思没关系，只要有干货就行。但是，培训师却告诉我，应该选择趣味性。</p>
<p>培训师的理由是这样的：大部分 45 分钟的演讲，都不足以完整地阐述大量的知识，获取大量的知识有更多方便的途径，比如看书。一个好的演讲者，不是应该让观众在现场接受多少内容的知识，而是让观众在现场产生对演讲内容大体框架的理解，进而在演讲结束后，观众可以进一步通过别的途径获得更多相关的知识。</p>
<p>所以，如果你的演讲原本要讲 10 个干货，那还不如把其中的最重要的 5 个整理得更加生动，形象，有趣。让观众现场能够对你演讲的主题产生兴趣，而另外那 5 个干货，你完全可以附在最后一页 PPT 上，作为延伸学习的推荐话题。如果你的演讲能让观众产生兴趣，在会后学习几个小时，那么听众在知识性上的获取效果绝对比你「填鸭」式的干货分享要好。</p>
<p>所以，适度收敛，少即是多。</p>
<h2 id="u7F3A_u4E4F_u7EC3_u4E60"><a href="#u7F3A_u4E4F_u7EC3_u4E60" class="headerlink" title="缺乏练习"></a>缺乏练习</h2><p>在这个世界上，有很多技巧都不是学来的，而是练出来的。比如我最近在学自由泳，无论我如何熟记姿势的各种要领，我也无法短时间内让自己的身体产生记忆，我能做的只是不停地练习，纠正错误，产生肌肉记忆。演讲也是一样。</p>
<p>你看到的大部分优秀的演讲者，在台上口若悬河，侃侃而谈，其实都是因为他们在之前做了大量的练习。</p>
<p>而大部分技术人员通常都是没有兴趣一遍一遍讲同样的内容，所以，缺乏练习使得他们在台上过度紧张，有些人因为紧张，只能对着讲稿把演讲内容一个字一个字读出来，这样和观众的互动就差太多了。</p>
<p>在这一点上，解决办法除了练习别无它法。我个人会有意识地每个月都做一些分享，很多时候是公司内部的或小范围的分享，这样可以不断提高自己的演讲能力。另外培训师也提到一个办法，就是自己对着摄像机做演讲，然后通过回放录像，来审视自己的表现。我试过一次，确实发现了自己很多问题，感兴趣的同学也可一试。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>超时、干货太多、缺乏练习，这就是技术演讲中我看到的最大的 3 个问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/tech-talk.jpg">
<p>我在国内的大大小小技术会议（比如 QCon, ArchSummit，MDCC，SwiftCon 等）中做过不少演讲，也听过很多别人的演讲。作为一个一路走过来的技术演讲者，我见过很多优秀的演讲者，也见过很多干]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何指导新人 - Mentor 指导手册]]></title>
    <link href="http://blog.devtang.com/2016/05/26/mentor-guide/"/>
    <id>http://blog.devtang.com/2016/05/26/mentor-guide/</id>
    <published>2016-05-26T14:22:21.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/mentor-guide.jpg">
<h1 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h1><p>本文希望帮助 Mentor 在指导实习生和新员工时，建立一些基本的共识和准则。本文主要讨论的是技术类的岗位。</p>
<h2 id="u6211_u4EEC_u4E3A_u4EC0_u4E48_u8981_u62DB_u5B9E_u4E60_u751F_u548C_u5E94_u5C4A_u751F_uFF1F"><a href="#u6211_u4EEC_u4E3A_u4EC0_u4E48_u8981_u62DB_u5B9E_u4E60_u751F_u548C_u5E94_u5C4A_u751F_uFF1F" class="headerlink" title="我们为什么要招实习生和应届生？"></a>我们为什么要招实习生和应届生？</h2><p>猿题库在招实习生上，向来是非常大方的。那么，我们为什么要花大价钱，招那些可能都没有任何实习经验和工程经验的学生？我们是为了让他们做一些简单低级的事情，还是想培养有潜力的学生？相信大家都能明白是后者。</p>
<p>那么，我们为什么想培养有潜力的学生？因为，找到一个靠谱的同事不容易，我们希望帮助这些有潜力的学生成长，在他们在成长的同时，最终能够喜欢上这里，最后能够成为正式员工。所以，为了吸引最优秀的实习生，我们开出来非常高的实习工资和有挑战的工作内容。</p>
<p>对待应届生也是一样，我们非常看重他的学校，成绩，数据结构和算法知识，兴趣，这也是为潜力买单。</p>
<p>但是，我们做的这些，得到的只是有潜力的实习生和应届生。他们离一个优秀的员工还有很大的差距，所以 Mentor 对他们的指导非常重要。如果把他们比做一个好树苗的话，Mentor 就是帮助他们最终成长成参天大树的人。相信大家都能明白，培养人其实比招人难得多。</p>
<p>那么，作为 Mentor，我们应该如何指导这些新人呢？</p>
<h2 id="u5EFA_u7ACB_u53CB_u8C0A"><a href="#u5EFA_u7ACB_u53CB_u8C0A" class="headerlink" title="建立友谊"></a>建立友谊</h2><p>好的老师和学生的关系有些时候更像朋友。大家不但会交流技术，也会一起吃饭聊天，扯淡八卦。互联网公司推崇平等，朋友式的关系更适合讨论技术。</p>
<p>如何建立友谊呢？作为 Mentor，应该在新同事刚刚入职时，带他熟悉公司环境和同事，陪他一起吃饭。平常休息的时候，聊聊工作之外的话题。有些时候，大方一点，请他吃吃饭。</p>
<p>良好的私人友谊，对于新人融入团队是非常重要的，遇到困难时，他会更加主动地向你寻求帮助。等他成长起来后，你们会成为很好的同事。即使以后你和他不在一个项目组，甚至不在一家公司了，但是你们的友谊会使得你们相互尊重并欣赏，谁知道你们以后不会再次合作呢？</p>
<h2 id="u52AA_u529B_u57F9_u517B_u65B0_u4EBA"><a href="#u52AA_u529B_u57F9_u517B_u65B0_u4EBA" class="headerlink" title="努力培养新人"></a>努力培养新人</h2><p>如果说建立友谊算是铺垫的话，那么努力培养新人才算是正题。</p>
<p>虽然大家都懂道理，但是就我观察，很多人都没有意识到培养新人的重要性，当项目太忙，自己精力不够时，就忽略了这方面的工作。而这方面的工作又没有实际明确的标准，就很容易做得不好。</p>
<p>所以，我想了一个评判培养新人重要程度的标准：培养新人的重要程度应该高于所有线上的功能开发，仅仅低于线上的紧急 Bug 修复。如果你手头有重要的开发工作，同时有重要的新人需要培养，那么你应该优先把培养新人的事情做了，再做重要的开发工作。</p>
<p>为什么这么说呢？因为，培养新人是「一次性」的投资，假如一个新人成长起来所需要的指导时间是 20 个小时，那么你尽早的完成这 20 个小时的指导，新人就可以尽早地产出有质量的工作。而如果你因为项目紧张而忽略了这件事情，那么新人可能会养成一些不好的编程习惯或做事方式，之后，你可能需要更多的时间来纠正他。</p>
<p>具体来说，努力培养新人要做好的事情包括：</p>
<ul>
<li>定期主动和新人讨论他遇到的问题。</li>
<li>开始的几周 Code Review，非常详细地审核，保证代码风格达成一致，一些不好的编程习惯得到立即纠正。</li>
<li>教会新人一些正确的学习方式，例如 Google，Github，Stackoverflow。</li>
<li>推荐一些深入的学习资料给新人。并且发现他在某方面没有提高时，持续 PUSH 他看相关的书籍。</li>
</ul>
<h3 id="u5B9A_u671F_u4E3B_u52A8_u548C_u65B0_u4EBA_u8BA8_u8BBA_u4ED6_u9047_u5230_u7684_u95EE_u9898"><a href="#u5B9A_u671F_u4E3B_u52A8_u548C_u65B0_u4EBA_u8BA8_u8BBA_u4ED6_u9047_u5230_u7684_u95EE_u9898" class="headerlink" title="定期主动和新人讨论他遇到的问题"></a>定期主动和新人讨论他遇到的问题</h3><p>建议新人在入职的头一两周可以使用这个办法。比如每天晚上 6 点半，在吃饭前用半小时，让新人把当天学习积累的问题和你讨论。</p>
<p>固定时间做固定的事情，一来使得你被他打断地次数减少，二来也使得他有机会把任何疑问都提出来。</p>
<h3 id="Code_Review"><a href="#Code_Review" class="headerlink" title="Code Review"></a>Code Review</h3><p>基本上刚入职的新人都会有 Code Style 的问题，刚开始的几次 Code Review，我们要首先解决 Code Style 问题。如果新人犯错，可以提供相关的 wiki 或代码风格资料给他，甚至和他进行代码风格的一些讨论，分享一些故事，让他对代码风格产生重视。一个合格的 Mentor 应该让新人在最多三次 Code Review 之后，就能够改正掉几乎所有的代码风格问题。</p>
<p>如果新人对代码风格有不同意见，可以组织一些学习讨论会，也可以在吃饭的时候叫上几个资深一些的同事一起分享这方面的经验。切忌不能只是用强力纠正，而没有让新人产生真正重视代码风格的意识。</p>
<p>在 Code Style 保证的同时，我们还需要让新人了解我们的各种编码约定，例如接口如何定义，目录如何安排，注释的原则，Commit Log 的约定等等。这方面也需要有 wiki 供新人学习。</p>
<p>Code Review 的最难部分，我们需要审核新人的架构和逻辑是否有问题，这方面花费的精力将非常多。对于有问题的架构，和新人的讨论也将花费大量时间。但是这就是新人成长的过程，对于他来说是非常重要的经历。</p>
<p>另外，让新人同时 Review 自己的代码，是一个非常好的学习方式，新人可以模仿和学习到一些好的架构和代码风格习惯。</p>
<h3 id="u6B63_u786E_u7684_u5B66_u4E60_u65B9_u5F0F"><a href="#u6B63_u786E_u7684_u5B66_u4E60_u65B9_u5F0F" class="headerlink" title="正确的学习方式"></a>正确的学习方式</h3><p>部分新人可能对于使用英文查找资料，使用 Google 存在一些障碍。我们应该需要纠正他们不使用百度，不使用中文来进行资料查找，否则对他们知识获取将会有很大的影响。</p>
<p>我们还应该分享一些自己常常学习和提高的方式，推荐一些博客、论坛和社区给新人，让新人学会我们的学习方式。</p>
<h3 id="u63A8_u8350_u5B66_u4E60_u8D44_u6599"><a href="#u63A8_u8350_u5B66_u4E60_u8D44_u6599" class="headerlink" title="推荐学习资料"></a>推荐学习资料</h3><p>在培养一段时间后，你可能就会发现新人在某一些方面的知识有所欠缺，但是显示我们把这些知识系统地讲一遍是不太现实的。我们应该推荐一些相关的书籍给他们，鼓励他们用闲暇的时间来阅读。时不时问问他们学习的进度，或者让他们分享一些学习的体会，都是不错的 PUSH 他们提高的技巧。</p>
<h2 id="u6388_u6743"><a href="#u6388_u6743" class="headerlink" title="授权"></a>授权</h2><p>当你发现新人已经成长起来后，可以尝试将自己熟悉的，同时重要的功能交给他来完成，而你自己做一些其它工作（根据实际情况，可以是更简单的工作，或者是更难的工作）。</p>
<p>这样做的好处是：</p>
<ul>
<li>新人可以借此得到更大的锻炼。</li>
<li>你因为对相关功能很熟悉，所以也能有效地进行指导和监督，控制代码质量和风险。</li>
</ul>
<p>将自己熟悉并且重要的工作交给别人，通常是比较难受的，因为一般人都希望保证效率，而自己因为熟悉，所以效率肯定是最高的。但是长远来看，对于 Mentor 来说，自己也需要成长，将自己擅长的事情交给别人，可以让自己跳出舒适区，尝试更难的事情。这么来看，对 Mentor 自己也是非常有利的。</p>
<h2 id="u56DE_u987E"><a href="#u56DE_u987E" class="headerlink" title="回顾"></a>回顾</h2><p>不管如何用心，刚开始指导新人的时候，总还是会有一些做得不尽人意的地方。Mentor 应该对自己的指导过程有一些总结和回顾，然后总结一些心得，这样在指导下一个新同事的时候，就会做得更加出色。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>在和新人建立良好友谊的基础上，我们需要努力培养他们，并且把这件事情当作最高优先级的事情。具体要做的事情包括：</p>
<ul>
<li>定期主动和新人讨论他遇到的问题</li>
<li>Code Review</li>
<li>教会他正确的学习方式</li>
<li>推荐学习资料</li>
<li>授权给他有挑战的，并且自己熟悉的工作</li>
<li>带完一个新人后，回顾一下自己的工作，看看有哪些值得改进的地方</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/mentor-guide.jpg">
<h1 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h1><p>本文希望帮助 Mentor 在]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[猿题库从 Objective-C 到 Swift 的迁移]]></title>
    <link href="http://blog.devtang.com/2016/05/24/migrate-from-oc-to-swift/"/>
    <id>http://blog.devtang.com/2016/05/24/migrate-from-oc-to-swift/</id>
    <published>2016-05-24T14:15:31.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><p>相信没有人会怀疑，Swift 是 iOS 开发未来的主流语言，但是由于 Swift 语言的不断变化以及庞大的迁移成本，真正把项目迁移到 Swift 语言的公司并不多。而猿题库 iOS 客户端是一个超过 3 年的项目，积累了超过 15 万行的 Objective-C 代码，我相信它在迁移过程中的经验对很多人有所帮助。</p>
<p>蓝晨钰（@晨钰Lancy）是猿题库 iOS 客户端的负责人，他主导了猿题库 iOS 客户端从 Objective-C 到 Swift 的迁移工作。同时他在实践 Swift 的过程中，总结了不少心得，这次他将会在 GMTC 大会上分享这方面的话题，以下是我对他的采访，希望对大家有帮助。</p>
<h3 id="u63D0_u95EE"><a href="#u63D0_u95EE" class="headerlink" title="提问"></a>提问</h3><blockquote>
<p>问题：向读者简单介绍一下自己吧。</p>
</blockquote>
<p>我叫蓝晨钰，iOS 开发者，11 年开始接触 iOS 开发，13 年加入猿题库负责 iOS 客户端开发工作，和猿题库一起经历了从无到拥有数千万用户的成长，和我的团队一起完成了数十个版本的迭代。</p>
<p>我从 14 年底 Apple 发布 Swift 语言开始一直关注和学习其知识理念，并在 15 年初在公司推广和实践 Swift 项目，至今在生产环境实践 Swift 已经超过一年，算是有比较丰富的移动客户端开发经验和 Swift 编程经验吧。个人对 Swift 语言的持乐观态度，在公司内积极推进 Swift 语言的实践，也非常享受 Swift 的编程体验。</p>
<blockquote>
<p>问题：听说你这次打算在 GMTC 上分享的话题是：《当泛型遇上协议 —— Generic Programming with Protcol in Swift》，能简单介绍一下为什么选这个主题吗？</p>
</blockquote>
<p>泛型编程和面向协议编程都是 Objective-C 语言所没有的特性，作为一个老 iOS 开发者来说，当我第一次接触它们时，我的内心是激动的，我迫不及待的想知道，这些个新特性新技术，会给我们的程序和开发带来怎么样的变化。而经过我们团队的不断学习和实践，我们也的确在这当中找到了很多乐趣，积累了不少经验，我希望能通过这次分享讲它们分享给更多人。</p>
<blockquote>
<p>问题：你怎么看待泛型编程和面向协议编程在客户端编程的未来？</p>
</blockquote>
<p>泛型编程是许多现代语言所有的特性，在其他语言的实践经验告诉我们，泛型是一个强大的工具，经常能有效的提高编程效率和提高代码的复用程度。面向协议编程则是由 Swift 提出的编程范式，强大的表达力和抽象能力，毫无疑问会变成一项重要工具。而这两者的结合则是一种全新的体验，这也是我这次分享的一个重要部分。</p>
<p>同时，由于 Swift 语言缺乏类似 objc runtime 的机制，我认为泛型编程和面向协议编程作为实现之前 runtime 所实现功能的替代，将越来越成为 iOS 开发者需要掌握的重要技能。</p>
<blockquote>
<p>问题：猿题库当前对 Swift 的使用到什么程度？已经完全迁移到 Swift 了吗？</p>
</blockquote>
<p>猿题库有两个客户端项目，分别是老师端和学生端，他们都是 Swift 和 Objective-C 混编的项目，并没有完全迁移到 Swift。其中猿题库老师端是在 Swift 发布之后不久启动的项目，我们在这个项目中开始推行 Swift 语言，所以这个项目是一个 Swift 语言为主的项目，Objective-C 部分主要为复用旧代码。</p>
<p>而猿题库学生端是我们的主项目，这个项目从 iOS 5 时代开始，一直使用 Objective-C 编写，直到近期 Swift 升到 2.x 之后，我们认为 Swift 已经足够成熟，并且我们在老师端中积累了足够的经验后才开始向 Swift 迁移的。目前学生端的项目中，大部分还是 Objective-C 语言实现，但新实现的页面和功能基本都使用 Swift 语言来编写。</p>
<blockquote>
<p>问题：你认为猿题库大概还需要多长时间能够完全迁移到 Swift?</p>
</blockquote>
<p>事实上，在生产环境中，几乎没有人愿意在收益甚微的情况下把 Objective-C  代码重写一次，因为重写意味着大量的研发资源和测试资源的消耗，而这基本不会产生实际意义上的产品收益。另外 Apple 在 Swift 和 Objective-C 的桥接上做了相当多的努力，大部分情况下，我们都可以不太费力的在 Swift 中复用 Objective-C 代码。</p>
<p>所以大部分公司的策略都会是新功能用 Swift 语言实现，旧功能先维持现状，等到产品变动或是架构变动的时候再使用 Swift 语言实现，这也是猿题库所采用的策略。所以我想短时间内不太可能完全迁移到 Swift 吧。如果非要说一个时间的话，我推测大约一年之后大部分业务应该会迁移到 Swift，而整个项目彻底迁移恐怕就需要两到三年以上了。</p>
<blockquote>
<p>问题：你认为 Swift 什么时候能够达到 ABI 稳定？</p>
</blockquote>
<p>老实说，我也不知道。Swift 的发展很快，我这次主题要讲的泛型相关的实践，在 Swift 1.x 的时候就没法实现。Swift 项目组的 Chris Lattner 也公开表示 Swfit 3.0 不会达到 ABI 稳定并且会缺少一些重要的泛型功能。我们只能期待在 Swift 3.x 或 Swift 4 的时候会有惊喜吧。</p>
<blockquote>
<p>问题：对比 Swift 和 Objective-C，你觉得 Swift 最大的优势是什么？</p>
</blockquote>
<p>Swift 的优势有很多，我比较喜欢的有几点：更安全的类型，代表更少的 Bug 和更低的崩溃率；更简洁的语法，代表更少的代码和更快的编程速度；强大的函数式、泛型、协议等特性，代表更能发挥程序员的想象力。选一个的话，我选最后一个，强大的特性给了我很大的编程愉悦感。</p>
<blockquote>
<p>问题：对于从 Objective-C 迁移到 Swift，你有遇到什么值得分享的坑吗？</p>
</blockquote>
<p>从 Objective-C 迁移到 Swift 代表着在很长一段时间内都是处于混编的状态，这里我认为最重要的经验是一定要有一个迁移的规范和指南来约束开发团队哪些部分需要迁移 Swift 而哪些部分不要，接口应该如何设计才能兼顾混编调用。举个例子，由于 Swift 调用 Objective-C 是方便的可靠的，反之则有许多的限制，所以设计接口的时候，需要考虑这个模块会不会被 Objective-C 调用，如果是的话，应该避免使用 Swift 语言的特性，又或是制定一套规则，来 Swift 语言的接口如何转成 Objective-C 兼容的接口。</p>
<blockquote>
<p>问题：对于学习 Swift，你有什么推荐的方法或资料吗？</p>
</blockquote>
<p>iBooks 上有 Apple 推出的 Swift Programming 系列书籍是所有 iOS 开发者的必读和参考书目。iTunes U 上有 Stanford 的 Developing iOS  Apps with Swift，讲师是 Apple 工程师 Paul Hegarty，推荐新入门的 iOS 开发者学习。</p>
<p>Objc.io 上的 Advanced Swift 是我最近在读的书，内容绝对对得起 Advanced 这个词，推荐有一定基础 Swift 开发者阅读。此外 Github 上有大量的 Swift 开源项目，可以阅读源码来学习。</p>
<p>最后，也是最重要的，多写，多想，实践是最好的学习方式。</p>
<blockquote>
<p>问题：你对今年 WWDC 有什么期待吗？</p>
</blockquote>
<p>最大的期望是能去一次 WWDC（笑），可惜我们公司每年到 6 月高考的时候就是最忙的时候，所以这个愿望只能等以后了。对 WWDC 本身的话，期望 Apple 能弄出一些新东西，比如我很看好的虚拟现实相关的产品和技术。</p>
<p>另外希望 Apple 能加快 Swift 的推进，比如发布与 Google 合作推进 Swift 语言在 Android 客户端的应用之类。</p>
<p>全文完。</p>
<h3 id="u5E7F_u544A"><a href="#u5E7F_u544A" class="headerlink" title="广告"></a>广告</h3><p>由 InfoQ主办的GMTC全球移动技术大会将于6月24日在北京召开。来自BAT、携程、滴滴和社区的技术专家联袂分享，主题包括应用架构、性能优化、动态化、插件化、Swift、React Native、Weex等。本周移动大会8折最后一周，我的粉丝本周前20人报名享受6折1080的优惠呦，手慢无！手慢无！<br>优惠码：GMTC-TangQiao</p>
<p>购票链接：<a href="http://www.bagevent.com/event/27886?bag_track=tangqiao" target="_blank" rel="external">http://www.bagevent.com/event/27886?bag_track=tangqiao</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><p>相信没有人会怀疑，Swift 是 iOS 开发未来的主流语言，但是由于 Swift 语言的不断变化以及庞]]>
    </summary>
    
      <category term="Interview" scheme="http://blog.devtang.com/tags/Interview/"/>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（六）- 类型推断]]></title>
    <link href="http://blog.devtang.com/2016/05/22/swift-gym-6-type-infer/"/>
    <id>http://blog.devtang.com/2016/05/22/swift-gym-6-type-infer/</id>
    <published>2016-05-22T05:46:26.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<p>前几天，一个朋友在微博上通过私信问了我一个问题，如下的代码，为什么变量 <code>crr</code> 没能把值为 nil 的元素过滤掉？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr:[Int?] = [1, 2, 3, nil, 4, 5]&#10;let brr = arr.flatMap &#123; $0 &#125;&#10;brr&#10;// brr = [1, 2, 3, 4, 5]&#10;&#10;let crr:[Int?] = arr.flatMap &#123; $0 &#125;&#10;crr&#10;// crr = [&#123;Some 1&#125;, &#123;Some 2&#125;, &#123;Some 3&#125;, nil, &#123;Some 4&#125;, &#123;Some 5&#125;]</span><br></pre></td></tr></table></figure>
<p>简单来看，同样是使用 <code>flatMap</code> 函数，brr 变量成功过滤掉了值为 nil 的元素，变量 crr 过滤失败。而 brr 和 crr 的区别就是它们的类型不一样，brr 的类型是 <code>[Int]</code> ，而 crr 的类型是 <code>[Int?]</code>，想必其中原因与此有关，那到底是为什么呢？</p>
<p>在和一些朋友讨论之后，我大概想明白了，这和类型推断有关系。在 crr 相关的代码中，因为 crr 的类型已经被程序员指定为 <code>[Int?]</code>，所以为了编译通过，编译器需要推断出 <code>flatMap</code> 中的闭包的输入和输出变量类型。我们回顾一下 <code>flatMap</code> 在数据中的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension SequenceType &#123;&#10;    public func flatMap&#60;T&#62;(@noescape transform: (Self.Generator.Element) throws -&#62; T?)&#10;                rethrows -&#62; [T]&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，flatMap 返回的结果是 <code>[T]</code>，而闭包 transform 返回的结果是 <code>T?</code>。而在 crr 这个例子中，T 被推断出是 <code>Int?</code> , 因此 tranform 中 <code>T?</code> 就被代入，变成了 <code>(Int?)?</code> 。所以，如果完善一下上面例子的代码，编译器推断出来的类型是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let crr:[Int?] = arr.flatMap &#123;&#10;    (element: Int?) -&#62; (Int?)? in&#10;    return element&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里，返回的变量 element 其实类型并不是 <code>(Int?)?</code>，但是 Optional 是有 conversion 的方法，允许将一个类型的 <code>S</code> 的变量，自动转成 <code>S?</code>，所以转换被自动做了，并没有编译错误发生。</p>
<p>怎么改这个代码呢？</p>
<p>有人说把闭包的类型手工指定成 <code>Int?</code>，我试了一下，确实能够正常了，不过我感觉这更像是一个编译器的 Bug，我们再看看这个接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension SequenceType &#123;&#10;    public func flatMap&#60;T&#62;(@noescape transform: (Self.Generator.Element) throws -&#62; T?)&#10;                rethrows -&#62; [T]&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>按照 <code>flatMap</code> 的接口定义，如果闭包返回的是 Int?，那么按照这个定义，最终 <code>flatMap</code> 的结果就必须是 <code>[Int]</code>，而我们要强制要求结果是 <code>[Int?]</code>，除非这里有自动的转换，否则就应该编译失败。而我自己的试验代码失败，确认出并没有从 [Int] 到 <code>[Int?]</code> 的自动转换。所以我暂时认为这么改能正常工作是一个编译器的 Bug（如有错误，欢迎指出）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: cannot convert value of type &#39;[Int]&#39; to specified type &#39;[Int?]&#39;</span><br></pre></td></tr></table></figure>
<p>另外，也有朋友说，在这种场景下并不应该使用 <code>flatMap</code> 函数。确实是这样，flatMap 函数本来就有着 flat 的作用在里面，在数组的 <code>flatMap</code> 实现中，有两个重载：</p>
<ul>
<li>一个重载版本是为了打平嵌套的多维数据。</li>
<li>另一个重载版本，就是我们刚刚讨论的版本，flat 是为了去掉 Optional 的封包，同时把 nil 元素去掉。</li>
</ul>
<p>而这个示例代码调用了 <code>flatMap</code> 函数，却希望仍然得到 Optional 的数组，实在是不应该使用 <code>flatMap</code> 来做这个事情。如果只是为了去掉 Optional 中的 nil 元素，使用 <code>filter</code> 方法可能更为合适一些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;let arr:[Int?] = [1, 2, 3, nil, 4, 5]&#10;let drr:[Int?] = arr.filter &#123;&#10;    if let _ = $0 &#123;&#10;        return true&#10;    &#125; else &#123;&#10;        return false&#10;    &#125;&#10;&#125;&#10;drr&#10;// drr = [&#123;Some 1&#125;, &#123;Some 2&#125;, &#123;Some 3&#125;, &#123;Some 4&#125;, &#123;Some 5&#125;]</span><br></pre></td></tr></table></figure>
<p>其实函数式编程的方法不止 <code>map</code>, <code>flatMap</code>, <code>filter</code> 这些，在一个名为 <a href="http://reactivex.io/" target="_blank" rel="external">reactiveX</a> 的网站上，列举了 Reactive 编程实践下的一些 <a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="external">常见的函数</a>，里面的很多方法都挺有意思，这些方法也被实现在了 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a> 中，感兴趣的同学可以看看。</p>
<p>祝玩得开心！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天，一个朋友在微博上通过私信问了我一个问题，如下的代码，为什么变量 <code>crr</code> 没能把值为 nil 的元素过滤掉？</p>
<figure class="highlight plain"><table><tr><td class="code"><p]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[济州岛旅游见闻]]></title>
    <link href="http://blog.devtang.com/2016/05/08/jeju-island-tour/"/>
    <id>http://blog.devtang.com/2016/05/08/jeju-island-tour/</id>
    <published>2016-05-08T13:44:12.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>公司五一节给大家放了九天假，于是和家人去了一趟济州岛，记录一些见闻。</p>
<h2 id="u4E71_u6253_u79C0"><a href="#u4E71_u6253_u79C0" class="headerlink" title="乱打秀"></a>乱打秀</h2><img src="/images/nanta-show.jpg">
<p>在观看乱打秀之前，我以为乱打秀就是一种利用各种厨房炊具进行音乐打击演奏的表演。看完之后，我才发现乱打秀其实是一种混合了多种表演形式的艺术混合体。</p>
<p>乱打秀的核心内容是音乐，在表演中，演员会利用各种厨房乐器来进行各种有节奏感的打击。但是如果只是听打击乐声的话，演出难免单调，所以乱打秀在打击音乐的同时，又混入了很多别的表演元素。</p>
<p>首先混入的是不少杂技的表演内容。例如：在奔跑中翻跟头、相互之间非常快速地扔盘子、背对篮筐投篮、耍双截棍以及打斗等等。这些杂技类的元素对于演员的身体素质和协调性要求非常高，现场能够看出女演员的腹肌和手臂肌肉非常结实。乱打秀的故事场景是在厨房，所以还有一些关于刀功的杂技元素，其中一个环节大家比拼切菜的功力，整个表演演员用锋利的菜刀切出各种效果，看得让人心惊动魄。</p>
<p>然后混入的是魔术元素。包括一个把酒瓶变没的魔术，以及一个丝巾变棍子的魔术，现场还利用灯效配合演员做出蜡烛灭掉和点亮的魔术。魔术元素虽然不多，但是因为观众事先并没有预期，所以看到时还挺意外的，有一点惊喜。</p>
<p>接着混入的是小品的元素。整个乱打秀融入在一个紧张的烹饪任务的故事情节中，随着剧情地发展，观众会不自觉地融入到那种紧张的故事剧情中。</p>
<p>乱打秀还融入了大量与观众的互动，这些互动有一些非常深入，已经本身成为了演出的一部分。其中有一个环节是邀请几个观众上台参与包饺子，然后突然演员们都快闪离场了，留下几个观众尴尬地不知所措，现场观众笑翻天了。另外还有一个环节是演员邀请观众和他一起打拍子，演员故意用生气地表演来表示对观众的配合不满意，然后学大家各种搞笑的动作，非常有意思。</p>
<h2 id="u7535_u52A8_u6C7D_u8F66"><a href="#u7535_u52A8_u6C7D_u8F66" class="headerlink" title="电动汽车"></a>电动汽车</h2><p>济州岛的景点离得都比较远，所以一般自由行都需要包车。这次包车的时候，我发现我们乘坐的竟然是一辆新能源电动汽车，进一步了解到，济州岛政府都在推广电动汽车。</p>
<img src="/images/sumsang-car.jpg">
<p>我们乘坐的电动汽车是三星旗下的（如上图），在国内完全搜索不到。与国内不同的是，三星的这款电动汽车快充和慢充是共用一个充电口。另外听司机说，快充充满电只需要 20 分钟，满电可以开 100 多公里，听起来还是非常夸张的。可惜在网上搜不到这款车的中文资料。</p>
<h2 id="u7269_u4EF7"><a href="#u7269_u4EF7" class="headerlink" title="物价"></a>物价</h2><p>济州岛的物价整体还是比北京还是要高一些，吃一碗当地的猪肉面，最少是 7000 韩元，折换成人民币大概 40 多块钱。如果不吃面，人均 80 元左右吧。出租车的话，起价 2800 韩元（约 17 元人民币）。当地的特产橘子，长得有点像国内的丑橘，但是便宜的也要 2000 韩元一个（约 10 元人民币）。</p>
<p>济州岛的海产品非常丰富，按理说海产应该比较便宜对吧？但是也不是，一个当地产的带鱼，好一点的要 6 万韩元一公斤（约 180 元人民币一斤）。</p>
<h2 id="u996E_u98DF"><a href="#u996E_u98DF" class="headerlink" title="饮食"></a>饮食</h2><p>济州岛在古代其实是流放之地，物资比较匮乏。所以济州岛上其实没有什么特别好吃的东西。当地有名的食物，无非就是：猪肉面，参鸡汤，烤黑猪肉，海鲜锅，炸鸡。</p>
<p>从这些食物上可以感受到当地蔬菜匮乏，我个人对参鸡汤的评价还可以，烤肉的话，其实北京的味道一点也不比当地的差。</p>
<h2 id="u514D_u7A0E_u8D2D_u7269"><a href="#u514D_u7A0E_u8D2D_u7269" class="headerlink" title="免税购物"></a>免税购物</h2><p>济州岛为了吸引外国人（其实主要就是中国人）前来旅游，专门有大型的免税店：新罗免税店和乐天免税店。在相关购买流程上，政府做了很多优化的工作。比如在新罗免税店，我们可以直接刷支付宝、微信支付以及银联卡。</p>
<img src="/images/jeju-mall.jpg">
<p>我还记得大概 5 年前来济州岛购物的时候，每件商品都还需要填一个退税申请，然后跑到机场相应的窗口办理退税。但是这一次，我们在一家叫 eMart 的可退税超市，超市的收银机可以直接刷护照，然后将税金当场免去，购物体验相当棒。</p>
<p>免税购物和免签证应该是济州岛吸引中国游客的大杀器，基本上到处都是中国人，各种商店也都有中文导购。</p>
<h2 id="u5929_u6C14"><a href="#u5929_u6C14" class="headerlink" title="天气"></a>天气</h2><p>济州岛有三多：石多、风多、女人多。我们去的第二天就赶上了接近 9 级的大风。基本上大风夹着一些雨水，使得室外的旅游完全无法进行了，还好有很多室内的观光景点可以游玩，不然还是挺遗憾的。济州岛最佳的旅游时间其实是秋季，我们上次来旅游就是那个时节，完全没有大风。</p>
<h2 id="u672A_u6765"><a href="#u672A_u6765" class="headerlink" title="未来"></a>未来</h2><p>济州岛近年来因为旅游火爆，整体物价和房价都涨了很多，不知道这对当地居民来说是祸是福。</p>
<p>这次了解到有很多租车公司提供济州岛自驾服务，车子上还专门有中文的导航，只需要有国际护照即可，希望如果下次带来，能够试一试。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>公司五一节给大家放了九天假，于是和家人去了一趟济州岛，记录一些见闻。</p>
<h2 id="u4E71]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SwiftCon 期间的面基和八卦]]></title>
    <link href="http://blog.devtang.com/2016/05/07/swiftcon-2016-chat-notes/"/>
    <id>http://blog.devtang.com/2016/05/07/swiftcon-2016-chat-notes/</id>
    <published>2016-05-06T16:01:37.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/swiftcon-friends.jpg">
<p>4 月 23 - 24 日，我参加了上海的 <a href="http://www.swiftconchina.com/" target="_blank" rel="external">SwiftCon</a> 大会。有一些人说参加会议主要就是混圈子，也有一些人说参加会议主要是了为听干货，还有一些人在微博上投票，到底我们应该听干货还是去混圈子。好吧，不能都做吗？一次会议演讲嘉宾的质量固然重要，但是一次会议天然地把一群相同趣味的人聚集到了一起，不乘机好好认识一下扯扯蛋聊聊天，多可惜呀。</p>
<p>我这次去上海参会，不但听了很多有意思的分享，私下也见了特别多朋友。和这些朋友面基聊天，很是开心，一些讨论也很有感触，一并记录一下。</p>
<p>本文主要记录聊天扯蛋方面的感受，如果要看技术方面的总结，可以移步到 <a href="/2016/04/25/swiftcon-2016-notes/">《SwiftCon 2016 参会感想》</a>。</p>
<h2 id="tinyfool__26amp_3B__u788E_u6708_u6210_u661F"><a href="#tinyfool__26amp_3B__u788E_u6708_u6210_u661F" class="headerlink" title="tinyfool &amp; 碎月成星"></a>tinyfool &amp; 碎月成星</h2><p>tinyfool 是我面基的第一个人。那天是大会正式开始前一天的下午，我们约在一家咖啡馆聊天。一同来的还有大会的组织者锅巴，触控科技的廖宇雷，tiny 公司的 CTO 碎月成星（陈勇辉）。</p>
<p>第一感受就是，tiny 是一个非常健谈的人。我们几个人在那儿聊天，基本上将近一半的表达时间都被 tiny 霸占了。不过我是那种特别容易冷场的人，所以有一个人不停地叨叨，反倒感觉特别舒服，我只需要听着就可以了。</p>
<p>tiny 的思路转换得特别快，基本上给他一个话题，他就可以一直发散下去，各种观点听起来也挺有意思。我们聊在线教育，聊招人，聊 Remote 的工作方式，聊雾霾，聊创业，聊学习和成长，还有各种八卦。也许是聊得太多吧，好多观点也没能记住。tiny 说他创业做不下去了，打算把公司关了找工作，这一点在第二天的大会演讲中他也提到了。</p>
<p>还记得的就是各种 tiny 和碎月成星的趣事，这两个人的性格就像冰与火一样处在两个极端，碎月成星是那种极度内向的人，但是他们却能够一起合作经营公司。我也私下八卦了一下 tiny 的小女朋友的故事，就不给大家说了，哈哈，祝他们早日成婚。</p>
<p>聊天时，碎月成星讲了一个非常有意思的笑话，现场听他讲完，感觉他也是那种人混熟之后，话也能讲很多的人。</p>
<h2 id="u9505_u5DF4__26amp_3B__u6273_u5B50"><a href="#u9505_u5DF4__26amp_3B__u6273_u5B50" class="headerlink" title="锅巴 &amp; 扳子"></a>锅巴 &amp; 扳子</h2><p>锅巴在忙完大会的一些琐事后，赶过来加入了我和 tiny 的聊天。从锅巴那儿，我了解到这次大会基本上由他和扳子两个人完成，他们都有固定的工作，这种会议是完全民间的行为。锅巴说，之前办 PHP 相关的大会很成功，现在 Swift 语言刚刚兴起，没有人办过，所以就决定办一场。</p>
<p>相比今年年初在北京的 <a href="http://atswift.io/" target="_blank" rel="external">atSwift</a> 大会，锅巴的这次 SwiftCon 大会是两天的时间，时间更长（atSwift 大会是一天），场地租金更贵（atSwift 大会是租的学校的会场），而且锅巴考虑到有很多是外地的嘉宾和参会者，所以选择的会场离机场特别近，这也一定程度上增加了办会的成本。</p>
<p>锅巴私下和我聊的时候说到，他们之前甚至打算亏本办这场大会，不过聊天中我问他卖票情况，他说还比较理想，我估计应该是没有亏本的。办会不亏本应该是非常好的事情，这样才能使得大家有动力持续改进会议质量。锅巴还是一个特别大度的人，他们这次还邀请了算是「竞争对手」的梁杰的 atSwift 大会组委会成员，并且为他们提供了免费的展台。</p>
<p>当然，聊天少不了八卦，锅巴提到关于股票的高频交易一些趣事，很有意思，涉及一些敏感信息就不给大家说了，哈哈。</p>
<h2 id="u5434_u67EF_u7476"><a href="#u5434_u67EF_u7476" class="headerlink" title="吴柯瑶"></a>吴柯瑶</h2><p>吴柯瑶是一个性格外向活泼的美女，从非技术工作转而做 iOS 开发，没有参加培训班，自己一点一点成长起来。她在找工作的时候，因为是女生，遭遇了更多的挑战。本来她找 tinyfool 想让他帮忙推荐，tinyfool 做了一个非常明智的决定，tinyfool 说：「你先找，自己试试看，不行再说」。结果，瑶瑶最后凭自己的能力找到了 iOS 开发的工作，这件事情 tiny 做得太赞了，因为它让瑶瑶获得了相当大的自信心。</p>
<p>这次大会吴柯瑶是主持人，在大会中午休息的时候，瑶瑶分享了一段自己成长的经历，不知道有多少人认真听了，我感觉她的成长过程对于大家的启发或许更多。</p>
<p>和瑶瑶聊天八卦的主要是她以前当模特的故事，嗯，详细的也不给大家说了，哈哈。</p>
<h2 id="u5085_u82E5_u611A__26amp_3B__u65B9_u5FD7_u521A"><a href="#u5085_u82E5_u611A__26amp_3B__u65B9_u5FD7_u521A" class="headerlink" title="傅若愚 &amp; 方志刚"></a>傅若愚 &amp; 方志刚</h2><p>大会第一天结束后，我和 ThoughtWorks 的几个朋友（傅若愚、方志刚、小灰灰）一起去撸串。他们给我介绍了很多关于这家公司的趣事。小灰灰其实是前 ThoughtWorks 员工，现在在 SegmentFault 做市场运营相关的工作。</p>
<p>ThoughtWorks 以前在我眼中总是很神秘，这次和他们聊天，更进一步从各种故事中了解了这家公司。和别的偏咨询的业务不太一样，ThoughtWorks 在移动开发领域，整体上业务还是侧重「外包」开发的工作较多。</p>
<p>在和他们聊天的过程中，我才发现 ThoughtWorks 是在 iOS 开发中，也实践成功了 TDD 的公司。而这一点，其实做到的互联网公司非常少。在我之前的认知中，因为移动开发的单元测试能够覆盖的代码极其有限，加上移动开发中的功能模块（特别是上层的界面和交互逻辑）在快速迭代中反复更改，我认为 TDD 并不适合在移动开发领域。ThoughtWorks 的故事让我再次对自己的观点产生了动摇。</p>
<p>进一步了解到，ThoughtWorks 的一个 App 的业务逻辑，可能由超过 10 个人来完成，另外 ThoughtWorks 的员工也可能分布在不同的城市，他们需要更解耦地工作和协调，而这个时候，TDD 成为一个很简单有效的方式。ThoughtWorks 接的 App 开发的单子，本身也不太可能像移动互联网公司那样，两周发一个版本来快速迭代。综合起来，在移动开发中引入 TDD，或许适合这样的场景：</p>
<ul>
<li>App 开发人员超过 10 人，并且大家代码相互依赖</li>
<li>App 开发人员异地协同工作</li>
<li>App 的迭代周期不算特别频繁</li>
<li>App 的质量非常重要</li>
</ul>
<p>小灰灰还提到，ThoughtWorks 这家公司还有一个比较独特的地方，就是创始人不完全以赢利为目的来经营公司，比如他们会接一些明显亏本的、但是公益性的项目，比如在一些第三世界国家，帮助当地的政府开发一些信息系统。整体 ThoughtWorks 中国区还是很挣钱的，但是补贴给了不少国外的亏本项目。</p>
<p>ThoughtWorks 另外一个文化，就是大量招聘新人，大部分员工都是工作 1-3 年的，使用新人的首要原因其实是因为便宜，ThoughtWorks 在整体互联网行业中给付的薪水并不高，所以使用新人可以使得他们能够控制住成本。同时，ThoughtWorks 还是比较有技术追求的，他们公司内部有一些行业资深的大牛可以指导这些新人，于是那些有潜力的新人，能够得到快速地项目锻炼和恰当的指导，于是快速成长。小灰灰说，有一些新人，刚进公司，就要去给那些年纪比他大十几岁的客户做敏捷咨询，那种压力是巨大的，相对来说成长也是巨大的。</p>
<p>但是，终究 ThoughtWorks 这种模式下，能够到达金字塔顶端的人是少数，所以大部分员工在工作几年之后，能力成长起来了，就会选择跳槽。拿小灰灰的话说：「薪资 double 是至少的，能力强的能够 triple」。</p>
<p>其实对于 ThoughtWorks 来说，这其实是「双赢」的。为什么人离职了还是「双赢」呢？因为 ThoughtWorks 还是留住了少量最最精英的人到达金字塔的顶端，同时 ThoughtWorks 以非常小的人力成本，保证了它能够完成项目，公司能够正常经营。那些离开 ThoughtWorks 的人，在公司经历了历练和成长，何尝不会感恩公司，他们在别的公司做得好，反倒会正面宣传 ThoughtWorks 的技术影响力。</p>
<p>我有一次听到一个类似的故事，四大会计事务也是大量招募新人，很多重要的项目，用老人带新人的方式开展工作，那些新人拿着非常低的薪水，但是工作压力特别大，但是通常三年之后，这些新人成长起来，离职都能够找到非常好的新工作。而少量留下来的四大老员工，又继续着这种老人带新人的模式。</p>
<p>某种程度上，这就是一种商业模式，这些公司选择用低薪 + 成长空间，来吸引应届毕业生，同时获得商业收益，虽然人员不停流动，但是公司依然能够经营得很好。</p>
<h2 id="u9648_u4E58_u65B9"><a href="#u9648_u4E58_u65B9" class="headerlink" title="陈乘方"></a>陈乘方</h2><p>因为陈乘方所在的公司雇佣了图拉鼎，以 Remote 的方式为 ENJOY 工作过。所以我找他聊天时，首先请教了一下在以 Remote 的方式合作时，有哪些注意事项。陈乘方提到最好 Remote 的工作内容还是比较确定，不太会变的产品方案，因为远程修改产品细节将涉及大量的沟通工作，这样效率会非常低下。</p>
<p>陈乘方也介绍了一些远程工作的实践，比如在微信群里面，用微信语音来开每天早上的站会，方便大家沟通上一天的进度和当天的安排。我相信这里面的实践技巧还有很多，因为时间关系，我也没有详细了解。</p>
<h2 id="LYcHEE"><a href="#LYcHEE" class="headerlink" title="LYcHEE"></a>LYcHEE</h2><p>这次去上海，我还专门见了荔枝软件的 LYcHEE。LYcHEE 一直在努力推广正版的 Mac 软件，他经营的 <a href="https://sbcwangka.taobao.com/" target="_blank" rel="external">小店</a> 虽然没挣多少钱，但是也够他日常的生活开销。我之前和他合作推广过 Charles 和 Reveal，都非常愉快。</p>
<p>LYcHEE 的 <a href="https://sbcwangka.taobao.com/" target="_blank" rel="external">淘宝小店</a> 的模式是，和国外的正版软件谈合作，然后一次性地下单购买几百个 License，然后再销售。通常为了保证软件是正版的，这些 License 都是正版软件官方网站购买的兑换码，这样可以保证购买人的注册信息都是兑换时生效的。LYcHEE 的风险其实也来源于这种模式，因为这些 License 都是批量采购，一旦没有卖到一定数量，他就会面临亏本。</p>
<p>和 LYcHEE 聊天，我发现他是一个非常自律的人，因为他自己开淘宝店，所以每天上班的地方就在家里。他会每天早上固定的时间起床，然后健身，然后工作，中午和晚上也会有固定时间休息。我特别佩服这种自律性强的人，LYcHEE 个子很高，整个人看起来非常精神，由于长期健身，身体有明显的肌肉线条，非常帅。</p>
<p>他的淘宝店的客服，也全部都是远程办公的方式在协作。这种 Remote 的方式和图拉鼎的 Remote 有很大的差别，因为客服的 PKI 很好制定，也非常有效（比如回答量，响应时间等），所以 LYcHEE 只需要定好 PKI，就可以很好地管理这些客服的工作了。而淘宝的卖家平台也很方便地提供了这些 PKI 指标。</p>
<p>如果你长期使用 Mac 电脑，以后买正版软件之前，建议都可以去 LYcHEE 的 <a href="https://sbcwangka.taobao.com/" target="_blank" rel="external">淘宝小店</a> 先搜一下，基本上如果有正版的话，都是网上能够买到的最低价了。</p>
<p>另外，LYcHEE 私下告诉我，他在卖正版的 Mac 软件之余，计划再做一些更大的事情，期待着他的新产品发布。</p>
<p>嗯，顺便还见到了 LYcHEE 的女朋友，祝早日成婚～</p>
<h2 id="u6C64_u5723_u7F61"><a href="#u6C64_u5723_u7F61" class="headerlink" title="汤圣罡"></a>汤圣罡</h2><p>汤哥一直是我眼中的全才，运维、开发、设计通吃，这次终于有机会见到了他真人。汤哥性格非常内向，另外感觉有一些固执，对事情有着自己的看法，不太容易说服他，哈哈。</p>
<p>汤哥一直强调会场的凳子坐着屁股疼，到大会第二天中午，马上轮到我分享前，汤哥说屁股实在坐不住了，要走了。吓得我赶紧抽中午的时间，把下午的分享提前给他讲了一遍。但是，结果到大会分享结束前，汤哥都没有走！汤哥不但又听了一遍我的分享，还把傅若愚的分享也听完了才走。我对此表示，以后再也不相信汤哥的屁股会疼了。</p>
<p>关于汤哥的八卦，嗯，汤哥给我讲了讲他们家那边的做相亲 O2O 的大妈，实在是非常有趣，如果你见到了他，一定得让他讲一讲。</p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>每次参加各种技术大会，我都会挑几个感兴趣的主题，认真听演讲嘉宾的分享，然后别的时间，我就会到处找朋友聊天八卦。我想这才是参加技术大会正确的姿势，没人说你一定需要坐在凳子上一直听到「屁股疼」，对吧？</p>
<p>希望明年的 SwiftCon 大会，能够见更多的新朋友，听更多的八卦和趣闻。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/swiftcon-friends.jpg">
<p>4 月 23 - 24 日，我参加了上海的 <a href="http://www.swiftconchina.com/" target="_blank" rel="external">Swi]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SwiftCon 2016 参会感想]]></title>
    <link href="http://blog.devtang.com/2016/04/25/swiftcon-2016-notes/"/>
    <id>http://blog.devtang.com/2016/04/25/swiftcon-2016-notes/</id>
    <published>2016-04-24T16:10:53.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<p>4 月 23 - 24 日，我参加了由 Think 技术社区举办的 <a href="http://www.swiftconchina.com/" target="_blank" rel="external">SwiftCon</a> 大会。这次大会见到了很多新老朋友，也从嘉宾的分享中学习了很多，微博上对于此次大会也有一些争议，一并写个参会感想，分享一下我的观点。</p>
<h2 id="u5206_u4EAB_u7B14_u8BB0"><a href="#u5206_u4EAB_u7B14_u8BB0" class="headerlink" title="分享笔记"></a>分享笔记</h2><p>首先分享一下我两天听分享的收获。</p>
<h3 id="u4E00_u4E2A_Swift__u9879_u76EE_u7684_u7F51_u7EDC_u5C42_u53D8_u8FC1_u2014_u2014_u9648_u4E58_u65B9"><a href="#u4E00_u4E2A_Swift__u9879_u76EE_u7684_u7F51_u7EDC_u5C42_u53D8_u8FC1_u2014_u2014_u9648_u4E58_u65B9" class="headerlink" title="一个 Swift 项目的网络层变迁——陈乘方"></a>一个 Swift 项目的网络层变迁——陈乘方</h3><p>陈乘方负责开发 ENJOY 这个 App，ENJOY 是一个比美团和点评更「上档次」的美食推荐和团购应用。而 ENJOY 是一个由纯 Swift 语言开发出来的 App。陈乘方的这次分享中，我感受到了大家 ENJOY 这个项目对于 Swift 新特性的接受和演进过程。</p>
<p>大家刚开始写 Swift 项目的时候，都是把 Objective-C 翻译成 Swift，那个时候，虽然我们用的语言是 Swift，但是我们的思维方式还是 Objective-C 的，所以，陈乘方首先介绍了在项目演进过程中，大家对于 Swift 新特性的引入，从而带来编码方式的变革过程。</p>
<p>他们使用枚举、范型、以及 protocol extension 作为第一个演进版本，使得自己的项目更加 Swift 化。</p>
<p>接着第二个演进版本，他们将 AFNetworking 进行了替换，改成了 Alamofire。比较关键的一点，他们把成功和失败的双回调，合并成 <code>completion</code> 单回调，所以就产生了 <code>APIResult</code> 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum APIResult&#60;T&#62; &#123;&#10;   case Success(T)&#10;   case Failure(NSError, AnyObject?)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这种改进是更加 Swift 化的尝试，因为 <code>APIResult</code> 这种保存网络结果的方式，是一种对数据的封装，可以更加方便地使用 <code>map</code> 和 <code>flatMap</code> 进行链式调用。</p>
<p>最后一个演进版本，他们：</p>
<ul>
<li>用 ObjectMapper 代替了 Mantle</li>
<li>去掉命名前缀</li>
<li>用 Struct 类型的 Model</li>
<li>尽可能减少 optional 的 Model 属性</li>
<li>为 APIResult 增加了 map 和 flatMap 方法</li>
</ul>
<p>整个演进过程中，我能感受到他们对于 Swift 的最佳实践也是一步一步摸索得更加清晰。除了总结性的介绍外，陈乘方在演讲的后半部分，还以一个具体的 API 请求为例，展示代码的整个生成过程，让我更加清晰地理解了他们的应用架构方式。</p>
<p>这个主题分享非常适合那些刚刚迁移到 Swift 语言的新项目，他们可以从中吸取到宝贵的实践经验。</p>
<p>最后恭喜 ENJOY 获得了 3000 万美元的新一轮融资，以及陈乘方本人抽中了今年 WWDC 的门票，ENJOY 公司会报销陈乘方参加 WWDC 的全部费用，真是良心公司，大家投简历去吧，哈哈。</p>
<h3 id="Objective-C__u548C_Swift__u7684_u8DE8_u5E73_u53F0_u5F00_u53D1_u2014_u2014Tinyfool"><a href="#Objective-C__u548C_Swift__u7684_u8DE8_u5E73_u53F0_u5F00_u53D1_u2014_u2014Tinyfool" class="headerlink" title="Objective-C 和 Swift 的跨平台开发——Tinyfool"></a>Objective-C 和 Swift 的跨平台开发——Tinyfool</h3><p>tinyfool 的这个分享我很早以前听过，当时应该是在网上看的他参加博览网的分享，分享地址 <a href="http://boolan.com/lecture/1000001076" target="_blank" rel="external">在这里</a>，当时他分享的主题是《如何把 iOS 代码编译为 Android 应用》。这次分享的题目虽然不一样，但实质内容是一样的。</p>
<p>这其实是一个非常有技术含量的事情，tinyfool 基本上把他们要做的事情讲了，但是并没有深入到细节讲怎么做。这其实是完全能够理解的，因为这些细节讲起来会非常碎，在场的人也很难有谁有这方面的需求做同样的事情。所以基本上，这件事情大家了解他是如何着手计划和实施的，就可以了。</p>
<p>不过这场分享，很多人表达出不满意。我想 tiny 如果抛出两个技术细节，让大家玩味一下会更有意思一些。</p>
<h3 id="u9006_u5411_u5DE5_u7A0B_uFF1A_u4ECE_Objective-C__u5230_Swift_u2014_u2014_u5305_u6DB5_u537F"><a href="#u9006_u5411_u5DE5_u7A0B_uFF1A_u4ECE_Objective-C__u5230_Swift_u2014_u2014_u5305_u6DB5_u537F" class="headerlink" title="逆向工程：从 Objective-C 到 Swift——包涵卿"></a>逆向工程：从 Objective-C 到 Swift——包涵卿</h3><p>这个分享非常对我的味口，因为我一直对 iOS 安全非常关心。</p>
<p>包涵卿在演讲中，介绍了他使用 Hopper Disassembler， IDA Pro， otool, class-dump 逆向分析 Objective-C 和 Swift 的编译后代码。其中涉及的技术细节都非常有意思。</p>
<p>例如 Non Fragile Layout，这种编译方案，使得父类增加成量变量，不会影响子类的二进制代码运行。这样，苹果就可以在新的 iOS 操作系统中，默默地升级 NSObject，UIView 和 UIViewController 这些大家都会继承的父类的成员变量，而不会影响原有的代码运行。这个技术细节感觉国内并没有多少人是真正理解清楚的。</p>
<p>关于这个，我记得王晓磊给我的公众号投稿过一篇名为 <a href="https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=206233994&amp;idx=1&amp;sn=1d3379abb1cec9306d40efc38910434e&amp;scene=1&amp;srcid=0424ZMkiur8yL1FDeGxrzT9X&amp;key=b28b03434249256bd1853e2fbc502b1a9a19b062d66276afd7aa2c9ab2dc68c0e8368c260f4345ffbf461be0b77510bf&amp;ascene=0&amp;uin=NDU1NzA2MTk1&amp;devicetype=iMac+MacBookAir" target="_blank" rel="external">Objective-C 类成员变量深度剖析</a> 的文章，也对这个特性做了详细的分析。</p>
<p>包涵卿还介绍了 Swift-String 的内部实现，通过介绍它的大小是是 24 字节，一步步分析，最后还原出原来是它有一个 _core 的变量，类型是一个 _StringCore 结构。这个结构里面有三个变量：_baseAddress, _countAndFlags, _owner。</p>
<p>包涵卿接着介绍了 Swift-Demangle 的细节，一个 Swift Protocol 的指针大小是 40 字节的逆向分析。</p>
<p>包涵卿介绍了一个超有用的分析命令<code>ima lookup -a &lt;address&gt;</code> ，可以查对应地址可能是什么对象，有这个命令之后，在分析对象组成的时候，就方便很多了。</p>
<p>最后，我了解到 protocol witness，它是一个类似 C++ 的虚方法表的实现，这让我理解了 Swift 对 Protocol 的实现方式。</p>
<h3 id="u62E5_u62B1_Swift_3-0__u4E0E_u672A_u6765_u5C55_u671B_u2014_u2014_u56FE_u62C9_u9F0E"><a href="#u62E5_u62B1_Swift_3-0__u4E0E_u672A_u6765_u5C55_u671B_u2014_u2014_u56FE_u62C9_u9F0E" class="headerlink" title="拥抱 Swift 3.0 与未来展望——图拉鼎"></a>拥抱 Swift 3.0 与未来展望——图拉鼎</h3><p>图拉鼎是奇点和 Manico 的作者，也以 Remote 的方式为 ENJOY 工作过。</p>
<p>图拉鼎的这次分享，首先介绍了 Swift 3.0 的目标：</p>
<ul>
<li>ABI 稳定</li>
<li>跨平台</li>
<li>Package Manager</li>
</ul>
<p>接着，他分享了 Swift 2.2 在语言演进上的变化，包括：selector、keyPath、去 Objective-C 化、标准化命名、参数化命名、废除 IUO 。</p>
<p>这些语言变化对我都很有帮助，特别是标准化命名这一点，方法名加 ed 结尾统一表示返回新的对象，例如：sort 是在原数组排序，sorted 是返回的是新数组。类似的还有 reversed, enumerated 等。这种命名方式设计是非常舒服的，而我之前并没有注意到这一点。</p>
<p>废除 IUO（Implicityly Unwrapped Optional） 这一点对我启发也很大，我们了解到苹果对于语言的演进过程，其实就能理解哪些是好的设计，哪些是不好的设计。</p>
<p>最后，图拉鼎介绍了 Swift 未来的 <a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">演进方向</a>：</p>
<ul>
<li>SE-0025: Scoped Access Level</li>
<li>SE-0038: Package Manager C Language Target Support</li>
<li>SE-0048: Generic type alias</li>
</ul>
<p>对此，我最大的收获是知道了原来可以 <a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">从这里</a> 看苹果对于 Swift 语言未来的规划，相信我以后会常常到这里翻翻，看看苹果是如何做计划的。</p>
<p>图拉鼎还介绍了一个好的学习平台，IBM 的 Swift sandbox: <a href="https://swiftlang.ng.bluemix.net" target="_blank" rel="external">https://swiftlang.ng.bluemix.net</a>，听他说这个平台更新非常及时，可以方便我们实验 Swift 的新特性。</p>
<h3 id="Redux_in_Swift_u2014_u2014_u65B0_u4E00_u4EE3_u7684_iOS__u5E94_u7528_u67B6_u6784_u2014_u2014_u65B9_u5FD7_u521A"><a href="#Redux_in_Swift_u2014_u2014_u65B0_u4E00_u4EE3_u7684_iOS__u5E94_u7528_u67B6_u6784_u2014_u2014_u65B9_u5FD7_u521A" class="headerlink" title="Redux in Swift——新一代的 iOS 应用架构——方志刚"></a>Redux in Swift——新一代的 iOS 应用架构——方志刚</h3><p>方志刚自己在 playground 上做了一个用于演讲的程序，可以播放 PPT + 看代码，而且你知道吗？这是他在第一天演讲的现场撸出来的。真是后生可畏啊！</p>
<p>在这个分享中，方志刚分享了一个小众的、新颖的架构方案：Redux。在介绍完架构后，方志刚直接上代码，带着我们一步一步演示如果用 Redux 开发出一个 TODO 的应用。Redux 优点：好测，简单，可缓存，时光倒退模式这些都让人感觉耳目一新。</p>
<p>但是，我最大的收获倒不是这个框架本身。我相信一个新的框架肯定也会有各种各样的问题，我最大的收获是方志刚在介绍如何把这个框架改造成支持异步的时候，提出了一个 Inverse Of Control 的方案：把 dispatch 反转控制，交给异步的线程来回调。</p>
<p>我不知道未来我是否会有类似的设计架构的需求，如果我以后也有改造现有框架，让它支持异步的方案时，我应该会仔细评估方志刚的这种设计方式，还是挺有意思的。</p>
<h3 id="How_to_parse_float_numbers_-_the_really_hard_way_u2014_u2014_u5085_u82E5_u611A"><a href="#How_to_parse_float_numbers_-_the_really_hard_way_u2014_u2014_u5085_u82E5_u611A" class="headerlink" title="How to parse float numbers - the really hard way——傅若愚"></a>How to parse float numbers - the really hard way——傅若愚</h3><p>每次听傅若愚的分享，我都有智商被碾压的感觉，不过每次回头再仔细学习他的 keynote，我总是会收获很多。其实我的 Swift 烧脑系列文章，有几篇都是在傅若愚的演讲中得到的启发。</p>
<p>这次我听到他一下子定义了大量操作，将 Monad, Application 和 Functor 都实现并且应用在浮点数转换中时，我又知道我得会后再下功夫了。</p>
<p>其实傅若愚也明白这一点，他将所有的讲稿和代码都放到了 <a href="https://github.com/lingoer/SwiftyCharms" target="_blank" rel="external">GitHub</a> 上，大家可以自行学习。</p>
<h3 id="u8BFB_Swift__u6E90_u7801_uFF0C_u7406_u89E3_Monad_u2014_u2014_u5510_u5DE7"><a href="#u8BFB_Swift__u6E90_u7801_uFF0C_u7406_u89E3_Monad_u2014_u2014_u5510_u5DE7" class="headerlink" title="读 Swift 源码，理解 Monad——唐巧"></a>读 Swift 源码，理解 Monad——唐巧</h3><p>我自己的分享，主办方把我放在中午饭之后，让我压力山大，为了让大家不睡着，我带大家一起伸了懒腰，是的，我们大会所有人一起举起双手伸了一个大懒腰。然后，我结合《引爆点》这本书，给大家讲了一个段子：「如何成为 iOS 大 V」。</p>
<p>热场大概花了 10 分钟吧，然后就进入正题讲 Monad。整体语速还是有点稍快，现场没有提词器，我不得不时不时回头，对观众还是挺不友好的。最后演讲完，我让听懂的同学举手，现场大概有一半的同学举手表示懂了。</p>
<p>我自己学习 Monad 大概断断续续花了一年时间，能够在 40 分钟内让现场有一半的同学听懂，我认为值了。这场演讲是我准备得最多次数的演讲，在正式演讲前，我一共讲了五次（一次给 Lancy，一次公司内部分享，一次给 T 线下沙龙，一次给南京软件技术大会，一次给汤圣罡），也是我认为最有挑战的演讲内容吧，整体来说，我给自己打 90 分。</p>
<p>没听懂的同学，对不住了，我已经尽力了。如果你没听懂，建议再学习一下相关的资料：<a href="http://t.cn/Rq4fwJk" target="_blank" rel="external">http://t.cn/Rq4fwJk</a>、<a href="http://t.cn/Rqp3GiW" target="_blank" rel="external">http://t.cn/Rqp3GiW</a>、<a href="http://t.cn/RL5pYwM" target="_blank" rel="external">http://t.cn/RL5pYwM</a></p>
<h2 id="u5176_u5B83"><a href="#u5176_u5B83" class="headerlink" title="其它"></a>其它</h2><p>以上几个分享，是我认真听了，并且觉得非常值得总结的。除此之外，由于我和会场的朋友聊天，错过了「从数学函数角度理解函数式编程——丁峰」，「Swift 语言的设计取舍及跨语言调用——董一凡」，「Asynchronous Programming in Swift，Swift 异步编程——刘冠杉」这三个分享，所以无法总结。</p>
<p>「Swift 设计模式——老镇 (曾伟) 」这个分享我听了，我觉得稍微有一些问题，因为老镇只是把这些设计模式一一介绍，其实这样并不是很有效。作为分享，还不如选一两个点，结合 Swift 的源码来理解，可能更好一些。不过老镇对这次分享准备得非常认真，写了一万多字的讲稿，举了大量武侠的例子，没能深入也蛮可惜的。我感觉还是他经验太少，在内容组织上没有经验，期待他以后会演讲得更好。</p>
<h2 id="u5173_u4E8E_u5BF9_u4F1A_u8BAE_u7684_u8BA8_u8BBA"><a href="#u5173_u4E8E_u5BF9_u4F1A_u8BAE_u7684_u8BA8_u8BBA" class="headerlink" title="关于对会议的讨论"></a>关于对会议的讨论</h2><p>从昨天开始，twitter 和 微博上就有人开始喷这次 SwiftCon 会议，我感觉实在犯不着，因为这次大会有相当多的内容都是精心准备的，如果有一两场不合你的胃口，也不用攻击整场会议。这次 SwiftCon 会议的分享内容，在我以上总结到的分享，都是高质量的，而这些总结，已经覆盖了超过半数的分享议题了。如果你仅仅拿一两场的分享说事，明显犯了以点盖面的错误。如果有谁觉得不对，建议也能够详细指出每一场分享到底水在哪里，让讨论能够更加客观和公正。</p>
<p>另外，微博上发泄或者互喷是相当浪费时间的，有这个时间还是看看技术文章，看看开源代码吧。整个互联网圈子已经够乱了，我还是希望我们 iOS 圈子能够少一些偏激，多一些心平气和的讨论。</p>
<p>最后，我要说，这次会议其实是非赢利的，首先所有讲师都没有报酬的。我从锅巴和板子那里了解到，所有的大会志愿者，也是没有任何劳务报酬的，大会的主持吴柯瑶（其实她是一个 iOS 开发者）也是没有任何报酬的。那为什么要收门票呢？因为分享的场地设备得花钱，外地讲师的路费和住宿费得花钱，所以这些钱需要通过门票来补贴。</p>
<p>如果你能理解这是一个完全民间的团体，组织的一次非赢利性的大会，他们都是本着做事和分享的态度来做这个会议，那么我相信你的心态会更加宽容一些。这是上海有史以来的第一次 Swift 大会，所有人都希望它办成功，这个过程中有什么不如意的，我们改进就行了，没有那么不可原谅的。</p>
<p>愿大家开心～</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>4 月 23 - 24 日，我参加了由 Think 技术社区举办的 <a href="http://www.swiftconchina.com/" target="_blank" rel="external">SwiftCon</a> 大会。这次大会见到了很多新老朋友，也从]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊聊 WWDC 的八卦]]></title>
    <link href="http://blog.devtang.com/2016/04/19/talk-about-wwdc-2016/"/>
    <id>http://blog.devtang.com/2016/04/19/talk-about-wwdc-2016/</id>
    <published>2016-04-19T13:34:22.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/wwdc-2016.jpg">
<p>就在今天，苹果对外公布了 WWDC 2016 即将举办的消息，具体的举办时间是 6 月 13 日 - 17 日。我虽然从来没有去过 WWDC，但是我的个人提高和 WWDC 是密切相关的。</p>
<p>了解我的朋友都知道，我曾经说过，我是一个视觉型的学习者，所以我在刚刚初学 iOS 的时候，选择了斯坦福的视频课程。而我在入门之后，理所当然地选择了看 WWDC 视频作为我的进一步提高的方法。</p>
<p>由于 iOS 开发在快速发展，每年苹果都会给我们带来很多新的知识。而对于这些知识，第一手的资料就是 WWDC 的视频。通常情况下，一个 iOS 开发的新知识首先会在 WWDC 上被苹果公开，然后 3 个月左右，会有国内外的博客介绍这些知识，再过半年左右，会有国外的图书介绍这些知识。所以如果想尽早地了解这些知识，那么只有通过 WWDC 的视频。</p>
<p>在 2014 年以前，这些视频只能在会议之后获得，但是从 2014 年开始，视频开始随着 WWDC 大会的进程，在会议过程中逐步放出，而且重要的视频会带有英文字幕。坚持阅读这些视频不但可以获得最新的 iOS 开发知识，还可以提高英文听力水平。</p>
<p>很多朋友说他英语听力不好，相信我，其实技术的文档和会议中使用的英语语法和单词都相当简单，你缺少的只是一个坚持一段时间的信心。我当时也是受制于国内资料太少，被逼无赖看的，但是「通过英文资料学习」这个能力一旦获得，你就停不下来了。</p>
<p>WWDC 在早年其实是通过抢票的方式来购买的，所以历年 WWDC 门票售卖期间，各个开发者都如临大敌，为了抢得一张近一万人民币的票，想尽各种办法。这种情型在 2013 年达到了巅峰，那个时候，门票开售仅仅 2 分钟，就销售一空（见下图）。</p>
<img src="/images/wwdc-2013.jpg">
<p>这种情况至到 2014 年改成「摇号」的方式，才得到改变。苹果也意识到 WWDC 对开发者的吸引力太大，于是将视频尽量早地放出。</p>
<p>最近，苹果甚至给去年的 WWDC 视频都补上了中文字幕，不过说回来，字幕里面把 「Tim Cook」 翻译成 「提姆厨师」真的不是开玩笑吗？反正看了一眼这个字幕，我心中升起了「比更大还大」(Biger than biger）的无奈，乖乖切回了英文字幕。</p>
<img src="/images/tim-cook.jpg">
<img src="/images/trans-2.jpg">
<p>我没有去过 WWDC，作为一个 iOS 开发者，我一直希望有一天能够去那个圣地学习一番。不过门票和来回的机票和住宿还是让我的钱包压力山大。所以我一直很羡慕那些公司能够报销参加 WWDC 大会的开发者。如果你在这样的公司，欢迎留言告诉我，我会把留言精选出来，让大家围观羡慕的。我也希望猿题库公司成长到一定阶段之后，也能给优秀的员工这样的福利。</p>
<p>今年的 WWDC 能有什么期待呢？除了例行的 iOS 升级大版本之外，我猜估计就是 Swift 3.0 的推出吧，不过也可能苹果留了一手给我们再次带来惊喜。</p>
<p>或许期待本身，就是一件美妙的事情吧，让我们拭目以待。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/wwdc-2016.jpg">
<p>就在今天，苹果对外公布了 WWDC 2016 即将举办的消息，具体的举办时间是 6 月 13 日 - 17 日。我虽然从来没有去过 WWDC，但是我的个人提高和 WWDC 是密切相关的。</p>
<p>了解]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《把时间当做朋友》：一本关于心智的启蒙书]]></title>
    <link href="http://blog.devtang.com/2016/04/19/control-yourself/"/>
    <id>http://blog.devtang.com/2016/04/19/control-yourself/</id>
    <published>2016-04-19T00:28:17.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img11.360buyimg.com/n1/g13/M06/11/0B/rBEhU1JgnwgIAAAAAAJx6QF6lj0AAER-QGFkaAAAnIB428.jpg" alt=""></p>
<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><p>很早以前就看了李笑来老师的<a href="http://item.jd.com/11338691.html" target="_blank" rel="external">《把时间当做朋友》</a>，最近终于整理完成了学习笔记。《把时间当做朋友》是一本老书，最初写于 2008 年，现在依然在售卖中。李笑来也将本书的 <a href="http://zhibimo.com/read/xiaolai/ba-shi-jian-dang-zuo-peng-you/index.html" target="_blank" rel="external">电子版</a> 公开到了网上，免费供读者下载。</p>
<p>本书的作者李笑来以前是新东方的英语老师，在比特币火爆之前，花 100 万买了比特币，我猜他现在应该是财务自由了。李笑来老师在投资比特币之余，展现出了强大的自学能力，自己学习了编程、设计并且作品都还不错，现在，他在学习社群的运营，并且创建了「学习学习再学习」微信公众号以及多个付费社群。</p>
<p>我看完《把时间当做朋友》之后，最大的感受是：这是一本关于心智的启蒙书。</p>
<p>关于心智的定义，我觉得李笑来在书中的定义稍显复杂。在我看来，所谓心智就是一种高层次的大脑控制技巧。这种高层次的大脑控制技巧主要包括两个部分：</p>
<ul>
<li>内在控制：控制自己的情绪。</li>
<li>外在控制：控制自己的行为。</li>
</ul>
<p>接下来，我会按照上面的理解，来将书本的内容重新梳理和介绍。</p>
<h2 id="u771F_u7684_u5B58_u5728_u9AD8_u5C42_u6B21_u7684_u5927_u8111_u63A7_u5236_u5417_uFF1F"><a href="#u771F_u7684_u5B58_u5728_u9AD8_u5C42_u6B21_u7684_u5927_u8111_u63A7_u5236_u5417_uFF1F" class="headerlink" title="真的存在高层次的大脑控制吗？"></a>真的存在高层次的大脑控制吗？</h2><p>理解心智，首先就得理解高层次的大脑控制的存在。那么，真的存在高层次的大脑控制吗？关于这个，作者在书中举了很多例子，我也给大家举几个我自己想到的例子。</p>
<h3 id="u6CE8_u610F_u529B_u8F6C_u79FB"><a href="#u6CE8_u610F_u529B_u8F6C_u79FB" class="headerlink" title="注意力转移"></a>注意力转移</h3><p>你是否有遇到过这种情况？你在看书，遇到一个不认识的单词，想查一下词典，于是你打开手机。刚刚解锁手机，你发现你的微信上有两个红点，于是你点进去，发现是你的死党发过来的搞笑视频。看了视频把你乐坏了，回了死党一段信息后。你发现微信朋友圈上有红点，于是你就点进去看朋友圈。等你把朋友圈刷完，你早已忘记了你本来在看书这件事情。</p>
<p>在上面这件事情中，你到底是被你的大脑控制，还是被各种外界信号刺激所控制呢？</p>
<h3 id="u60C5_u7EEA_u5931_u63A7"><a href="#u60C5_u7EEA_u5931_u63A7" class="headerlink" title="情绪失控"></a>情绪失控</h3><img src="/images/7sin.jpg">
<p>在电影 <a href="http://baike.baidu.com/subview/22021/7627734.htm" target="_blank" rel="external">《七宗罪》</a> 里（上图），有一个情节是连环杀人案凶手最后利用警员米尔斯的愤怒，让他无法控制自己的情绪，最终当着所有人的面，把凶手杀死。当然，最后等待米尔斯的是被押上警车以及职业生涯的断送。</p>
<p>在这件事情中，米尔斯不是被他的大脑控制，而是被愤怒的情绪所控制。《七宗罪》里面涉及的暴食、贪婪、懒惰、愤怒、骄傲、淫欲和嫉妒，这些情绪都会在某些场景下影响我们，使得我们的行为丧失理智。</p>
<h2 id="u5185_u5728_u63A7_u5236_uFF1A_u63A7_u5236_u81EA_u5DF1_u7684_u60C5_u7EEA"><a href="#u5185_u5728_u63A7_u5236_uFF1A_u63A7_u5236_u81EA_u5DF1_u7684_u60C5_u7EEA" class="headerlink" title="内在控制：控制自己的情绪"></a>内在控制：控制自己的情绪</h2><h3 id="u4E2A_u6027_u662F_u7531_u60C5_u7EEA_u548C_u7ECF_u5386_u5851_u9020_u7684"><a href="#u4E2A_u6027_u662F_u7531_u60C5_u7EEA_u548C_u7ECF_u5386_u5851_u9020_u7684" class="headerlink" title="个性是由情绪和经历塑造的"></a>个性是由情绪和经历塑造的</h3><p>情绪是我们生命重要的组成部分，很多时候，我们的性格和做事方式都是情绪在各种经历下的产物。我接触到的对此最好的阐述，就是电影 <a href="http://baike.baidu.com/item/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F" target="_blank" rel="external">《头脑特工队》</a> 了。顺便说一下，该片由皮克斯与迪士尼合作制作，在 2016 年 2 月，获得了第 88 届奥斯卡最佳动画长片奖。</p>
<img src="/images/insideout-movie.jpg">
<p>在电影《头脑特工队》（上图）中，主人公莱利的行为由五种情绪构成，这五种情绪是 “欢乐”、“恐惧”、“厌恶”、“悲伤”、“愤怒”。在这五种情绪相互影响下，莱利在小时候是一个有着外向，活泼，调皮性格的小女孩，但是随着她搬到新家，没有了朋友，她慢慢变得焦虑，厌恶身边的人，以前的性格被重新塑造。最终，她将自己的痛苦述说出来，使自己的压力得到释放，她的个性中的快乐成份融入了眼泪，使得她更加懂得珍惜。</p>
<h3 id="u63A7_u5236_u60C5_u7EEA"><a href="#u63A7_u5236_u60C5_u7EEA" class="headerlink" title="控制情绪"></a>控制情绪</h3><p>我们说控制自己的情绪，并不是指我们需要压抑所有的不好情绪，在《头脑特工队》中，主人公莱利就是因为过度压抑悲伤，使得自己无处释放压力，最终反倒被自己的愤怒情绪所控制。</p>
<p>所以，当我们说控制自己的情绪的时候，我们其实在说，我们应该为了获得长久的好情绪，而控制自己短期的坏情绪。</p>
<p>我老婆是学幼儿教育的，她给我讲过一个故事，幼儿教育学家为了研究小孩的自控能力，会做一个叫做 <a href="http://baike.baidu.com/link?url=8EKV-tjzMsKQFVnSnr1Ar3VWf8iCbKTdvH1AZHJXzWcBPJO38hQZd12cKIbrjgQIgjl-tmqPhfR4Z8oFPjcpXK" target="_blank" rel="external">延迟满足</a> 的实验。这个实验（<a href="https://www.youtube.com/watch?v=Yo4WF3cSd9Q" target="_blank" rel="external">相关视频</a>）是这样的：</p>
<blockquote>
<p>在一个屋子里面，让小孩坐在一个书桌前，然后给小孩一个糖果，告诉他：「我 15 分钟后回来，如果你在我回来之前都不吃这个糖果，等我回来后就再奖励你一个糖果」。</p>
<p>通常情况下，很多小孩都无法抵抗糖果的诱惑而很快将它吃掉。而研究发现，那些坚持到最后的小孩，自控能力更强，在随后的跟踪研究发现，这些小孩能够在学校取得更好的学习成绩。</p>
</blockquote>
<p>最后，研究人员发现，这些小孩都会非常简单的一招：转移注意力。具体来说，他们会在特别想吃糖果的时候，选择做别的事情来让自己大脑暂时不那么关注糖果。比如他们可能会唱歌，在桌子上写字，将头转向窗外。</p>
<p>所以，在这个故事中，小孩为了获得「得到两个糖果的奖励」这种喜悦的情绪，通过转移注意力的方式，暂时压抑了自己短期「想吃这个糖果」的欲望。</p>
<p>我们在生活中，也在不断地重复着这种事情。当我们工资不高的时候，看到一个想买的东西，我们会理性地压抑自己的购物欲望，为的是这个月不至于交不起房租或者饿肚子。当我们在高三时，我们每天都学习得很辛苦，但是我们会控制自己的压力，为的是高考时能够考出更好的成绩。当我们和别人起冲突时，我们会控制自己想打人的冲动，为的是自己不至于在警察局待上几天。</p>
<p>中国有句古训：「忍一时风平浪静，退一步海阔天空」。其实意思就是我们应该为长久的好情绪，控制自己短期的坏情绪。而这种推迟满足感的能力，就是一种高层次的大脑控制技巧。</p>
<h2 id="u63A7_u5236_u60C5_u7EEA_u7684_u6280_u5DE7"><a href="#u63A7_u5236_u60C5_u7EEA_u7684_u6280_u5DE7" class="headerlink" title="控制情绪的技巧"></a>控制情绪的技巧</h2><p>下面是我总结出来的控制情绪的具体技巧。（注：我将这些技巧在《把时间当做朋友》书中的对应章节，以章名 + 小节名的方式附在每个技巧标题后面，例如 3.2 节表示：第 3 章第 2 节。）</p>
<h3 id="u8F6C_u79FB_u6CE8_u610F_u529B_uFF08_u7B2C_2-4__u8282_uFF09"><a href="#u8F6C_u79FB_u6CE8_u610F_u529B_uFF08_u7B2C_2-4__u8282_uFF09" class="headerlink" title="转移注意力（第 2.4 节）"></a>转移注意力（第 2.4 节）</h3><p>刚刚上面小孩抵抗糖果的诱惑的实验其实已经提到了这种技巧，这种技巧的核心在于，对于一些坏情绪或者痛苦的体验，我们不去想它，那么它的影响就会大大降低。小孩通过简单的把头转向窗外想别的事情，就可以让糖果的诱惑力对大脑的影响大大降低。</p>
<p>类似的场景还包括，当你特别不高兴的时候，找一些你平时喜欢做的事情，甚至简单地让自己做一些事情（比如运动）都可以极大的转移掉你对于糟糕情绪的关注。</p>
<h3 id="u63A8_u8FDF_u6EE1_u8DB3_u611F_uFF08_u7B2C_2-5__u8282_uFF09"><a href="#u63A8_u8FDF_u6EE1_u8DB3_u611F_uFF08_u7B2C_2-5__u8282_uFF09" class="headerlink" title="推迟满足感（第 2.5 节）"></a>推迟满足感（第 2.5 节）</h3><p>人总是倾向于立刻获得满足，如果完成一件事情的满足感来自未来的某一个时间，那么这就需要大脑的控制了。推迟满足感与转移注意力的差别在于，推迟满足感明明知道当前的行为让自己有些难受，但是仍然控制大脑做这件事情。</p>
<p>我最近在学习两个新技能，一个是学自由泳，一个是学骑独轮的思维车。这两个技能的获得过程都是痛苦的。我在学自由泳的时候，由于身体还没有对动作产生记忆，所以身体非常不协调，稍微不小心就呛水了。但是我会明白这是学会游泳的必经过程，所以坚持学下去，以便我在未来的某个时间，可以获得「学会自由泳」带来的喜悦和成就感。</p>
<p>学自由泳是一个很容易达到推迟满足感的例子。真实生活中，有着更多更难做到的事情，需要我们控制好情绪。</p>
<p>在《把时间当做朋友》的书中，作者就举了一个很难的事情：背下 GRE 要求的 2 万个单词。因为 2 万个单词实在太多，所以这件事情必须经过一个相当长的时间才能完成，即使一天背 100 个单词，也需要连续 200 天才能完成，而坚持做这件事情 200 天的难度非常大。</p>
<p>虽然所有人都能理解这个道理，但是真正能坚持做下来的人少之又少，后面我会分享坚持的一些技巧。</p>
<h2 id="u5916_u5728_u63A7_u5236_uFF1A_u63A7_u5236_u81EA_u5DF1_u7684_u884C_u4E3A"><a href="#u5916_u5728_u63A7_u5236_uFF1A_u63A7_u5236_u81EA_u5DF1_u7684_u884C_u4E3A" class="headerlink" title="外在控制：控制自己的行为"></a>外在控制：控制自己的行为</h2><p>我们对情绪的控制，最终反映出来的结果就对自己行为的控制。外在的行为控制表现出来有各种实践技巧，在本书中，用了大量篇幅进行了介绍。下面我们来一一看看这些技巧包括哪些。</p>
<h3 id="u7CBE_u786E_u611F_u77E5_u65F6_u95F4_uFF08_u7B2C_2-3__u8282_uFF09"><a href="#u7CBE_u786E_u611F_u77E5_u65F6_u95F4_uFF08_u7B2C_2-3__u8282_uFF09" class="headerlink" title="精确感知时间（第 2.3 节）"></a>精确感知时间（第 2.3 节）</h3><p>控制行为的第一步是感知时间，这也是书名《把时间当做朋友》的由来。书中也提到《奇特的一生》，我对此书也刚好写过<a href="/2016/02/16/make-friend-with-time/">读书笔记</a>。时间是完成所有事情的基础资源，精确感知时间使得我们能够对时间资源的利用率显著提升。</p>
<h3 id="u7528_u7EB8_u7B14_u6765_u8BB0_u5F55_u65F6_u95F4_uFF0C_u4EE5_u53CA_u5177_u4F53_u7684_u6267_u884C_u6280_u5DE7_uFF08_u7B2C_3-2-3-5__u8282_uFF09"><a href="#u7528_u7EB8_u7B14_u6765_u8BB0_u5F55_u65F6_u95F4_uFF0C_u4EE5_u53CA_u5177_u4F53_u7684_u6267_u884C_u6280_u5DE7_uFF08_u7B2C_3-2-3-5__u8282_uFF09" class="headerlink" title="用纸笔来记录时间，以及具体的执行技巧（第 3.2-3.5 节）"></a>用纸笔来记录时间，以及具体的执行技巧（第 3.2-3.5 节）</h3><p>这部分的内容偏执行，详细讲解了如何用纸笔来记录时间，记录执行时间的技巧和总结方法。虽然李笑来老师在书中没有推荐「番茄工作法」，但是我觉得这部分的实践技巧和「番茄工作法」是能够相互配合使用的。关于「番茄工作法」，我也写过一篇<a href="/2016/04/12/tomato-time-management/">读书笔记</a>。</p>
<h3 id="u5408_u7406_u7684_u3001_u9002_u5EA6_u7684_u8BA1_u5212_uFF08_u7B2C_3-6__u8282_uFF09"><a href="#u5408_u7406_u7684_u3001_u9002_u5EA6_u7684_u8BA1_u5212_uFF08_u7B2C_3-6__u8282_uFF09" class="headerlink" title="合理的、适度的计划（第 3.6 节）"></a>合理的、适度的计划（第 3.6 节）</h3><p>避免过度看重计划的重要性，在打算做一些事情时，没有计划或者简单计划后的快速启动，比花费大量时间计划后再做要更好。比如说健身，与其说研究哪种健身运动更合适，倒不如今天开始就动起来。当然，笑来老师也提到，改变的事情需要快做决策，投资的事情需要慢做决策。</p>
<h3 id="u9605_u8BFB_uFF08_u7B2C_4-1__u8282_uFF09"><a href="#u9605_u8BFB_uFF08_u7B2C_4-1__u8282_uFF09" class="headerlink" title="阅读（第 4.1 节）"></a>阅读（第 4.1 节）</h3><p>阅读是持续获得新知识的技巧。不过我们更应该看重图书的阅读，同时应该压抑自己在社交网络（微博、微信朋友圈）上碎片时间的阅读。因为后者知识不但很碎片化，而且也不成系统，另外同时有很多毫无营养价值的鸡汤 / 假新闻存在。</p>
<p>关于阅读，我之前写过《如何阅读一本书》的<a href="/2016/01/17/how-to-read-a-book-summary/">读书笔记</a>，也推荐给大家。</p>
<h3 id="u5B66_u4F1A_u5982_u4F55_u5B66_u4E60_uFF08_u7B2C_4-2-4-4__u8282_uFF09"><a href="#u5B66_u4F1A_u5982_u4F55_u5B66_u4E60_uFF08_u7B2C_4-2-4-4__u8282_uFF09" class="headerlink" title="学会如何学习（第 4.2-4.4 节）"></a>学会如何学习（第 4.2-4.4 节）</h3><p>「学会如何学习」就是要掌握正确的获取新知识的方法。很多人问我 iOS 开发如何入门，如何提高，好象这些问题就应该通过问别人才能获得答案。但是我觉得，一个学习能力强的人，面对一个新领域的知识，他自己就会找到学习新知识的方法和提高技巧。</p>
<p>这其实就是一种自学能力。书中对于自学能力的解读（第 4.3 节）包括：</p>
<ul>
<li>阅读理解能力</li>
<li>检索能力</li>
<li>写作能力</li>
<li>实践能力</li>
<li>保持开放的心态</li>
<li>了解学习的进程</li>
</ul>
<p>在书中，笑来老师还提到的学习技巧包括：警惕自己的经验造成的「思维误区」，当我们面对不同观点时，常常自省一下，可能才有机会调整自己的认识。我们不光需要自省，同时也要不盲目信服权威和老师（第 4.4 节）。</p>
<p>另外，在判断知识正确的时候，掌握「正确的科学方法论」也非常重要。这一点在《如何阅读一本书》中也有涉及。我们在判断一个理论是否正确时，要考虑它的论点，论据以及推导过程。任何论据不对、论据不充分或者推导过程不严谨的观点，我们都应该加以小心。</p>
<p>在这方面，最应该小心的就是成功学鸡汤了(第 5.1 节），成功学鸡汤常常会犯论据不对或者推导过程不严谨的错误。</p>
<p>罗辑思维有一期节目批判中医，其中就指出了中医粉在为中医辩护中的各种逻辑上的错误，感兴趣的朋友可以翻来听听。</p>
<p>另外我最近和朋友讨论，也颠覆了我的一些观点，其中一个观点是：电动车一定是未来吗？我一直觉得是未来，但是我的这个朋友的观点让我发现了，我的论据还是有一些不充分的地方。</p>
<p>书中同时提到了《少有人走的路》，我还没阅读，稍后应该会补上阅读笔记。</p>
<h3 id="u6539_u53D8_u6001_u5EA6_uFF08_u7B2C_4-5__u8282_uFF09"><a href="#u6539_u53D8_u6001_u5EA6_uFF08_u7B2C_4-5__u8282_uFF09" class="headerlink" title="改变态度（第 4.5 节）"></a>改变态度（第 4.5 节）</h3><p>「改变态度」其实改变的是：思考问题的角度，从而让自己更舒服。</p>
<p>比如我本来 iOS 开发做得很成功，但是转而做管理之后，iOS 方面的技能基本上只能在业余时间提高了。对于此，我可以这么想：这么多年辛辛苦苦学习积累的 iOS 技能不能够派上用场上，慢慢还会忘掉，真是郁闷。但是，换一个角度，我还可以这么想：我在 iOS 方面已经很难提高了，但是我在管理方面还是一个菜鸟，人的一生能够同时经历程序员和管理者两个职业角度来学习，最终我如果能够在新的领域成长起来，何尝不是一件精彩的事情！</p>
<p>我们面对失败，面对困难，面对学习的态度，都可以通过换一个角度，找到更加积极的应对方式。如果你实在找不到角度，我给你出一个办法，你想象一下这个场景：你不是出身在中国，而是出生在非洲的一个平民窟里，你吃不饱，无法受到良好的教育，周围医疗环境糟糕，甚至连喝干净的水都是奢望。你再想想你现在的生活，是不是真的有那么糟糕。</p>
<h3 id="u5C0F_u5FC3_u300C_u6210_u529F_u5B66_u300D_uFF08_u7B2C_5__u7AE0_uFF09"><a href="#u5C0F_u5FC3_u300C_u6210_u529F_u5B66_u300D_uFF08_u7B2C_5__u7AE0_uFF09" class="headerlink" title="小心「成功学」（第 5 章）"></a>小心「成功学」（第 5 章）</h3><p>书中提到的技巧包括：</p>
<ul>
<li>拒绝鸡汤</li>
<li>拒绝简单地强调坚持</li>
<li>拒绝不合理的论证</li>
<li>过于强调自己的独一无二</li>
<li>过于强调人脉和圈子</li>
</ul>
<h3 id="u7406_u89E3_u548C_u63D0_u9AD8_u5B66_u4E60_u6548_u7387_uFF08_u7B2C_6-1-6-7__u8282_uFF09"><a href="#u7406_u89E3_u548C_u63D0_u9AD8_u5B66_u4E60_u6548_u7387_uFF08_u7B2C_6-1-6-7__u8282_uFF09" class="headerlink" title="理解和提高学习效率（第 6.1-6.7 节）"></a>理解和提高学习效率（第 6.1-6.7 节）</h3><p>学会：分割任务，坚持执行，保持合理节奏，不迟到。</p>
<h3 id="u4E0D_u8981_u6D6A_u8D39_u65F6_u95F4_u8BC1_u660E_u81EA_u5DF1_uFF08_u7B2C_6-8__u8282_uFF09"><a href="#u4E0D_u8981_u6D6A_u8D39_u65F6_u95F4_u8BC1_u660E_u81EA_u5DF1_uFF08_u7B2C_6-8__u8282_uFF09" class="headerlink" title="不要浪费时间证明自己（第 6.8 节）"></a>不要浪费时间证明自己（第 6.8 节）</h3><p>活在别人的世界里是很悲惨的，因为大多数时候，除了你特别好的朋友和亲人之外，别的人并不关心你是否过得开心。那些看不起你的人，那些批评你的人，只要不是友善的态度，大可不必回应，更不用证明自己。</p>
<p>我还记得，有一个人在我的公众号留言：「你 iOS 技术文章写得还行，但是非技术的东西写得很烂，麻烦以后别写了，浪费我的时间」。我看了之后，默默地把他拉入了黑名单。</p>
<p>你永远不可能让所有人喜欢你，你也永远无法和那些试图伤害你的人解释，总有一些人喜欢看你的笑话，看你出丑，对于这些人，无视他们的存在是最好的生活方式。实际上，他们的存在对于你确实一点价值也没有。</p>
<h3 id="u4E0D_u540E_u6094_uFF0C_u800C_u662F_u603B_u7ED3_uFF08_u7B2C_6-9__u8282_uFF09"><a href="#u4E0D_u540E_u6094_uFF0C_u800C_u662F_u603B_u7ED3_uFF08_u7B2C_6-9__u8282_uFF09" class="headerlink" title="不后悔，而是总结（第 6.9 节）"></a>不后悔，而是总结（第 6.9 节）</h3><p>这也是一种看问题的角度，当我们失败的时候，专注于总结而不是后悔才有可能让我们进步。</p>
<h3 id="u8010_u5FC3_uFF08_u7B2C_7-3__u8282_uFF09"><a href="#u8010_u5FC3_uFF08_u7B2C_7-3__u8282_uFF09" class="headerlink" title="耐心（第 7.3 节）"></a>耐心（第 7.3 节）</h3><p>耐心其实就是「推迟满足感」的外在表现，但是这件事情其实说起容易做起来难。笑来老师在本节中也没有说应该如何获得耐心。面对一个花费时间较长的工作，我知道的产生耐心的技巧包括：</p>
<ul>
<li>拆解任务，为自己的任务设立阶段性目标。以便从心理上感受到目标容易达成，同时可以更好地追踪进度。</li>
<li>每天用「番茄工作法」来安排当前的工作，使得自己能够聚焦当前的工作。</li>
<li>暗示自己工作时产生焦虑是正常的，所以尽力不去想工作量的事情。</li>
<li>当工作快要完成的时候，暗示自己快要成功了。</li>
<li>一开始就做好充分的估计和准备，不要盲目乐观，避免进度延后之后心理的落差。</li>
<li>通过固定时间和固定频率的工作，培养习惯让身体对任务的执行产生条件反射。</li>
<li>利用 10000 小时定理来鼓励自己。</li>
</ul>
<h3 id="u5176_u5B83"><a href="#u5176_u5B83" class="headerlink" title="其它"></a>其它</h3><p>书中还提到的技巧包括：培养记忆力（第 4.6 节）、不自卑（第 6.10 节）、不要简单地把时间都转换成金钱（第 6.11 节）、专注于当前的工作（第 6.12 节）、提前准备（第 7.1-2 节）</p>
<p>另外，我自己也有一些书中没有提到的一些心得。包括：</p>
<ul>
<li>自省：定期回顾与总结。形式可以是以年度总结、月度总结的方式，审视自己的行为是否有值得改进的地方。</li>
<li>培养好奇心。鼓励自己学习和探索新的事物。</li>
<li>培养习惯。刚刚也说到，习惯让自己对一些事情的坚持变得更加容易。</li>
<li>适度坚持。面对一些不确定收益的事情，不应该随意放弃。</li>
</ul>
<h2 id="u5FC3_u667A_u4E0E_u60C5_u5546_u7684_u5173_u7CFB"><a href="#u5FC3_u667A_u4E0E_u60C5_u5546_u7684_u5173_u7CFB" class="headerlink" title="心智与情商的关系"></a>心智与情商的关系</h2><p>如果说心智这个概念听起来如果比较新的话，那么 <a href="http://wapbaike.baidu.com/subview/305/15912412.htm" target="_blank" rel="external">情商</a> 就是一个历史悠久的概念了。我好奇地翻了一下情商的定义，包括五个部分：自我意识、控制情绪、自我激励、认知他人情绪和处理相互关系。</p>
<p>看完这个定义，我突然觉得，其实心智就是一部分的情商，包括：自我意识、控制情绪、自我激励。这部分主要是偏向于自我的控制。而情商的剩下部分：认知他人情绪和处理相互关系，主要偏向于社会交往能力。</p>
<p>所以说，看起来李笑来老师似乎搞了一个新概念，但是其实是把以前的情商理论，抽取出了一部分偏自我控制的部分，进行了归纳和总结。</p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>李笑来老师的<a href="http://item.jd.com/11338691.html" target="_blank" rel="external">《把时间当做朋友》</a>是一本关于心智的启蒙书，对于我们控制情绪和行为都具有不错的实践指导意义，本书的 <a href="http://zhibimo.com/read/xiaolai/ba-shi-jian-dang-zuo-peng-you/index.html" target="_blank" rel="external">电子版</a> 可以免费下载，推荐各位朋友阅读，早日开始自己的心智。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img11.360buyimg.com/n1/g13/M06/11/0B/rBEhU1JgnwgIAAAAAAJx6QF6lj0AAER-QGFkaAAAnIB428.jpg" alt=""></p>
<h2 id="u5F15_u8A00]]>
    </summary>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[「番茄工作法」- 简单的时间管理方法]]></title>
    <link href="http://blog.devtang.com/2016/04/12/tomato-time-management/"/>
    <id>http://blog.devtang.com/2016/04/12/tomato-time-management/</id>
    <published>2016-04-12T13:20:55.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>「番茄工作法」是一个简单、轻松的提高工作效率的办法。一直在小众圈子里面流行，但是没有被普及。写下此文，希望番茄工作法能够被更多人了解和接受。</p>
<p>「番茄工作法」这个名字的来历是这样：番茄是指番茄外形的定时器（下图）的意思。专门的定时器常常用于烹饪的计时，时间到了之后闹钟就会响起来。</p>
<img src="/images/tomato.jpg">
<p>番茄工作法的思想是：将日常工作分割成若干个计时器单元，每个单元大概 30 分钟左右。在番茄单元之间，进行合理地休息放松。在番茄单元进行时，保证自己精力全部集中在工作的事情上，不接受被打断和分神。</p>
<p>这种思想看起来非常简单，但是我在实际工作中，发现它确实能够非常高效地帮助我集中注意力。程序员在编程时通常需要较长的时间来整理思路和编码，「番茄工作法」使得我们更加容易集中注意力，从而将时间利用率提升。</p>
<h2 id="u4F7F_u7528_u65B9_u6CD5"><a href="#u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="使用方法"></a>使用方法</h2><p>「番茄工作法」的使用主流程如下：</p>
<ol>
<li>每天早上到公司后，首先拿一张纸（或者是本子中的一页），用笔写下当天应该要做完的事情。</li>
<li>将这些事情按优先级排序，然后进行大致的估算后，拆分成若干个「番茄钟」，每个「番茄钟」是 25 分钟。</li>
<li>设置「番茄钟」倒计时，同时开始第一件事情的第一个「番茄钟」。</li>
<li>在「番茄钟」倒计时期间，集中精力只做事先安排好的事情。</li>
<li>在「番茄钟」结束后，休息 5 分钟，走动放松一下，然后继续下一个「番茄钟」，直到完成自己的任务。</li>
<li>每完成 4 个「番茄钟」（即 2 小时），休息 15-30 分钟。</li>
</ol>
<p>一些意外情况：</p>
<ol>
<li>如果你被电话、交谈打断，这个「番茄钟」即宣告失败，可以简单休息 5 分钟，然后重启「番茄钟」。</li>
<li>如果你突然想到一件重要的事情，除非当前非做不可，否则应该在纸上将此事快速记录下来，然后继续你的「番茄钟」。</li>
</ol>
<h2 id="u4E00_u4E9B_u6280_u5DE7_u548C_u5FC3_u5F97"><a href="#u4E00_u4E9B_u6280_u5DE7_u548C_u5FC3_u5F97" class="headerlink" title="一些技巧和心得"></a>一些技巧和心得</h2><ol>
<li><p>在进行「番茄钟」时，我们应该尽量想办法避开一些容易分神的信息源。例如：将手机的消息推送静音，关闭 QQ 和微信。相信我，你大多数时候并不需要立即响应聊天软件中的信息。使用「番茄钟」后，你的消息回复时间最坏情况下也就是晚 25 分钟。如果真的有人有急事，他会直接到你的办公桌来找你，或者直接给你打电话的。对于程序员来说，也可以带个笔记本，找一个相对安静的地方编程。</p>
</li>
<li><p>随着你的注意力控制越来越容易，你可以适当延长「番茄钟」的时间。就我的经验，延长到 45 - 50 分钟是完全没有问题的。其实你如果明白了「番茄钟」的原理，你甚至可以在心中假想一个「番茄钟」，然后让自己快速进入精力集中状态。</p>
</li>
<li><p>一天下来，回顾自己当天的「番茄钟」完成情况，看看主要的问题在于自己的精力无法集中，还是老是被别人打断。针对具体的问题可以做一些调整的尝试。比如，如果是精力无法集中，则看看是否是干扰源过多，尽量减少干扰。如果是老被打断，则可以和同事商量一些工作方式，比如让同事尽量用邮件和 QQ 找你，而不是当面打扰你。</p>
</li>
<li><p>「番茄工作法」是一种简单轻松的工作法，我们应该尽量简单地使用它来辅助自己的工作，而不应该让任务计划和管理本身成为一件麻烦。所以，建议不要使用复杂的 App 来记录你的番茄钟完成情况，一张 A4 纸和一支笔就够了。另外，记录档案和思考如何提高不应该超过一个番茄时间，我们不应该让「番茄工作法」成为一种负担。</p>
</li>
<li><p>我们应该认识到，工作被打断是在所难免的，总会有一些临时的沟通工作无法被计划，并且是有价值的。所以，「番茄钟」失败后，不应该有过多的情绪，尽快重启一个「番茄钟」，你的工作应该很快就会进入状态。</p>
</li>
<li><p>各位做 iOS 开发的同学有多少买了 Apple Watch？我发现 Apple Watch 就是最好的「番茄钟」，我将 Apple Watch 的计时器放到了表盘上，抬手就可以开始一个番茄时间，非常方便（下图）。时间到了就会震动，也不会影响到旁边的同事。</p>
</li>
</ol>
<img src="/images/apple-watch-timer.jpg">
<h2 id="u63A8_u8350_u8BFB_u7269"><a href="#u63A8_u8350_u8BFB_u7269" class="headerlink" title="推荐读物"></a>推荐读物</h2><p><img src="http://img14.360buyimg.com/n1/g12/M00/00/03/rBEQYFMn13UIAAAAAAY-iISkO8AAAC2dgKel0kABj6g946.jpg" alt=""></p>
<ul>
<li><a href="http://item.jd.com/10406129.html" target="_blank" rel="external">《番茄工作法图解：简单易行的时间管理方法》</a>：一本 10 几块钱的、薄薄的充满图案的小册子，让你轻松理解番茄工作法。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>「番茄工作法」是一个简单、轻松的提高工作效率的办法。一直在小众圈子里面流行，但是没有被普及。写下此文，希]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[应该如何管理密码 - 我的密码管理心得]]></title>
    <link href="http://blog.devtang.com/2016/04/07/my-password-management-way/"/>
    <id>http://blog.devtang.com/2016/04/07/my-password-management-way/</id>
    <published>2016-04-07T15:59:37.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/password.jpg">
<h2 id="u6211_u7684_u5BC6_u7801_u5347_u7EA7_u4E4B_u8DEF"><a href="#u6211_u7684_u5BC6_u7801_u5347_u7EA7_u4E4B_u8DEF" class="headerlink" title="我的密码升级之路"></a>我的密码升级之路</h2><p>我最早接触密码这个概念是在高中的时候，那个时候我第一次申请 QQ 号，需要想一个超过 6 位数的密码。于是，我填上了我爸爸的手机号。老实说，手机号作为密码还不算最糟糕的。比起生日来说，手机号更长一些，可能的组合也更多一些。</p>
<p>我很快就了解了撞库这种攻击方式，你的密码如果在任何平台都用一样的话，如果有一个平台不靠谱，明文存储了密码（在那个年代其实并不少见，CSDN 都曾经存的是明文），那么黑客就可以用这个账号密码尝试登录其它平台。</p>
<p>于是，我把自己的密码分成了几套，简单的一套用于注册一些不太重要的服务，复杂的一套用于一些比较重要的服务，支付相关的还有一套。</p>
<p>对于每一套密码，我在密码后面加上了平台的名字。比如 QQ 的密码就是基础密码后面加 qq，网易邮箱的密码就是基础密码后面加 mail。</p>
<p>用了一段时间之后，我又增加了一些变化，我希望我尾部增加的与平台相关的名字不那么明显，于是，我把平台的首字母简单的取其字典序的下一个字母，然后插入到一个中间的位置。比如 qq 的密码，就是去 q 的下一个字母 r，然后把 r 插入到密码中间位置。因为我的基础密码本来就是一段随机的数字字母（真是随机的，只不过我背下来了），所以要看出规律可能需要爆出两个库才行。</p>
<p>但是，这么管理密码还是很累。而且，现在不断出现的安全事故让我觉得爆出两个网站被拖库也不算什么让人意外的事情。</p>
<h2 id="1password"><a href="#1password" class="headerlink" title="1password"></a>1password</h2><p>终于，我尝试购买了 1password，开始用 1password 来管理密码。1password 常常有 5 折的优惠活动，今年春节趁他家 APP 优惠，我开始了我的密码迁移之旅。</p>
<p>1password 完全采用随机的方式来生成每一个网站的密码，通常推荐的是 12 位的字母数字组合。我花了好几天，才把所有自己在用的账号密码做了更新。</p>
<p>1password 支持各种方式（iCloud 或 Dropbox）在云端同步你的密码。这样你也不用担心换了电脑找不到密码了。对于云端数据安全，1password 使用的是加密的方式来保存。即使黑客获得了你们密码文件，也需要一个解密的密码来解开它。而这个密码，就是你需要牢牢记住的那最后一个密码。</p>
<p>使用 1password 之后，每次在 chrome 中需要输入密码时，直接使用 1password 的插件进行自动的填充即可。习惯 Safari 的朋友，1password 也有 safari 的插件。值得一提的是，1password 还支持在 iOS 系统的 Safari 中填充密码，如下所示：</p>
<img src="/images/safari-1p.jpg">
<p>除去浏览器后，主要需要输入密码的地方就是 Mac 的原生应用和手机 APP 了。对于原生应用和手机 APP，1password 都支持把密码用复制的方式，粘贴到应用的密码输入界面。对了，买了 Mac 版的 1password，手机版的 1password 高级功能也自动解锁了。</p>
<p>1password 唯一搞不定的是那些不允许粘贴密码的应用，比如支付宝。对于这些应用，我另外有一套密码独立管理，没有放在 1password 管理中。</p>
<p>有了 1password 之后，一些软件的 License 也可以集中管理了，这还是一件挺爽的事情。1password 可以自动识别出软件的图标，如下所示。</p>
<img src="/images/1p-license-list.jpg">
<p>反思过来，密码确实是一个非常反人类的事情，因为人们天然怕麻烦，所以大多数人都只有一套密码，并且密码规则非常弱。</p>
<p>现在我们也慢慢看到越来越多的应用开始抛弃密码，用手机随机短信验证码来登录。还有一次公司，尝试用指纹（比如 iPhone)、声音 (比如微信的声音锁）、头像视频（比如借贷宝的认证）等来作为安全认证的替代品，都是不错的兼顾用户体验和安全的尝试。</p>
<h2 id="u5BC6_u7801_u88AB_u76D7"><a href="#u5BC6_u7801_u88AB_u76D7" class="headerlink" title="密码被盗"></a>密码被盗</h2><p>悲剧的是，就在我刚刚改完各种密码之后，我的百度云账号被盗，而且我通过正常渠道申诉失败。后来发现原因是我百度云账号绑定的网易邮箱被盗了，而那个邮箱我很久没有使用，都忘记了，所以也没有用 1password 改过密码。盗号者盗完我的网易邮箱后，从里面看到了我的注册百度云的确认邮件，于是申请了百度云找回密码，从而重置了我的百度云密码。重置之后，我的绑定邮箱被解绑，于是我就没有方法找回百度云密码了。</p>
<p>最终多亏在百度的朋友帮忙和担保，我才得以用非正常的渠道申诉成功。看到家里的所有照片失而复得，我第一次感觉到安全问题离自己这么近。</p>
<p>最后推荐 Mac 的各位朋友都使用 1password 来管理密码，并且对于一些非常重要的账号，用独立的非 1password 密码来管理。</p>
<p>安全问题，真的就在我们身边，大家还是小心一点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/password.jpg">
<h2 id="u6211_u7684_u5BC6_u7801_u5347_u7EA7_u4E4B_u8DEF"><a href="#u6211_u7684_u5BC6_u7801_u5347_u7EA7_u4E4]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（五）- Monad]]></title>
    <link href="http://blog.devtang.com/2016/04/05/swift-gym-5-monad/"/>
    <id>http://blog.devtang.com/2016/04/05/swift-gym-5-monad/</id>
    <published>2016-04-05T14:56:07.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第五节，练习前请做好准备运动，保持头脑清醒。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/65dc76a3gw1f0sz15ou0fj20cx07d0u3.jpg" alt=""></p>
<h2 id="Why_Monad_3F"><a href="#Why_Monad_3F" class="headerlink" title="Why Monad?"></a>Why Monad?</h2><p>因为 Monad 的定义有点复杂，我们先说为什么要理解和学习它。业界对于 Monad 的用处有着各种争论，特别是学术派喜欢用 Haskell 来解释它，因为「Haskell 是纯函数式编程语言」。但这往往让问题更加复杂了—-我为了理解一个概念，还需要先学习一门新语言。</p>
<p>所以我希望就 Swift 这门语言，分享一下理解 Monad 有什么用。实际上，即使在 Wikipedia 上，<a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="external">Monad</a>) 也没有被强行用 Haskell 来解释。所以我相信基于 Swift 语言，还是可以把 Monad 的概念讲清楚。</p>
<p>在我看来，之所以有 Monad 这种结构，实际上是为了链式调用服务的。什么是链式调用呢？我们来看看下面一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tq: Int? = 1&#10;tq.flatMap &#123;&#10;    $0 * 100&#10;&#125;.flatMap &#123;&#10;    &#34;image&#34; + String($0)&#10;&#125;.flatMap &#123;&#10;    UIImage(named: $0)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>所以，如果一句话解释 Monad，那就是：Monad 是一种设计模式，使得业务逻辑可以用链式调用的方式来书写。</p>
<p>在某些情况下，链式调用的方式组织代码会特别有效，比如当你的调用步骤是异步的时候，很容易写成多层嵌套的 <code>dispatch_async</code>，使用 Monad 可以使得多层嵌套被展开成链式调用，逻辑更加清楚。除了异步调用之外，编程中涉及输入输出、异常处理、并发处理等情况，使用 Monad 也可以使得代码逻辑更清晰。</p>
<h2 id="u57FA_u7840_u77E5_u8BC6"><a href="#u57FA_u7840_u77E5_u8BC6" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="u5C01_u88C5_u8FC7_u7684_u503C_uFF08wrapped_value_29"><a href="#u5C01_u88C5_u8FC7_u7684_u503C_uFF08wrapped_value_29" class="headerlink" title="封装过的值（wrapped value)"></a>封装过的值（wrapped value)</h3><p>这个中文词是我自己想出来的，有一些人把它叫做「上下文中的值」（value with a context），有一些人把它叫做「容器中的值」（value in a container)，意思是一样的。</p>
<p>什么叫做「封装过的值」呢？即把裸露的数据放到另一个结构中。例如：</p>
<ul>
<li>数组就是对值的一种封装，因为数组把裸露的元素放到了一个线性表结构中。</li>
<li>Optional 也是对值的一种封装，因为 Optional 把值和空放到了一个枚举（enum）类型中。</li>
</ul>
<p>如果你愿意，你也可以自己封装一些值，比如把网络请求的结果和网络异常封装在一起，做成一个 enum (如下所示）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Result&#60;T&#62; &#123;&#10;    case Success(T)&#10;    case Failure(ErrorType)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>判断一个数据类型是不是「封装过的值」，有一个简单的办法：就是看这个数据类型能不能「被打开」，拿出里面的裸露的元素。</p>
<ul>
<li>数组可以被打开，拿出里面的数组元素。</li>
<li>Optional 可以被打开，拿出里面的值或者 .None。</li>
<li>一个 Int 类型的值，无法「被打开」，所以它不是「封装过的值」。</li>
</ul>
<p>一个字符串是不是「封装过的值」呢？前提是你如何定义它「被打开」，如果你把它的打开定义成获得字符串里面的每个字符，那么字符串也可以是一个「封装过的值」。</p>
<!--
那要这么说，其实 Int 也可以被看作一个「封装过的值」，如果你把它的打开，定义成获得这个 Int 的每个 bit 位的值就行。
-->
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>在上一篇烧脑文章中我们也提到过，要识别一个类型是不是 Monad，主要就是看它是否实现了 <code>flatMap</code> 方法。但是，如果你像下面这么实现 <code>flatMap</code>，那也不能叫 Monad：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TangQiao &#123;&#10;    func flatMap() &#123;&#10;        print(&#34;Hello world&#34;)&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Monad 对于 <code>flatMap</code> 函数有着严格的定义，在 Haskell 语言中，这个函数名叫 bind，但是定义是一样的，这个函数应该：</p>
<ul>
<li>作用在一个「封装过的值」M 上。</li>
<li>它的参数应该是另一个闭包 F，这个闭包 F：接受一个解包后的值，返回一个「封装过的值」。</li>
</ul>
<p>具体在执行的时候，<code>flatMap</code> 会对 M 进行解包得到 C，然后调用闭包 F，传入解包后的 C，获得新的「封装过的值」。</p>
<p>我们来看看 Optional 的 <code>flatMap</code> 实现，验证一下刚刚说的逻辑。源码地址是：<a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func flatMap&#60;U&#62;(@noescape f: (Wrapped) throws -&#62; U?) &#10;        rethrows -&#62; U? &#123;&#10;    switch self &#123;&#10;    case .Some(let y):&#10;        return try f(y)&#10;    case .None:&#10;        return .None&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Optional 的 <code>flatMap</code>：</p>
<ul>
<li>作用在一个「封装过的值」：<code>self</code> 身上。</li>
<li>接受一个闭包参数 <code>f</code>，这个 <code>f</code> 的定义是：接受解包后的值，返回一个「封装过的值」: <code>U?</code> 。</li>
<li>在执行时，<code>flatMap</code> 先对 <code>self</code> 进行解包，代码是 <code>case .Some(let y)</code>。</li>
<li>如果解包成功，则调用函数 f，得到一个新的「封装过的值」，代码是 <code>try f(y)</code>。</li>
<li>如果解包出来是 .None，则返回 .None。</li>
</ul>
<h2 id="u8BBE_u8BA1_u80CC_u540E_u7684_u8FFD_u95EE"><a href="#u8BBE_u8BA1_u80CC_u540E_u7684_u8FFD_u95EE" class="headerlink" title="设计背后的追问"></a>设计背后的追问</h2><p><code>flatMap</code> 接受的这个闭包参数，直观看起来很奇怪。接受的是解包的值，返回的又是封装过的值，一点都没有对称的美！</p>
<p>为什么要这么设计？不这么设计就不能完成链式调用吗？我想了半天，答案就是一个字：懒！</p>
<p>为什么这么说呢？因为「封装过的值」大多数时候不能直接计算，所以要计算的时候都要先解包，如果我们为了追求「对称的美」，使得函数接受的参数和返回的值都是「封装过的值」，当然是可以的。不过如果这么设计的话，你就会写大量雷同的解包代码。程序设计的时候追求「Don’t Repeat Yourself」原则，这么做当然是不被接受的。</p>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>刚刚我们说，在设计上为了复用代码，我们必须保证闭包的参数是解包后的值。</p>
<p>那么，同样的道理，每次返回之前都封包一下，不一样很重复么？我们返回的值能不能是解包后的原始值，然后自动封装它？</p>
<p>答案是可以的，但是这就不是 Monad 了，这成了 Functor 了。我们上一讲提到过，Functor 中实现的 <code>map</code> 方法，就是一个接受解包后的值，返回结果仍然是解包后的值。为了保证链式调用，map 会自动把结果再封包一次。</p>
<p>我们再来回顾一下 <code>map</code> 的源码吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func map&#60;U&#62;(@noescape f: (Wrapped) throws -&#62; U) &#10;        rethrows -&#62; U? &#123;&#10;    switch self &#123;&#10;    case .Some(let y):&#10;        return .Some(try f(y))&#10;    case .None:&#10;        return .None&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在该源码中，函数 <code>f</code> 在被执行完后，结果会被封包成 Optional 类型，相关代码是：<code>.Some(try f(y))</code>。</p>
<p>所以，Optional 的 <code>map</code> 和 <code>flatMap</code> 差别真的非常非常小，就看你的闭包想不想自己返回封装后的值了。</p>
<p>在具体业务中，我们也有一些实际的需求，需要我们自己控制返回封装后的值。比如 Optional 在操作的时候，如果要返回 .None，则需要使用 <code>flatMap</code>，错误的使用了 <code>map</code> 函数的话，就会带来多重嵌套 nil 的问题。比如下面这个代码，变量 <code>b</code> 因为是一个两层嵌套的 nil，所以 <code>if let</code> 失效了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tq: Int? = 1&#10;let b = tq.map &#123; (a: Int) -&#62; Int? in&#10;    if a % 2 == 0 &#123;&#10;        return a&#10;    &#125; else &#123;&#10;        return nil&#10;    &#125;&#10;&#125;&#10;if let _ = b &#123;&#10;    print(&#34;not nil&#34;)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>归根结底，你在编程时使用 Monad 还是 Functor，取决于你的具体业务需求：</p>
<ul>
<li>如果你在处理「封装过的值」时，不会（或不需要）返回异常数据，则可以使用 Functor，让数据的封装过程交给 <code>map</code> 函数来处理。</li>
<li>如果你在处理「封装过的值」时，需要在闭包函数里返回类似 nil（或 ErrorType）一类的数据，则可以使用 Monad，自己返回新的「封装过的值」。</li>
</ul>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>Swift 语言中并没有原生的 Applicative，但是 Applicative 和 Functor、Monad 算是三个形影不离的三兄弟，另外它们三者的差异都很小，所以干脆一并介绍了。</p>
<p>刚刚我们讨论 Functor 与 Monad 时，都是说把值放在一个容器里面。但是我们别忘了，Swift 是函数式语言，函数是一等公民，所以，函数本身也是一种值，它也可以放到一个容器里面，而我们要讨论的 Applicative，就是一种关于「封装过的函数」的规则。</p>
<p>Applicative 的定义是：使用「封装过的函数」处理「封装过的值」。这个「封装过的函数」解包之后的参数类型和 Functor 的要求是一样的。</p>
<p>按照这个定义，我们可以自己改造数组和 Optional，使它们成为 Applicative，以下代码就是一个示例，来自 <a href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" target="_blank" rel="external">这里</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Optional &#123;&#10;    func apply&#60;U&#62;(f: (T -&#62; U)?) -&#62; U? &#123;&#10;        switch f &#123;&#10;        case .Some(let someF): return self.map(someF)&#10;        case .None: return .None&#10;        &#125;&#10;    &#125;&#10;&#125;&#10;&#10;extension Array &#123;&#10;    func apply&#60;U&#62;(fs: [Element -&#62; U]) -&#62; [U] &#123;&#10;        var result = [U]()&#10;        for f in fs &#123;&#10;            for element in self.map(f) &#123;&#10;                result.append(element)&#10;            &#125;&#10;        &#125;&#10;        return result&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们为数组和 Optional 增加了一个 <code>apply</code> 方法，而这个方法符合 Applicative 的定义。如果和 <code>map</code> 方法对比，它们的唯一差别就是闭包函数是封装过后的了：</p>
<ul>
<li>对于 Optional 来说，<code>apply</code> 的闭包函数也变成 Optinoal 的了。</li>
<li>对于数组来说，<code>apply</code> 的闭包函数也是一个数组（我们之前介绍过，数组也是对数据的一种封装）。</li>
</ul>
<h2 id="Monad__u7684_u5E94_u7528"><a href="#Monad__u7684_u5E94_u7528" class="headerlink" title="Monad 的应用"></a>Monad 的应用</h2><p>理论都离不开应用，否则就是「然并卵」了，讲完了概念，我们来看看除了 Swift 语言中的数组和 Optional，业界还有哪些对于 Monad 的应用。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><a href="http://promisekit.org/" target="_blank" rel="external">PromiseKit</a> 是一个同时支持 Objective-C 和 Swift 的异步库。它用 Promise 来表示一个未来将要执行的操作，使用它可以简化我们的异步操作。因为篇幅有限，本文并不打算展开详细介绍 Promise，我们就看一个实际的使用示例吧。</p>
<p>假设我们有一个业务场景，需要用户先登录，然后登录成功后发API获取数据，获取数据后更新 UITableView 的内容，整个过程如果有错误，显示相应的错误信息。</p>
<p>传统情况下，我们需要把每个操作都封装起来，然后我们可以选择：</p>
<ul>
<li>方法一：用多层嵌套的 <code>dispatch_async</code> 把逻辑写到一起，但是这样嵌套代码，可读性和可维护性很差。</li>
<li>方法二：每一步有一个 delegate 回调函数，把业务逻辑分散到各个回调函数中。但是这样不但逻辑分散了，而且关键的函数调用的依赖关系被我们隐藏起来了。</li>
</ul>
<p>另外，以上两种方法处理错误逻辑都可能会有多处，虽然我们可以把报错也封装成一个函数，但是在多个地方调用也不太舒服。使用 PromiseKit 之后，刚刚提到的业务场景可以用如下的示意代码来完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login().then &#123;&#10;    return API.fetchKittens()&#10;&#125;.then &#123; fetchedKittens in&#10;    self.kittens = fetchedKittens&#10;    self.tableView.reloadData()&#10;&#125;.catch &#123; error in&#10;    UIAlertView(&#8230;).show()&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果你的逻辑涉及并发，PromiseKit 也可以很好地处理，例如，你希望发两个网络请求，当两个网络请求都结束时，做相应的处理。那就可以让 PromiseKit 的 <code>when</code> 方法与 <code>then</code> 结合工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let search1 = MKLocalSearch(request: rq1).promise()&#10;let search2 = MKLocalSearch(request: rq2).promise()&#10;&#10;when(search1, search2).then &#123; response1, response2 in&#10;    //&#8230;&#10;&#125;.catch &#123; error in&#10;    // called if either search fails&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在 PromiseKit 的设计中，<code>then</code> 方法接受的闭包的类型和 <code>flatMap</code> 是一样的，所以它本质上就是 <code>flatMap</code>。Promise 其实就是一种 Monad。</p>
<h3 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h3><p>比起 PromiseKit，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a> 的名气要大得多。最新的 ReactiveCocoa 4.0 同时支持 Objective-C 和 Swift，我们在源码中发现了 RAC 的 <code>SignalType</code> 就是一个 Monad：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension SignalType &#123;&#10;&#10;    public func flatMap&#60;U&#62;(strategy: FlattenStrategy, transform: Value -&#62; SignalProducer&#60;U, Error&#62;)&#10;        -&#62; Signal&#60;U, Error&#62; &#123;&#10;        return map(transform).flatten(strategy)&#10;    &#125;&#10;&#10;    public func flatMap&#60;U&#62;(strategy: FlattenStrategy, transform: Value -&#62; Signal&#60;U, Error&#62;) &#10;        -&#62; Signal&#60;U, Error&#62; &#123;&#10;        return map(transform).flatten(strategy)&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>我们再次总结一下 Monad、Functor、Applicative：</p>
<ul>
<li>Monad：对一种封装过的值，使用 <code>flatMap</code> 函数。</li>
<li>Functor：对一种封装过的值，使用 <code>map</code> 函数。</li>
<li>Applicative：对一种封装过的值，使用 <code>apply</code> 函数。</li>
</ul>
<p>我们再对比一下<code>flatMap</code>、<code>map</code> 和 <code>apply</code>：</p>
<ul>
<li><code>flatMap</code>：对自己解包，然后应用到一个闭包上，这个闭包：接受一个「未封装的值」，返回一个「封装后的值」。</li>
<li><code>map</code>：对自己解包，然后应用到一个闭包上，这个闭包：接受一个「未封装的值」，返回一个「未封装的值」。</li>
<li><code>apply</code>：对自己解包，然后对闭包解包，解包后的闭包：接受一个「未封装的值」，返回一个「未封装的值」。</li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" target="_blank" rel="external">Swift Functors, Applicatives, and Monads in Pictures</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/" target="_blank" rel="external">Functor、Applicative 和 Monad</a></li>
<li><a href="https://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/" target="_blank" rel="external">Promises are the monad of asynchronous programming</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何实现自己没实现过的需求之文本动画]]></title>
    <link href="http://blog.devtang.com/2016/03/20/text-animation-guide/"/>
    <id>http://blog.devtang.com/2016/03/20/text-animation-guide/</id>
    <published>2016-03-20T13:34:23.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>吕伟（<a href="http://weibo.com/u/1660258615" target="_blank" rel="external">@我在罪恶坑的日子</a>）iOS 开发者，这些年在上海工作。专业：扯淡，兼职：开发。<br>感谢投稿，<a href="http://www.ismash.cn/post/ru-he-shi-xian-zi-ji-mei-shi-xian-guo-de-xu-qiu-zhi-wen-ben-dong-hua-pian" target="_blank" rel="external">原文链接</a>。</p>
</blockquote>
<p>大家好，我是非知名程序员，想跟大家说一段传统相声节目，额，对不起，说错了。想跟大家分享一点关于文本和动画的东西。这不是一篇纯血统，高、精、尖的技术文章，但依然希望有人能像喜欢混血美女一样喜欢。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>记得以前看到过一个很赞的文字效果的动画，类似于这样：</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13845905/1e55a5d0-ec7e-11e5-9631-68aaf6b07ba1.gif" alt="textanimation"></p>
<p>当时被惊艳到了，最近偶然间又再次见到，依然还是那么喜欢。假设我们现在需要实现这样的需求。一般碰到需求我们都会去 GitHub 上看看，俗称找轮子（GitHub 基本上只有你想不到的，就没有它没有的）。大多数情况下，没有问题。或者说有点小问题：轮子太多，无从下嘴。</p>
<h2 id="u9009_u62E9"><a href="#u9009_u62E9" class="headerlink" title="选择"></a>选择</h2><blockquote>
<p>选轮子就像选姑娘，你不知道后面等着你的是什么 —–罪恶坑小程如是说</p>
</blockquote>
<p>程序员江湖，每位大侠的武功和套路不尽一样，少林，武当，昆仑各门各派，百花争艳。实现轮子的思路自然也不一样。有的轮子高深晦涩难懂，功能强大，有的清晰明了，功能简单。不过有一点相同是，选错了就会被坑，只是坑大坑小问题。选轮子自然需要无比谨慎，既要匹配需求同时也要能在掉坑里的时候填上（废话，出 bug 了，你不填，谁填），要能 hold 住。然而填坑哪能那么简单呢，首先轮子实现思路，代码的结构，运行时序你要搞清楚吧，提供了哪些功能，没提供哪些功能，你要了解吧。基本上一个复杂点的轮子，研究下来就要好些时间了。这还不包括你开会，沟通，解 bug，喝茶，倒水，上厕所，抽烟，骂娘，吐槽产品需求的时间。所以，妹子们，不要问我们今天加不加班，要问今天能不能在你睡前下班。（项目快上线了，小程不加班谁加班。嗯哼。）</p>
<h2 id="u521B_u9020"><a href="#u521B_u9020" class="headerlink" title="创造"></a>创造</h2><blockquote>
<p>如果能用代码扮演上帝话，苍老师的量产不是问题，就看产品经理定的需求是拟物还是扁平。—-罪恶坑小程如是说</p>
</blockquote>
<p>既然选轮子的时间成本也不低，那有时候我们可以自己造一个轮子。其实写一个的好处也多，有成就感，写好了可以吹牛逼，写坏了填坑速度快。但问题是，以前没写过怎么办？没把握怎么办？比如我们现在需要实现上面的文字效果，但是又不知道怎么写，怎么办？</p>
<p>没关系，上帝创造世间也分了七步走，跟着这位带头大哥后面学，总不会错的。</p>
<h2 id="u5F00_u59CB"><a href="#u5F00_u59CB" class="headerlink" title="开始"></a>开始</h2><blockquote>
<p>罗马不是一天建成的，毛片不是一次性拍完的 —-罪恶坑小程如是说 </p>
</blockquote>
<p>咦，好像扯得有点多了。对不起，现在开始正式拍（苍老师准备下，小程也准备下，Action）：</p>
<h4 id="1-__u5206_u89E3_u4EFB_u52A1"><a href="#1-__u5206_u89E3_u4EFB_u52A1" class="headerlink" title="1.  分解任务"></a>1. <strong> 分解任务 </strong></h4><p>通过简单观察我们可以马上知道，上面那个动画效果是通过对每个字符做动画完成的。而在 iOS 里，文本显示控件最常见和常用的是 UILabel。而 iOS 的 Explicit Animation 有 Properties Animation 和 keyframe Animation 两种。</p>
<p>但是 UILabel 控件没有提供对其 Text 中每个字符的控制的功能，我们需要改造下。既然要对每个字符做动画，那少不了需要<code>frame</code>，<code>bounds</code>，<code>position</code>，<code>transform</code>，这些属性。<br>这样看来我们需要两个武器：一个做排版功能的 framework，不用说，肯定是 <a href="http://objccn.io/issue-5-1/" target="_blank" rel="external">TextKit</a>。而另一个是能显示单个字符也拥有<code>frame</code>，<code>bounds</code>，<code>position</code>，<code>transform</code>等属性的类，很自然，我们想到<code>CATextLayer</code>。</p>
<h4 id="2-__u5148_u89E3_u51B3_u6587_u672C_u5E03_u5C40"><a href="#2-__u5148_u89E3_u51B3_u6587_u672C_u5E03_u5C40" class="headerlink" title="2.  先解决文本布局"></a>2. <strong> 先解决文本布局 </strong></h4><p>TextKit 里主要是三个类 <code>NSTextStorage</code>，<code>NSLayoutManager</code>，<code>NSContainer</code>。它们一起帮组我们解决文字布局，排版的工作。</p>
<ul>
<li><p><strong>NSTextStorage</strong>：<code>NSMutableAttributedString</code>的子类，持有文字内容，当字符发生改变时，通知<code>NSLayoutManager</code>对象</p>
</li>
<li><p><strong>NSLayoutManager</strong>: 我们的男主角，从<code>NSTextStorage</code>里获取文字内容后，转换成对应的 glyph，根据<code>NSTextContainer</code>的 visible Region 显示 glyph。</p>
</li>
<li><p><strong>NSContainer</strong>: 确定一个 region 来放置 text。这个 region 被<code>NSLayoutManager</code>用来决定哪里可以 break lines</p>
</li>
</ul>
<p>不过可惜 UILabel 没有这三个类作为自己的属性对象，我们需要自己解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TextAnimationLabel: UILabel,NSLayoutManagerDelegate &#123;   &#10;     let textStorage:NSTextStorage = NSTextStorage(string: &#34;&#34;)&#10;     let textLayoutManager:NSLayoutManager = NSLayoutManager()&#10;     let textContainer:NSTextContainer = NSTextContainer()&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>除此以外我们还需要两个 Array 用来保存文本变换前的旧字符和变换后的新字符:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var oldCharacterTextLayers:[CATextLayer] = [] &#10;var newCharacterTextLayers:[CATextLayer] = []</span><br></pre></td></tr></table></figure>
<p>因为我们需要用我们自己的 textStorage 对象，所以我们需要覆盖 text 和 attributedText 等属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override var text:String!&#123;&#10;    get &#123;&#10;        return super.text&#10;    &#125;&#10;    set &#123;&#10;        super.text = text&#10;        let attributedText = NSMutableAttributedString(string: newValue)&#10;        let textRange = NSMakeRange(0,newValue.characters.count)&#10;        attributedText.setAttributes([NSForegroundColorAttributeName:self.textColor], range: textRange)&#10;        attributedText.setAttributes([NSFontAttributeName:self.font], range: textRange)&#10;        let paragraphyStyle = NSMutableParagraphStyle()&#10;        paragraphyStyle.alignment = self.textAlignment&#10;        attributedText.addAttributes([NSParagraphStyleAttributeName:paragraphyStyle], range: textRange)&#10;        self.attributedText = attributedText&#10;        &#125;&#10;        &#10; &#125;&#10;    &#10;override var attributedText:NSAttributedString!&#123;&#10;    get &#123;&#10;        return self.textStorage as NSAttributedString&#10;    &#125;&#10;    set&#123;&#10;        cleanOutOldCharacterTextLayers()&#10;        oldCharacterTextLayers = Array(newCharacterTextLayers)&#10;        textStorage.setAttributedString(newValue)&#10;        self.startAnimation &#123; () -&#62; () in&#10;        &#125;&#10;            self.endAnimation(nil)&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当 TextStorage 的文本内容改变时，会触发一个通知 send textLayoutManager 以便重新布局排版。显然我们可以在排版布局完成后来为每个字符创建设置一个 CATextLayer，并设置相应的 frame 以便正确的显示内容。我们可以有个函数来完成计算。并且 layout finish 完成时调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Mark:NSLayoutMangerDelegate&#10;func layoutManager(layoutManager: NSLayoutManager, didCompleteLayoutForTextContainer textContainer: NSTextContainer?, atEnd layoutFinishedFlag: Bool) &#123;&#10;        calculateTextLayers()&#10;        print(&#34;\(textStorage.string)&#34;)&#10;&#125;&#10;    &#10;    &#10;//MARK:CalculateTextLayer&#10;func calculateTextLayers()&#10;&#123;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们的主要想法，是找到 text 里每个 character 以及对应的 glyph rect. 然后用 character 和 glyph rect 创建 CATextLayer</p>
<p>首先我们要有一个空数组用来存放新的 CATextLayer。并且获取 textStorage 的 attributedText。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func calculateTextLayers()&#10;&#123;&#10;    newCharacterTextLayers.removeAll(keepCapacity:false)&#10;    let attributedText = textStorage.string&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们要通过 LayoutManger 找到 TextContainer 的 used Rect，这样方便我们可以让文本垂直居中，就像普通的 Label 那样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func calculateTextLayers()&#10;&#123;&#10;    newCharacterTextLayers.removeAll(keepCapacity:false)&#10;    let attributedText = textStorage.string&#10;    let wordRange = NSMakeRange(0, attributedText.characters.count)&#10;    let attributedString = self.internalAttributedText();&#10;    let layoutRect = textLayoutManager.usedRectForTextContainer(textContainer)&#10;    var index = wordRange.location&#10;    let totalLength = NSMaxRange(wordRange)&#10;    while index &#60; totalLength &#123;&#10;         ...&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们开始迭代处理文本里的每个字符，创建一个 glyphRange 并且用这个 glyphRange 找到对应的 character，然后我们将 glyph index 丢给 LayoutManager 得到 textContainer，再用 container 和 glyphRange 取得 glyphRect(这里需要注意下 kerning 的问题)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let glyphRange = NSMakeRange(index, 1)&#10;let characterRange = textLayoutManager.characterRangeForGlyphRange(glyphRange, actualGlyphRange: nil)&#10;let textContainer = textLayoutManager.textContainerForGlyphAtIndex(index, effectiveRange: nil)&#10;var glyphRect = textLayoutManager.boundingRectForGlyphRange(glyphRange, inTextContainer: textContainer!)</span><br></pre></td></tr></table></figure>
<p>最终我们还需要注意的就是 glyph 的 kerning，如果 <code>kerningRange.location == index</code>，我们需要将前一个 textLayer 取出来调整其 Rect 的宽度至新的 glyphRect 的最右边，保证 glyph 不会被裁切掉（可以对比下面两张图片）</p>
<p><img width="122" src="https://cloud.githubusercontent.com/assets/3759810/13854816/4a6b5258-eca8-11e5-9870-15ed2d4f0d70.png"></p>
<p><img width="122" src="https://cloud.githubusercontent.com/assets/3759810/13854821/4c5b947e-eca8-11e5-811e-e9abb161345f.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let kerningRange = textLayoutManager.rangeOfNominallySpacedGlyphsContainingIndex(index)&#10;if kerningRange.location == index &#38;&#38; kerningRange.length &#62; 1 &#123;&#10;    if newCharacterTextLayers.count &#62; 0 &#123;&#10;        // &#22914;&#26524;&#21069;&#19968;&#20010; textlayer &#30340; frame.size.width &#19981;&#21464;&#22823;&#30340;&#35805;&#65292;&#10;        // &#24403;&#21069;&#30340; textLayer &#20250;&#36974;&#25377;&#20303;&#23383;&#20307;&#30340;&#19968;&#37096;&#20998;&#65292;&#27604;&#22914; &#8220;Yes&#8221; &#30340; Y &#21491;&#19978;&#35282;&#20250;&#34987;&#20999;&#25481;&#19968;&#37096;&#20998;&#10;        let previousLayer = newCharacterTextLayers[newCharacterTextLayers.endIndex - 1]&#10;        var frame = previousLayer.frame&#10;        frame.size.width += CGRectGetMaxX(glyphRect) - CGRectGetMaxX(frame)&#10;        previousLayer.frame = frame&#10;     &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里关于 kerning 和 glyph 要多说一点。先来说下 glyph，简单来说 glyph 是表示一个 character 的具体样式 , 但他们却不是一一对应的关系，比如一个字母 “A” 可以有不同的写法来表示例如：</p>
<p><img width="417" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878224/e142bef8-ed4a-11e5-9c84-798cb5939f36.png"></p>
<p>除此以外，还有这种情况：</p>
<p><img width="243" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878392/fab15e02-ed4b-11e5-9d38-2dc00ed45b0b.png"></p>
<p>上面是的 “ff” 虽然是两个 character，但是 glyph 却是一个。<br>不过不用担心，强大 LayoutManager 提供了两个方法帮助我们通过一个找到对应另外那个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func characterIndexForGlyphAtIndex(_ glyphIndex: Int) -&#62; Int&#10;func glyphIndexForCharacterAtIndex(_ charIndex: Int) -&#62; Int</span><br></pre></td></tr></table></figure>
<p>现在我们说下 kerning。通常，在水平排布的文本中，glyph 都是一个挨着一个放置的，但是在某些时候为了让文本的可读性更好，看上去更加优雅美观，一个字形和另外一个字形之间可能会稍微的错位下，比如下面这种情况：</p>
<p><img width="601" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878767/7631a33c-ed4e-11e5-9d03-46d89d8af9c8.png"><br>这也是上面为什么”Y“会出现显示不全的原因了。</p>
<p>接下来就比较简单了，创建 Textlayer, 设置垂直居中，添加到数组当中，<code>index += characterRange.length</code>，开始下次循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glyphRect.origin.y += (self.bounds.size.height/2)-(layoutRect.size.height/2)&#10;let textLayer = CATextLayer(frame: glyphRect, string: attributedString.attributedSubstringFromRange(characterRange));&#10;layer.addSublayer(textLayer);&#10;newCharacterTextLayers.append(textLayer);&#10;index += characterRange.length</span><br></pre></td></tr></table></figure>
<h4 id="3-__u52A8_u753B_u5B9E_u73B0"><a href="#3-__u52A8_u753B_u5B9E_u73B0" class="headerlink" title="3.  动画实现"></a>3. <strong> 动画实现 </strong></h4><p>上面我们解决了字符排版的问题，接下来动画的实现就相对的容易了，仔细观察那个动画，很容易得出主要是对 <code>opacity</code> 和 <code>transform</code> 两个属性做属性动画，<code>opacity</code> 让每个字体逐渐显示和逐渐消失，而 <code>transform</code>则做了两种变形，一种是往下移动，另外一种是旋转。用 <code>CABasicAnimation</code> 可以解决单个属性动画，而 <code>CAAnimationGroup</code> 则帮我们解决多个动画叠加的复合效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func groupAnimationWithLayerChanges(old olderLayer:CALayer, new newLayer:CALayer) &#10;     -&#62; CAAnimationGroup? &#123;&#10;&#10;    var animationGroup:CAAnimationGroup?&#10;    var animations:[CABasicAnimation] = [CABasicAnimation]()&#10;&#10;    if !CATransform3DEqualToTransform(olderLayer.transform,&#10;    newLayer.transform) &#123;&#10;         let basicAnimation = CABasicAnimation(keyPath: &#34;transform&#34;)&#10;         basicAnimation.fromValue = NSValue(CATransform3D: olderLayer.transform)&#10;         basicAnimation.toValue = NSValue(CATransform3D: newLayer.transform)&#10;         animations.append(basicAnimation)&#10;         &#125;&#10;&#10;    if olderLayer.opacity != newLayer.opacity &#123;&#10;       let basicAnimation = CABasicAnimation(keyPath: &#34;opacity&#34;)&#10;       basicAnimation.fromValue = olderLayer.opacity&#10;       basicAnimation.toValue = newLayer.opacity&#10;       animations.append(basicAnimation)&#10;       &#125;&#10;&#10;    if animations.count &#62; 0 &#123;&#10;       animationGroup = CAAnimationGroup()&#10;       animationGroup!.animations = animations&#10;   &#125;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一个问题，就是隐式动画的问题，Core Animation 基于一个假说，就是屏幕上的任何东西都可以 (或者可能) 做动画，我们平时在写代码时应该有这种印象就是你只是 layer 设置了一个值，没有添加动画，但是你会看到一个平滑过渡的显示效果而不是非常突兀的变化。这就是隐式动画。当我们改变一个属性时，Core Animation 帮我们做了一个动画，动画时间取决于当前 NSTransaction 的设置，而动画类型取决于图层行为。</p>
<p>这里有个有趣的东西，多说一点，就是当我们对 UIView 关联的图层做动画而不是一个单独的图层做动画，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func changeColor()&#10;&#123;&#10;    CATransaction.begin();&#10;    CATransaction.setAnimationDuration(1.0)&#10;    CGFloat red = CGFloat(arc4random() / (CGFloat)INT_MAX);&#10;    CGFloat green = CGFloat(arc4random() / (CGFloat)INT_MAX);&#10;    CGFloat blue = CGFloat(arc4random() / (CGFloat)INT_MAX);&#10;    self.layerView.layer.backgroundColor = UIColor.(colorWithRed:red green:green blue:blue alpha:1.0).CGColor;&#10;    CATransaction.commit();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>图层的颜色瞬间切换到新的值，而不是之前的平滑过渡，隐式动画似乎给关闭了。<br>我们知道 UIView 和 CALayer 最重要的关系就是 UIView 是 CALayer 的 delegate，<br>当我们改变 CALayer 的属性时，它会调用 <code>func actionForKey(_ event: String) -&gt; CAAction?</code> </p>
<p>这个方法，接下来发生的事情在官方文档里都有写，实际上是如下几步:</p>
<ul>
<li><p><em>If the layer has a delegate that implements the actionForLayer:forKey: method, the layer calls that method. The delegate must do one of the following:</em></p>
<ol>
<li><p>Return the action object for the given key.</p>
</li>
<li><p>Return the NSNull object if it does not handle the action.</p>
</li>
</ol>
</li>
<li><p><em>The layer looks in the layer’s actions dictionary for a matching key/action pair.</em></p>
</li>
<li><em>The layer looks in the style dictionary for an actions dictionary for a matching key/action pair.</em></li>
<li><em>The layer calls the defaultActionForKey: class method to look for any class-defined actions.</em></li>
</ul>
<p>UIView 作为它关联图层的 Delegate，实现了 <code>actionForLayer(_ layer: CALayer, forKey event: String) -&gt; CAAction?</code> ，当不在一个动画块中，UIView 返回 nil，而在动画块中则返回一个非空值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#34;OutSide:\(self.view.actionForLayer(self.view.layer, forKey: &#34;backgroundColor&#34;))&#34;)&#10;UIView.beginAnimations(nil, context: nil)&#10;print(&#34;InSide:\(self.view.actionForLayer(self.view.layer,&#10;forKey: &#34;backgroundColor&#34;))&#34;)&#10;UIView.commitAnimations()</span><br></pre></td></tr></table></figure>
<p>显示结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OutSide:Optional(&#60;null&#62;)&#10;InSide:Optional(&#60;CABasicAnimation: 0x7f7f93ff81b0&#62;)</span><br></pre></td></tr></table></figure>
<p>当然返回 nil 并不是禁用隐式动画的唯一方法，下面这样也行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CATransaction.setDisableActions(true)</span><br></pre></td></tr></table></figure>
<p>那为什么说这个问题呢？因为我们在对每个字符做动画的时候需要先将隐式动画关闭，否者将会做两次动画，比如下面这样:</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13857496/2443d70a-ecb5-11e5-8661-a499e9c8719d.gif" alt="closeimplicitanimation"></p>
<p>那么，我们先生成一份 oldlayer, 然后改变相应的属性，生产新的 newLayer。然后创建相应的动画组，添加显式动画。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let olderLayer = animationObjc.animatableLayerCopy(layer)&#10;CATransaction.begin()&#10;CATransaction.setDisableActions(true)&#10;newLayer = effectAnimationClosure(layer: layer)&#10;CATransaction.commit()&#10;var animationGroup:CAAnimationGroup?&#10;animationGroup = groupAnimationWithLayerChanges(old: olderLayer, new: newLayer!)&#10;layer.addAnimation(textAniamtionGroup, forKey: textAnimationGroupKey)</span><br></pre></td></tr></table></figure>
<h2 id="u6536_u5DE5"><a href="#u6536_u5DE5" class="headerlink" title="收工"></a>收工</h2><p>好了，当上面所有的工作完成之后，就是我们最开始看到的那个效果，代码已经上传 GitHub，你可以从 <a href="https://github.com/morpheus1984/TextKitAndAnimationEffect.git" target="_blank" rel="external">这里</a> 下载。其实这个 demo 里实现的 label 还有很大优化的空间。比如支持多种类型的动画效果，动画效果可配置等等。这是我接下来打算做的事情。<br>本人才疏学浅，错漏难免，欢迎大家批评指正。如果你发现 bug，可以提个 pull request。如果你有更好地思路也请告诉我，让我进步，我请你喝咖啡 ：）。</p>
<p>这是我的微信号（未完结，请往下看）：</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13864468/9fdcae9c-ecdc-11e5-9c49-278b327d1ba7.png" alt="wechat"></p>
<h2 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h2><p>不知不觉工作许多年了，这几年萝莉变成了姑娘，姑娘变成了孩子妈。大家从 QQ 空间杀到朋友圈。从晒女朋友，到晒结婚照继而到晒娃。这几年鸣人同志都不负众望当上了火影 (丫也不请吃饭)。大家都在发生变化。</p>
<p>学会开始写点东西分享可能是我想要的一个变化。</p>
<p>本来作为非知名程序员，平时都是自己上 GitHub 玩，自认为比起一干牛人既没本领可以提振民心士气，又没有独门绝技可以分享。直到我收到了一封来自组织的信。</p>
<p>最近我加入了一个公会，里面云集了各类高手，轻功，内力，暗器，大家各有所长，时不时分享下自己的看家本领。还是那句老话，不看不知道，一看吓一跳。世界还是外面的大，姑娘还是城里的靓。在群里，大家都很积极活跃，学习氛围异常的好。其实自打做起程序员起，这么多年来，虽然生性慵懒，但是自学却未敢放下，毕竟逆水行舟，不进则退。不可否认的是一个人的学习是很苦闷无聊的，但一群人陪着你一起苦闷无聊也是很欣慰的。</p>
<p>最后我想引用那封邮件里面的话来表达下我对公会的看法:</p>
<blockquote>
<p>这个社群的意义证明了，在互联网时代，依然有这么多人愿意为知识的积累和个人的成长付费，知识本身的价值得到重新的认知，人们以一种去中心化的方式连接起来，P2P 的创作和分享，可能会让知识和技能的积累、传播达到了一种新的高度、深度和广度</p>
</blockquote>
<p>我想一贯懒散的我为何突然想写这么个 blog 可能也是因为这个，毕竟知识的受益者永远是那些积极参与学习并持续思考的人。</p>
<p>额，最后想说的是，是的，那段引用的文字你没看错，这是个需要付费的群，免费时代的付费群，它叫 <a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=402078207&amp;idx=1&amp;sn=c0b437784c7fc789e06767eedf5cdf87&amp;scene=18#wechat_redirect" target="_blank" rel="external">攻城狮之路</a>。</p>
<p>知识是很昂贵的，我一直这么认为。另外，其实这是篇硬广。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>吕伟（<a href="http://weibo.com/u/1660258615" target="_blank" rel="external">@我在罪恶坑的日子</a>）iOS 开发者，这些年在上海工作。专业：扯淡，兼职：开发。<br>感谢投]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="投稿" scheme="http://blog.devtang.com/tags/%E6%8A%95%E7%A8%BF/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
</feed>
