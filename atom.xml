<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[唐巧的技术博客]]></title>
  <subtitle><![CDATA[记录下自己学习的点滴]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2016-06-19T12:32:05.000Z</updated>
  <id>http://blog.devtang.com/</id>
  
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[为什么提交 AppStore 总有事故发生]]></title>
    <link href="http://blog.devtang.com/2016/06/19/appstore-accident/"/>
    <id>http://blog.devtang.com/2016/06/19/appstore-accident/</id>
    <published>2016-06-19T12:23:24.000Z</published>
    <updated>2016-06-19T12:32:05.000Z</updated>
    <content type="html"><![CDATA[<p>6 月 18 日上午，百度云 iOS 版出现了线上事故，他们在提交 AppStore 审核的时候，把名字给弄错了。用户更新 App 之后，看到的 App 名字是 netdisk_iPhone，如下图所示。此后，百度在当天紧急提交了一个加急版本，修复了该问题。</p>
<img src="/images/baidu-bug-1.jpg">
<p>百度云在 AppStore 总榜中排名 50 名左右，这次事故虽然不太影响用户使用，但是确实会给用户感觉到一些困扰。比如因为它的名字实际上不存在，所以当它想获取 PUSH 消息权限时，弹出来的对话框是如下图这样。用户很可能会觉得奇怪，从而点击 “不允许”。</p>
<img src="/images/baidu-bug-2.jpg">
<p>在大厂里面，不止百度犯过错误，大约在一年前，新浪微博的客户端不小心把调试选项给加包到了正式功能中。于是大家都乐坏了，各种给自己加 VIP 效果，当然，服务器端的验证逻辑还是存在的，所以倒也并没有产生非常大的事故。下图是当时新浪微博事故 App 的截图。</p>
<img src="/images/sina-bug.jpg">
<p>也不能光说别人，其实我们公司前段时间也出现了一个线上事故。猿辅导 App 不小心把测试版给提交到 AppStore 上了，但是由于测试服务器地址不是对外网公开的，于是更新了的同学就无法正常使用 App 了。这个事故大概影响了我们将近一天时间，线上服务完全连不上，算是比较严重的了。</p>
<p>我见过的最最严重的事故，大概是两年前，某个上市公司出的金融类应用，在打包的时候，不小心把源代码打进了 IPA 里面。这个行为恰好被喜欢解 IPA 随意翻翻的 BeeFramework 的老郭看到了，于是大家一起围观了一下它的代码。好在大家都是圈内人，没什么恶意，所以也没有公开此事。不然，用这个代码随意做一些社交机器人或者抓取机器人还是挺容易的。</p>
<p>好了，关键来了。如何防止这类事故发生呢？我觉得做到以下几点应该就可以了：</p>
<ol>
<li>不需要到线上的调试代码，需要用 DEBUG 宏在代码里面明确禁掉。</li>
<li>将整个工程的配置，用 shared scheme 的方式，放在版本管理之下，所有的配置改动，都需要进行 review。</li>
<li>使用自动打包的脚本，不依赖人工进行打包操作。</li>
<li>在正式上线前，用苹果的 TestFlight 进行测试。TestFlight 的测试包可以做到和线上的包完全一致，所以像以上提到的所有问题，都可以在这一个环节发现。</li>
</ol>
<p>百度云的这次事故，很可能的原因是被开发误删除了配置中的 App Name，如果采用上面的步骤，那么在第二步和第四步中，将会发现这个问题。</p>
<p>大家有什么更好的办法吗？欢迎回复讨论。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>6 月 18 日上午，百度云 iOS 版出现了线上事故，他们在提交 AppStore 审核的时候，把名字给弄错了。用户更新 App 之后，看到的 App 名字是 netdisk_iPhone，如下图所示。此后，百度在当天紧急提交了一个加急版本，修复了该问题。</p>
<im]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WWDC 2016 随想]]></title>
    <link href="http://blog.devtang.com/2016/06/14/wwdc-2016-notes/"/>
    <id>http://blog.devtang.com/2016/06/14/wwdc-2016-notes/</id>
    <published>2016-06-14T14:32:50.000Z</published>
    <updated>2016-06-19T12:32:09.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/wwdc-2016.jpg">
<p>今天凌晨 1 点钟，熬夜看了今年的 WWDC，一些随想分享给大家。</p>
<h2 id="u82B1_u7D6E"><a href="#u82B1_u7D6E" class="headerlink" title="花絮"></a>花絮</h2><p>我为了半夜起来看 WWDC，特意提前 10 点钟就睡觉了。我睡觉前特意带上 Apple watch，并且设置好震动闹钟，免得到时候闹钟吵到家人。结果这傻 watch 在我睡着后先是提醒我看每周运动摘要，然后过半小时又震动提醒我已经静止太久应该活动一下，你妹啊！</p>
<p>不准笑！说你呢！！</p>
<h2 id="u65F6_u5149"><a href="#u65F6_u5149" class="headerlink" title="时光"></a>时光</h2><p>因为刚刚说的原因，结果我到 12 点都还没有睡着，我在迷迷糊糊中躺到了快一点钟，watch 震动了，于是我翻身走到客厅，打开电脑，连上直播地址。对了，还有一些朋友不知道直播地址，大家可以记一下，每年直播地址都是固定的：<wwdc.apple.com> 。</wwdc.apple.com></p>
<p>我还记得我刚毕业那阵子，也是熬夜看 WWDC，那个时候我还和老婆租的房子住，并且和校友一起合租的一个两居室。想想也就过去几年，现在自己有了更大的房子住，而整个移动互联网也成就了大量的百亿市值的公司。Tim Cook 在直播中提到，AppStore 是 8 年前出现的，再次感叹到移动互联网真的是好年轻啊。</p>
<h2 id="u5185_u5BB9"><a href="#u5185_u5BB9" class="headerlink" title="内容"></a>内容</h2><p>这次的 WWDC keynote 主要分成 4 个部分，其实就是四个平台：watchOS, tvOS，macOS（原来叫 OS X）, iOS。整个分享中规中矩，分别给大家介绍一下我觉得值得关注的改进吧。</p>
<h3 id="watchOS"><a href="#watchOS" class="headerlink" title="watchOS"></a>watchOS</h3><p>watchOS 推出了 watchOS 3，据说启动速度更快了，但是不知道耗电是不是也是更多了。关于这个，后续有一个 session 主题分享<a href="https://developer.apple.com/videos/play/wwdc2016/227/" target="_blank" rel="external">《Architecting for Performance on watchOS 3》</a>，感兴趣的朋友可以关注。</p>
<p>增加了 scribbles 功能，其实就是一种手写输入，手写居然还支持中文，我当时就在想：你倒是写一个复杂一点的字试试看呢？我对此功能不太看好。</p>
<p>别的改进都很小，比如增加了滑动更换主题，快速报警，现场还花大力气介绍一款叫 breathe 的应用，而这个应用就是指导你深呼吸的。不知道大家喜不喜欢，反正我是不会用的。</p>
<h3 id="tvOS"><a href="#tvOS" class="headerlink" title="tvOS"></a>tvOS</h3><p>这部分直接跳过吧，原因你懂的。</p>
<h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>OS X 更名为了 macOS，可以支持通过 apple watch 解锁电脑了。哦耶，我的手表终于不再只是用来看时间了 ! </p>
<p>剪切版支持从手机上复制，在电脑上粘贴，这个还是挺有用的，我平常都是用 QQ 或微信的文件传输助手做类似的事情。</p>
<p>optimize storage 功能可以把老文件自动存在云端，据说可以节省大概 100G 的空间。不过我猜想，iCloud 的免费空间应该不够用吧？是不是得花钱买些容量才行。</p>
<p>apple pay 可以在 PC 的浏览器上直接支付，点击支付时，需要在手机上确认授权。整个体验类似于拿微信或支付宝扫二维码付款。</p>
<p>siri 可以在 mac 上使用了，并且 siri 的结果可以 pin 在一个列表中，并可以拖动到别的地方。我有一阵子很喜欢用 iPhone 上的 siri，不过还是不太稳定。mac 上一般办公室是不太方便用 siri 的，家里的话要是没有培养出习惯，估计也不太会使用。所以这个功能到底实用性有多大还不确定。</p>
<p>增加了一个名为 picture in picture 的功能，其实就是看视频的时候可以固定住视频。</p>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p>介绍了 10 个特性，我选一些有意思的介绍吧。</p>
<p>Siri 可以和微信整合，这个很赞，你可以直接用 siri 控制发信息给微信中的好友。</p>
<p>系统的 Map 整合了大量的应用，比如可以在上面看大众点评的评价，可以直接叫滴滴打车。如果做得好，Map 很可能成为一个重要的打车入口，想到这儿就能明白为什么苹果投了滴滴 10 亿美金了。不过就苹果系统 Map 的那个糟糕体验，我不确定我是否能够接受它。反正我已经喜欢上了高德地图里面的郭德纲和林志玲的声音，离线的地图和导航也很适合中国这种按流量计费的移动网络环境。相比而言，系统自带的 Map 有些不接地气。</p>
<p>homekit 与智能家居的整合，整体的效果非常酷，但整个还需要依赖生态产业的配合。当前来看，国内的小米在这方面做得比苹果还是要快一些。</p>
<p>电话功能终于支持恶意电话提醒了，现场提到用的是腾讯的解决方案。嗯，360 估计是没有翻身的可能了。另外，phone  extension 似乎可以做更多的事情。</p>
<p>iMessage 可以发更多的内容，tap to replace to emoji 功能的交互设计还是挺有意思的，省却了选择 emoji 的时间。不过现场演示出现了 Bug，还是挺尴尬的。另外，大家都已经习惯了微信，而且 iMessage 只能和 iPhone 用户发，我觉得这些功能做得再有意思，也没有多大用。大家的直觉还是用微信来社交。</p>
<h3 id="u4E2D_u56FD_u5143_u7D20"><a href="#u4E2D_u56FD_u5143_u7D20" class="headerlink" title="中国元素"></a>中国元素</h3><p>这次 WWDC 中多次提到了中国，以及中国的互联网产品，包括微信，大众点评，滴滴。中国为苹果的赢收增长做出了巨大的贡献，我们也能看到苹果越来越重视中国区的需求了。比如恶意来电提醒，就是一个特别针对中国区用户的设计。</p>
<h3 id="Developer"><a href="#Developer" class="headerlink" title="Developer"></a>Developer</h3><p>这次 Tim Cook 专门介绍了针对开发者做的 iPad 版的 Swift Playground，其实这哪是一个 Playground 啊，这就是一个学习编程的 3D 游戏！整个 App 设计得非常用心，效果看起来也非常棒，下面是这个应用的界面，大家感受一下。</p>
<img src="/images/ipad-swift-playground.png">
<p>不过 Tim Cook 毕竟是做销售出身的，他不明白，其实我们真正关心的是，Swift 3 什么时候推出啊！结果他在 keynote 上啥都没说，让我们以为 Swift 3 没戏了，结果，我们事后又发现 Swift 3 的内容安静地躺在苹果的官方网站上：<a href="https://developer.apple.com/swift/" target="_blank" rel="external">https://developer.apple.com/swift/</a> 。</p>
<p>所以说，Tim Cook 还是不了解我们， iPad 版的 Swift Playground 太酷，那也就是给小孩学编程入门用的，大量的程序员还是关心的是 Swift 啥时候稳定，Xcode 有啥有意思的功能不，这些都被 Cook 给忽视了。</p>
<p>还算我眼睛尖，我在他的一页大量的 feature list 中，看到了下面的一行字：</p>
<p><img src="http://ww4.sinaimg.cn/mw690/65dc76a3jw1f4u663wkc6j20bv05ct9e.jpg" alt=""></p>
<p>这意味着，Xcode 终于官方支持插件了！妈妈再也不用担心升级 Xcode 的时候插件失效了！我今天翻了一下日程，WWDC 中专门有一个 session 做相关的介绍，是：<a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="external">《Using and Extending the Xcode Source Editor》</a></p>
<h2 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h2><p>最后看完 WWDC，已经是零辰 3 点钟了，有一点点失落。今年的内容惊喜不多，但是，我终归是又一次熬夜观看了直播。希望自己能保持这样对技术的激情，也希望苹果明年的 WWDC 能有一些惊喜。</p>
<p>哦，我整理了一个后续值得观注的 session 列表，分享给大家：</p>
<blockquote><p>Improving Existing Apps with Modern Best Practices<br><a href="https://developer.apple.com/videos/play/wwdc2016/213/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/213/</a></p>
<p>What’s New in Cocoa Touch<br><a href="https://developer.apple.com/videos/play/wwdc2016/205/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/205/</a></p>
<p>What’s New in Foundation for Swift<br><a href="https://developer.apple.com/videos/play/wwdc2016/207/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/207/</a></p>
<p>What’s New in UICollectionView in iOS 10<br><a href="https://developer.apple.com/videos/play/wwdc2016/219/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/219/</a></p>
<p>Typography and Fonts<br><a href="https://developer.apple.com/videos/play/wwdc2016/803/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/803/</a></p>
<p>Advanced Testing and Continuous Integration<br><a href="https://developer.apple.com/videos/play/wwdc2016/409/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/409/</a></p>
<p>Debugging Tips and Tricks<br><a href="https://developer.apple.com/videos/play/wwdc2016/417/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/417/</a></p>
<p>Getting Started with Swift ( 有最新 Swift 3 的内容）<br><a href="https://developer.apple.com/videos/play/wwdc2016/404/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/404/</a></p>
<p>Going Server-side with Swift Open Source<br><a href="https://developer.apple.com/videos/play/wwdc2016/415/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/415/</a></p>
<p>Introduction to Xcode ( 看看 Xcode 8 的新功能有啥）<br><a href="https://developer.apple.com/videos/play/wwdc2016/413/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/413/</a></p>
<p>Swift API Design Guidelines<br><a href="https://developer.apple.com/videos/play/wwdc2016/403/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/403/</a></p>
<p>Understanding Swift Performance<br><a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/416/</a></p>
<p>Using and Extending the Xcode Source Editor（了解 Xcode 编辑器的插件功能）<br><a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/414/</a></p>
<p>What’s New in LLVM<br><a href="https://developer.apple.com/videos/play/wwdc2016/405/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/405/</a></p>
<p>What’s New in Swift<br><a href="https://developer.apple.com/videos/play/wwdc2016/402/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/402/</a></p>
<p>What’s New in Xcode App Signing<br><a href="https://developer.apple.com/videos/play/wwdc2016/401/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/401/</a></p>
<p>Concurrent Programming With GCD in Swift 3<br><a href="https://developer.apple.com/videos/play/wwdc2016/720/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/720/</a></p>
<p>NSURLSession: New Features and Best Practices<br><a href="https://developer.apple.com/videos/play/wwdc2016/711/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2016/711/</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/wwdc-2016.jpg">
<p>今天凌晨 1 点钟，熬夜看了今年的 WWDC，一些随想分享给大家。</p>
<h2 id="u82B1_u7D6E"><a href="#u82B1_u7D6E" class="headerlink" ti]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给程序员的管理入门课程 -《格鲁夫给经理人的第一课》]]></title>
    <link href="http://blog.devtang.com/2016/06/06/high-output-management-summary/"/>
    <id>http://blog.devtang.com/2016/06/06/high-output-management-summary/</id>
    <published>2016-06-06T15:50:00.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5E8F"><a href="#u5E8F" class="headerlink" title="序"></a>序</h2><img src="/images/high-output-management-book.png">
<p><a href="http://item.jd.com/11232323.html" target="_blank" rel="external">《格鲁夫给经理人的第一课》</a> 最早出版于 2007 年，书原名为《High Output Management》。本书的作者格鲁夫是 Intel 的前 CEO，领导了 Intel 从一家濒临倒闭的存储器公司，转型为微处理器公司，并且在个人 PC 开始流行时，成功和微软缔结 Wintel 联盟，主宰了整个 PC 电脑时代。</p>
<p>格鲁夫是一个技术出身的管理者，在本书中，我们甚至看到他多次用编译器来举例，所以这本书也非常适合有技术背景的读者。</p>
<p>本书主要分为四大部分：</p>
<ul>
<li>第一部分「早餐店的生产线」：用早餐店的经营故事，来类比企业的经营管理，介绍了一些数据分析、产品预测、产品检验的办法，提出了管理杠杆率以及关注于产出的管理原则。</li>
<li>第二部分「打好团体战」：展开论述管理杠杆率，并且讨论了开会、决策和规划。</li>
<li>第三部分「推动组织的巧手」：从企业组织架构入手，谈混合型组织，双重报告，CUA 模型，以及文化价值观。</li>
<li>第四部分「谋事在人」：讲人员管理。涉及激励、工作成熟度、绩效评估、招人与留人、报酬与培训。</li>
</ul>
<h2 id="u7B2C_u4E00_u90E8_u5206_uFF1A_u65E9_u9910_u5E97_u7684_u751F_u4EA7_u7EBF"><a href="#u7B2C_u4E00_u90E8_u5206_uFF1A_u65E9_u9910_u5E97_u7684_u751F_u4EA7_u7EBF" class="headerlink" title="第一部分：早餐店的生产线"></a>第一部分：早餐店的生产线</h2><p>本部分用早餐店的经营故事，来类比企业的经营管理。介绍了一些数据分析、产品预测、产品检验的办法。</p>
<h3 id="u7B2C_u4E00_u7AE0_uFF1A_u201C_u751F_u4EA7_u201D__u5305_u542B_u4EC0_u4E48_uFF1F"><a href="#u7B2C_u4E00_u7AE0_uFF1A_u201C_u751F_u4EA7_u201D__u5305_u542B_u4EC0_u4E48_uFF1F" class="headerlink" title="第一章：“生产” 包含什么？"></a>第一章：“生产” 包含什么？</h3><p>格鲁夫认为，一个早餐店的生产线，就包含了一个现代软件开发管理中的各种问题。一个合格的早餐店的生产线，可以在预定的时间内，用最低的成本，做出顾客需要的产品。而现代软件的开发流程，也是希望在一个预定的时间内，用最低的成本，开发出符合产品经理定义的、合格的应用或服务。</p>
<p>这个过程，涉及一些最基本的项目管理工作：找出限制步骤，然后优化流程，形成一个最佳的策略。</p>
<p>在经营早餐店的故事中，限制步骤可能是人员数量、一些机器的产能、或者库存量。通过分析这些限制步骤的成本和收益，你就可以找出一个最价收益的方案。</p>
<p>软件开发中的项目管理也是这样，你的限制步骤可能是人员数量、开发时间、产品功能点、测试时间、或者技术实现方案。找到限制步骤后，通过优化限制步骤就可以优化整个流程。</p>
<h3 id="u7B2C_u4E8C_u7AE0_uFF1A_u4ECE_u65E9_u9910_u5E97_u7684_u5E93_u5B58_u8C08_u8D77"><a href="#u7B2C_u4E8C_u7AE0_uFF1A_u4ECE_u65E9_u9910_u5E97_u7684_u5E93_u5B58_u8C08_u8D77" class="headerlink" title="第二章：从早餐店的库存谈起"></a>第二章：从早餐店的库存谈起</h3><p>格鲁夫认为，我们应该确定和监控早餐店的核心指标，对于一个早餐店来说，核心指标包括：销售预测、原料库存、设备状况、人员情况、品牌评价（用户反馈），并且每天检视这些指标。</p>
<p>另外，作者提到，指标应该有相互的限制，这样避免过度反应。就像软件开发中的软件质量与开发时间一样，不能只追求质量而不管开发时间，也不能只追求时间还不管质量。</p>
<p>其实作者在这章强调的就是数据分析的重要性，在数据分析上，作者介绍了一些方法，包括：</p>
<ul>
<li>先行指标，用于揭示未来信息的指标，例如 NPS，机器故障记录。</li>
<li>线性指标，用于分析进度的指标。</li>
<li>趋势指标，用于分析变化趋势的指标。</li>
<li>重复印证表，用于修正预测行为，提高预测准备性的指标。</li>
</ul>
<img src="/images/hom-1.png">
<img src="/images/hom-2.png">
<p>作者接着提到了计划生产。这个事情是预期未来的销售额而提前生产（放到库存）的一种行为。这里面合理地预测未来是核心，否则要么就会造成没有商品可卖，要么就会造成库存过高。刚刚提到的「重复印证表」可以比较好地帮助我们做预测的调整。</p>
<p>作者接着提到了检验质量。检验质量应该在生产的每个环节都做，但是越早的环节，检验的成本越低。就像我们修复程序的 Bug 这件事情一样，如果我们刚刚写完代码就收到相应的 Bug 报告，那么修复的成本会小很多。但如果我们写完过了一周才收到 Bug 报告，那么我们就需要花精力先回顾当时的逻辑，才能进一步找到有问题的代码。</p>
<p>作者提到了一些检验质量的办法，用于节省检验本身的精力成本。</p>
<p>第一种检验办法是：海关与监视器。海关简单来说就是所有的东西都必须检查，监视器简单来说就是抽样检查。根据具体产品出问题的概率，以及出问题的危害程度，我们可以结合海关的检验方法和监视器的检验方法。</p>
<p>第二种检验办法是：随机检验。随机检验的量应该随着检验结果的好坏有所调整，使得检验有针对性。</p>
<p>本章的最后，作者提出了管理杠杆率的概念，并且用下面的漫画来做了解释。作者认为，通过定义管理的「产出」，我们可以专注于那些提高产出的管理活动，那些高投入产出比的管理活动被作者称作「管理杠杆率」高，进而应该被优先安排和执行。</p>
<img src="/images/hom-3.png">
<h2 id="u7B2C_u4E8C_u90E8_u5206_uFF1A_u6253_u597D_u56E2_u4F53_u6218"><a href="#u7B2C_u4E8C_u90E8_u5206_uFF1A_u6253_u597D_u56E2_u4F53_u6218" class="headerlink" title="第二部分：打好团体战"></a>第二部分：打好团体战</h2><p>本部分介绍了管理的一些经验技巧，涉及管理杠杆率、开会、决策和规划。</p>
<h3 id="u7B2C_u4E09_u7AE0_uFF1A_u7BA1_u7406_u6760_u6746_u7387"><a href="#u7B2C_u4E09_u7AE0_uFF1A_u7BA1_u7406_u6760_u6746_u7387" class="headerlink" title="第三章：管理杠杆率"></a>第三章：管理杠杆率</h3><p>作者首先在本章定义了经理人的产出：</p>
<blockquote>
<p>经理人的产出 = 他直接管辖部门的产出 + 他间接影响所及部门的产出</p>
</blockquote>
<p>格鲁夫介绍了他一天的工作，能够看出来工作内容非常杂乱，也非常多，而且做不完。他说：</p>
<blockquote>
<p>我的一天通常结束在我觉得累而决定回家休息的时候，而不是事情做完了。</p>
<p>像家庭主妇一样，经理人永远有忙不完的事情。</p>
</blockquote>
<p>因为事情永远做不完，所以我们更需要关注于工作的产出，把最高优先级的事情找出来优先安排和执行。</p>
<h4 id="u7BA1_u7406_u5DE5_u4F5C_u7684_u5206_u7C7B"><a href="#u7BA1_u7406_u5DE5_u4F5C_u7684_u5206_u7C7B" class="headerlink" title="管理工作的分类"></a>管理工作的分类</h4><p>我们从格鲁夫一天工作的介绍中，能看出来他的工作分为几类：</p>
<ul>
<li>信息收集类。看邮件、看报告、开会、和同事聊天、看用户反馈、看产品数据、试用公司产品等。</li>
<li>传递信息。培训或者分享观点。</li>
<li>决策。通过、制定或者否决一些方案。</li>
<li>给予提示。传递一些观点。</li>
<li>为人表率。提供行为示范。</li>
</ul>
<p>在信息收集方面，作者鼓励在使用传统的邮件和口头直接沟通外，多增加一些非正式的沟通机会。比如多随意在公司里走走，找不同的人聊聊天等等。</p>
<p>在决策方面。作者认为决策分为两类：「未雨绸缪型」和「亡羊补牢型」，前者是在规划未来，后者是在补救当前问题。</p>
<p>关于给予提示，作者认为他与决策的差别在于，给予提示很多时候并没有明确的方案，他是希望让对方通过提示来做一些调整，而调整的具体的细节需要对方自己思考。</p>
<p>除了以上四类（信息收集、信息传递、决策、给予提示）工作，作者也提到，管理者的所有行为，同时也在以「榜样」的作用被员工效仿。例如管理者随意迟到，员工就会随意迟到。管理者做事情认真，员工也会有认真工作的压力。</p>
<h4 id="u7BA1_u7406_u6760_u6746_u7387"><a href="#u7BA1_u7406_u6760_u6746_u7387" class="headerlink" title="管理杠杆率"></a>管理杠杆率</h4><p>在介绍完管理工作的分类后，格鲁夫给大家介绍了他的管理杠杆率公式：</p>
<blockquote>
<p>  经理人的产出<br>= 组织产出的总和<br>= 杠杆率 A <em> 管理活动 A + 杠杆率 B </em> 管理活动 B ……</p>
</blockquote>
<p>与管理杠杆率相关的因素有很多，包括时效：一个员工有离职情绪时，及时沟通的时效就很重要。一个重要会议要开时，提前准备内容的时效就很重要。</p>
<p>另外，格鲁夫指出，也有很多管理活动的杠杆率是负的，例如：经理人情绪低下，影响员工士气。经理人越权干涉别人的工作，影响别人积极主动性。经理人做出错误决策，浪费人力物力。</p>
<p>格鲁夫指出，高杠杆率的事情包括：</p>
<ul>
<li>当一个经理人可以同时影响多个人的事情</li>
<li>当经理人一个简单动作或简短谈话，会对别人产生长远影响的时候</li>
<li>当经理人的技术、知识或信息，对一群人造成影响的时候</li>
</ul>
<p>作者也列出了一些具体的高杠杆率的事情：</p>
<ul>
<li>关注用户的反馈，特别是抱怨。</li>
<li>绩效评估。</li>
<li>传授知识、技能或价值观给部署。</li>
<li>授权。</li>
</ul>
<h4 id="u6388_u6743"><a href="#u6388_u6743" class="headerlink" title="授权"></a>授权</h4><p>关于授权，作者做了展开的介绍：</p>
<blockquote>
<p>没有完备监督计划的授权等于渎职。你绝对不能完全地抽身，即使你已经授权，你还是得负成败责任。<br>全程监督整个被授权的案子是确保结果尽如人意的唯一方法。监督不是干涉，而是通过不时的检查，来确定活动的进行一如预期。<br>因为监督你熟悉的工作比较容易，所以如果有机会，你应该把自己熟悉的工作授权给他人。但切记先前举的例子—理智叫你松手，但情感上你可能老大不愿意。</p>
</blockquote>
<p>监督的办法可以用上一部分提到的检验产品质量的原则：越早检验成本越小。例如对开发工作不熟悉的员工，让他们在写代码前就先给你讲讲他打算如何规划，就比让他写完你再检查要好得多。</p>
<p>监督的另外一个技巧也是检验产品质量的原则提到的：注意检验的频率。对于新人，要增加频率。对于信任的人，可以降低频率。另外，监督的方法要具有多样性，对不同的人采用不同的方法。</p>
<p>监督并不是说经理人一定需要替员工考虑好事情的方方面面，因为这毕竟需要付出大量的精力。对于某些事情，经理人只需要提出一些细节问题来测试员工的思考是否全面，则可以一定程度上评估出事情的靠谱程度。对于经理人不熟悉的领域，也可以用此办法。</p>
<p>关于这方面的知识，我在指导 iOS 开发新人的时候体会很深。通常指导新人的常用办法，就是将自己熟悉的工作交给新人完成。因为这些工作非常好通过监督（Code Review + 定期讨论）来保证质量，所以风险可控，而我自己也会从中学习到指导别人的各种技巧和经验。</p>
<p>最重要地，我需要打破我的舒适区，因为我需要放弃自己非常熟悉的工作内容，转而做一些新的陌生的事情。而新人的代码质量和编写速度往往是比我自己直接写要慢得多的，我需要有耐心地等待他们犯错，然后通过 Code Review 和讨论来让他们学习到相应的编程知识。</p>
<p>学会指导新人通常是一个有经验的程序员转向更高职位的第一个挑战，不管是他是转向偏管理的岗位还是继续在技术岗位上深挖，都需要先将手中的工作交出去，才能够承担更重要，更有挑战的事情。</p>
<h4 id="u63D0_u9AD8_u6548_u7387"><a href="#u63D0_u9AD8_u6548_u7387" class="headerlink" title="提高效率"></a>提高效率</h4><p>作者提出了一些提高效率的办法：</p>
<ul>
<li>找出限制步骤：重要的、紧急的事情优先安排。这样的情况下有空余，再安排别的事情。</li>
<li>类似的工作放在一起做。例如将邮件处理，QQ 信息回复的事情稍做积累再统一回复。</li>
<li>安排好日程表。对一些事情说不，对日程表的事情留上 Buffer。</li>
<li>建立指标。尽量估计自己在每件事情上的花费，尽管这件事情很难，也可能不太准，但是总是会有所帮助，而且有经验了之后，估计时间会越来越准。</li>
<li>存货法。留一些重要不紧急的事情，使自己不太忙的时候，可以做这些事。比如对于我来说，学习产品知识，试用各种 App 的功能，分析各种 UI 设计就是一个「存货」。</li>
<li>标准化。对一些经常做的事情，制定标准化的流程就可以提高效率。这就类似我们制定的产品评审流程，上线流程一样。标准化了之后，就不用每次想应该怎么做了，按步就班地开展即可。</li>
</ul>
<p>老被人打断怎么办？作者认为「躲起来让人找不出」或者「叫别人不要在某些时段打扰」的办法都不太好，他介绍了很多有用的办法，包括：</p>
<ul>
<li>标准化。把一些常见的问题归类总结。如果一类问题有归类总结了，也就意味着它能够被授权给员工来处理了，也很容易被进一步用于员工指导别人。</li>
<li>类似的工作放在一起做。每天固定时间处理员工的问题，或者固定在一对一沟通中处理相关问题。</li>
<li>运用指标。有指标就可以改进流程。看看自己花费在解决临时问题上的时间以及常见问题，然后就可以看看能够优化这些时间。</li>
</ul>
<h3 id="u7B2C_u56DB_u7AE0_uFF1A_u7BA1_u7406_u5FC5_u7ECF_u4E4B_u8DEF_uFF1A_u5F00_u4F1A"><a href="#u7B2C_u56DB_u7AE0_uFF1A_u7BA1_u7406_u5FC5_u7ECF_u4E4B_u8DEF_uFF1A_u5F00_u4F1A" class="headerlink" title="第四章：管理必经之路：开会"></a>第四章：管理必经之路：开会</h3><p>格鲁夫将会议分为两类：过程导向会议和任务导向会议。</p>
<ul>
<li>过程导向会议：关于知识技能和信息交流，通常是例行的。</li>
<li>任务导向会议：会产生决策的，通常不是例行的。</li>
</ul>
<h4 id="u8FC7_u7A0B_u5BFC_u5411_u4F1A_u8BAE"><a href="#u8FC7_u7A0B_u5BFC_u5411_u4F1A_u8BAE" class="headerlink" title="过程导向会议"></a>过程导向会议</h4><p>过程导向会议又可分为以下三类：一对一会议、部门会议，以及运营总结会议。过程导向会议要尽量规律化。</p>
<p>关于一对一会议，我之前专门写过文章：<a href="http://blog.devtang.com/2015/10/25/one-on-one-summary/">《浅析一对一沟通》</a></p>
<p>关于部门会议，作者的经验是经理人要注意大家讨论的主题和效率，事先讨论的主题需要明确，最好大家在开会前能做好准备。经理人要尽量让讨论是自由的，避免成为自己主宰的「一言堂」。部门会议的议题应该尽量让部属来负责，经理人的责任只是保证讨论不要偏题即可。</p>
<img src="/images/hom-4.png">
<p>运营总结会议是让那些通常没有机会开部门会议的同事提供互动的机会，让他们有机会彼此学习及分享经验。</p>
<h4 id="u4EFB_u52A1_u5BFC_u5411_u4F1A_u8BAE"><a href="#u4EFB_u52A1_u5BFC_u5411_u4F1A_u8BAE" class="headerlink" title="任务导向会议"></a>任务导向会议</h4><p>过程导向的会议一般有固定的开会时间和频率，其效果也多是交流信息为主。而任务导向会议一般没有固定的开会时间和频率，会议结束后一般也需要产出一份会议的讨论结果用于后续执行。</p>
<p>这种需要决策的会议通常需要控制人数，如果超过 8 个人，很可能比较难以推动达成意见的一致。</p>
<h4 id="u4E92_u8054_u7F51_u516C_u53F8_u5B9E_u9645_u7684_u60C5_u51B5"><a href="#u4E92_u8054_u7F51_u516C_u53F8_u5B9E_u9645_u7684_u60C5_u51B5" class="headerlink" title="互联网公司实际的情况"></a>互联网公司实际的情况</h4><p>就我的感受，互联网公司其实为了追求效率，还是希望尽量少开会，我参与的会议主要分几类：</p>
<ul>
<li>Scrum 相关的会议：包括计划会议、每日站会、评审会议和回顾会议。我们的技术和产品工作都用 Scrum 的方式来管理。</li>
<li>过稿会议：产品的过稿会议，UI 稿的过稿会议。</li>
<li>一些临时性的，需要讨论的会议，类似格鲁夫提到的任务导向会议。</li>
</ul>
<p>如果把一对一沟通算作会议，那么这也是我常参与的。但是因为一对一沟通的场地经常是在非办公室的区域，所以我其实不觉得这是一种会议。</p>
<h3 id="u7B2C_u4E94_u7AE0__u4E0D_u6325_u821E_u6743_u6756_u7684_u51B3_u7B56"><a href="#u7B2C_u4E94_u7AE0__u4E0D_u6325_u821E_u6743_u6756_u7684_u51B3_u7B56" class="headerlink" title="第五章 不挥舞权杖的决策"></a>第五章 不挥舞权杖的决策</h3><p>由于在互联网公司，科技类知识更新速度非常快，而相对于一线的技术人员，管理者并不能拥有更多决策所需要的专业知识，因此我们需要将具体的决策，下放到一线的员工手中。</p>
<p>格鲁夫在书中描述了一种理想的决策方式：</p>
<ul>
<li>先是充分地讨论和表达意见</li>
<li>然后是在意见充分被表达之后的决策</li>
<li>最后是一旦最后决策产生，那些少数不同意的同事，都应该在之后执行过程中全力支持。</li>
</ul>
<img src="/images/hom-5.png">
<h3 id="u7B2C_u516D_u7AE0__u89C4_u5212_u662F_u4E3A_u4E86_u660E_u5929"><a href="#u7B2C_u516D_u7AE0__u89C4_u5212_u662F_u4E3A_u4E86_u660E_u5929" class="headerlink" title="第六章 规划是为了明天"></a>第六章 规划是为了明天</h3><blockquote>
<p>在你规划行动方案之前，一定记得先问自己：有什么事情我如果 “今天” 做了，可以让 “明天” 更好，或者至少让 “明天” 不会更糟。</p>
</blockquote>
<p>在本章，格鲁夫首先介绍了 Intel 在流程规划上的一些方法，但是个人感觉比较偏制造业，因为讲的都是处理原材料，库存与订单之单的矛盾。</p>
<p>接着，格鲁夫介绍了目标管理，包括需要做到：1、有明确的目标。2、有向目标前进的具体方案。</p>
<blockquote>
<p>当你将计划落实为白纸黑字时，看起来最抽象笼统的总结即为你的战略，而你用来实行战略的行动即为战术。</p>
</blockquote>
<p>对于这章，我自己倒是有一些总结。就我在互联网公司的经验来说，我们做规划和目标管理主要是分为以下几类：产品规划、开发规划、运营规划、人员规划。</p>
<h4 id="u4EA7_u54C1_u7684_u89C4_u5212"><a href="#u4EA7_u54C1_u7684_u89C4_u5212" class="headerlink" title="产品的规划"></a>产品的规划</h4><p>我们通常需要计划出未来至少 3 个版本的产品迭代计划。然后，对于这些产品计划，安排相应的产品 PRD 稿的撰写和评审、UI 稿的制作和评审、技术评审、开发测试及最后的上线。</p>
<h4 id="u5F00_u53D1_u7684_u89C4_u5212"><a href="#u5F00_u53D1_u7684_u89C4_u5212" class="headerlink" title="开发的规划"></a>开发的规划</h4><p>开发的规划主要是通过 Scrum，将产品和美术稿已经 Ready 的待做事项以 backlogs 的方式放在 Scrum 的管理中。然后在每一个迭代冲刺（Sprint）中，我们从 backlog 里面选取部分工作到当个 Sprint 中。</p>
<p>每一个 Sprint 是包括完整的开发和测试工作，服务器端通常在 Sprint 快结束时，就需要完成上线操作。客户端由于版本发布过于频繁对于用户也有一些打扰，所以我们通常两周对外发布一次版本。</p>
<h4 id="u8FD0_u8425_u7684_u89C4_u5212"><a href="#u8FD0_u8425_u7684_u89C4_u5212" class="headerlink" title="运营的规划"></a>运营的规划</h4><p>大型的运营活动如果需要产品和开发的介入，就也需要相应的规划。通常情况下，我们认为提前一个半月开始是相对充裕的方式。运营花大概两周做活动的策划，剩下的一个月用于技术的排期。</p>
<h4 id="u4EBA_u5458_u7684_u89C4_u5212"><a href="#u4EBA_u5458_u7684_u89C4_u5212" class="headerlink" title="人员的规划"></a>人员的规划</h4><p>作为团队管理者，我们还需要在人员上做相应的规划。这包括：</p>
<ul>
<li>人员的招聘。预估未来业务增长对于人力的需求，以便提前做好相应的招聘工作。</li>
<li>人员的培养。新人的培养、重要岗位人员的培养。</li>
<li>人员的激励或开除。对一些表现优秀的人员，给予更多的关注和沟通。对一些表现不佳的人员，除了需要明确地指出他们的问题外，也需要根据改进情况选择后续的处理方案。</li>
</ul>
<h2 id="u7B2C_u4E09_u90E8_u5206_uFF1A_u63A8_u52A8_u7EC4_u7EC7_u7684_u5DE7_u624B"><a href="#u7B2C_u4E09_u90E8_u5206_uFF1A_u63A8_u52A8_u7EC4_u7EC7_u7684_u5DE7_u624B" class="headerlink" title="第三部分：推动组织的巧手"></a>第三部分：推动组织的巧手</h2><p>本部分介绍一些实践经验，作者从早餐店的发展作为故事，引出企业管理中涉及的混合型组织架构，从这种架构带来的问题出发，提出了双重报告这种解决方案，由从双重报告需要的企业文化出发，介绍了影响人们行为的 CUA 模型，最后得出高 CUA 因素的工作，需要员工用文化价值观来指导行为。</p>
<p>比较可惜的是，对于如何增强大家的文化价值观，格鲁夫并没有展开讨论，只是说领导应该以身作则。</p>
<h3 id="u7B2C_u4E03_u7AE0__u5F53_u65E9_u9910_u5E97_u5F00_u59CB_u7E41_u884D"><a href="#u7B2C_u4E03_u7AE0__u5F53_u65E9_u9910_u5E97_u5F00_u59CB_u7E41_u884D" class="headerlink" title="第七章 当早餐店开始繁衍"></a>第七章 当早餐店开始繁衍</h3><blockquote>
<p>在实务中，这种有关管理上集权及分权的分歧到处可见，几已成为今日管理上最重要的课题之一。</p>
</blockquote>
<p>本章只讲了一个故事，当早餐店做得越来越好时，分店越来越多，带来的管理上的复杂度也越来越大。不管是采购，还是人事，还是资产，我们都需要专门雇佣人员来负责。</p>
<p>但是除了这个故事外，本章并没有涉及任何解决方案的内容。</p>
<h3 id="u7B2C_u516B_u7AE0__u6DF7_u8840_u578B_u7EC4_u7EC7"><a href="#u7B2C_u516B_u7AE0__u6DF7_u8840_u578B_u7EC4_u7EC7" class="headerlink" title="第八章 混血型组织"></a>第八章 混血型组织</h3><blockquote>
<p>斯隆总结他在通用汽车数十年的经验时说：好的经营管理，是中央集权和地方分权间的折中产品。</p>
</blockquote>
<p>本章讨论了两种组织形式：「任务导向组织」和「功能导向组织」。</p>
<img src="/images/hom-6.png">
<p>任务导向组织是以具体的完成某件事情为目标而形成的组织。功能导向组织是以完成某个细分功能而形成的组织。这两种组织各有优缺点，很多时候需要以混合的形式存在于一家公司，而具体如何混合，在不同的公司差异相当大。</p>
<p>拿互联网公司来举例，我所在的猿题库是更偏向「任务导向组织」的公司，我们公司旗下有三款产品：猿辅导、猿题库、小猿搜题。这三个产品下面，各种有着完整并且独立的运营、产品、开发、测试、UI 团队。而我之前工作的网易有道，就是一家更偏向「功能导向组织」的互联网公司，因为在网易有道，有着全公司统一的测试团队、UI 团队。还有一些公司，他们甚至将全公司的移动端开发都集中成一个移动开发团队。</p>
<p>两种组织方式各有优缺点，我们来看看作者格鲁夫的分析。</p>
<h4 id="u529F_u80FD_u5BFC_u5411_u7EC4_u7EC7"><a href="#u529F_u80FD_u5BFC_u5411_u7EC4_u7EC7" class="headerlink" title="功能导向组织"></a>功能导向组织</h4><p>「功能导向组织」的部门更像是内部的分包商，相比外部的外包商，内部的分包商因为同属于一家公司，所以提供的服务会更好，而且还有：</p>
<ul>
<li>规模经济。以运维为例，全公司统一的运维部门，有利于在公司内部建一统一的运维规范和运维系统，节省运维成本。</li>
<li>根据需求，转移或分配企业资源。以测试为例，全公司统一的测试团队，在某些产品有更多临时测试需求时，更好地调配人员。</li>
<li>共享知识。全公司统一的测试团队、UI 团队有利于他们更加方便地交流相关的专业技术，测试团队可能在测试流程上更加优化，UI 团队可能在全公司范围内统一 UI 设计规范和准则。</li>
</ul>
<p>但是，「功能导向组织」的缺点也很明显，包括：</p>
<ul>
<li><p>不同部门之间会争抢「功能导向组织」的资源。比如测试团队如果是公共的话，每个部门都会为自己的产品争取尽量多的测试资源，但是谁能够证明自己的优先级肯定比别人的高呢？所以这其中会产生更多的沟通和决策成本。</p>
</li>
<li><p>责任心减弱。这一条并不是格鲁夫总结的，而是我自己感受到的。拿移动开发团队举例，如果移动开发团队是「功能导向组织」，那么某个移动开发者对于一个临时的开发工作很可能并不能做到付出 100% 的全力，因为他很可能只在这个项目做两个月。那么他很可能着眼于「把当前的工作做完」，而不是「整个产品本身的利益」来考虑问题。</p>
</li>
</ul>
<p>举一个具体的例子，当一个产品设计对一种特殊情况考虑不完整时，一个「功能导向组织」的开发者很可能基于按时「把当前的工作做完」这个目标，而选择忽视这些未定义的产品细节，按照「怎么方便就怎么开发」的方式来做，因为产品没定义清楚本来是产品的责任，与他无关。如果他找产品讨论这些细节，很可能使得实现方案变得更加复杂，对于他「把当前的工作做完」这个目标产生冲突。</p>
<p>但是，如果是一个「任务导向组织」的开发者，因为他会长久地负责这个项目的开发，这个项目的好坏最终会决定大家的绩效，他当前没有处理好这个产品细节，以后很可能也会是他来再次重构相应的代码。那么他就有更大的可能去和产品沟通和协调，确定这些未定义的产品细节。</p>
<h4 id="u4EFB_u52A1_u5BFC_u5411_u7EC4_u7EC7"><a href="#u4EFB_u52A1_u5BFC_u5411_u7EC4_u7EC7" class="headerlink" title="任务导向组织"></a>任务导向组织</h4><p>「任务导向组织」的优点是什么呢？优点是需求更加明确，决策更加灵活，人员也更加有凝聚力。</p>
<p>「任务导向组织」也有缺点，主要是这种方式会使得大家在共享专业知识上更加困难。对此，我们公司增加了很多全公司范围内的技术分享会，通过这些分享活动，我们希望增加大家在技术上的交流。</p>
<p>那么，猿题库公司的具体混合型组织是什么样的呢？我们的「功能导向组织」仅包括：运维团队、算法研究团队、数据分析团队、财务和行政团队。而我们将产品、运营、测试、客户端开发、Web 前端开发、UI 设计人员都分拆放到了「任务导向组织」中，而我们按产品将「任务导向组织」分为了三个：猿辅导团队、猿题库团队、小猿搜题团队。</p>
<h3 id="u7B2C_u4E5D_u7AE0__u53CC_u91CD_u62A5_u544A"><a href="#u7B2C_u4E5D_u7AE0__u53CC_u91CD_u62A5_u544A" class="headerlink" title="第九章 双重报告"></a>第九章 双重报告</h3><p>格鲁夫在本章中，推荐用双重报告来解决混合型组织的管理问题。混合型组织中，一个人如果在一个「任务导向组织」，那么他很可能在专业技能上无法得到 Leader 的指导，格鲁夫希望通过让这个人在专业技能上报告给一个专业技能上的 Leader，使得这个人在专业技能上有所成长。</p>
<p>但是，格鲁夫也提到，这种双重报告很多时候是模糊不清的，「含混是解决问题之道」。所谓的含混，就是指专业技能的 Leader 在实际上并没有明确的权力。有些时候，双重报告的存在形式是一些「同级群体」或「同级委员会」，这些群体可能由于一些专业问题自发地形成，但是自主地决策解决一些 Leader 无法解决的问题。</p>
<p>我自己就亲自经过多次「同级群体」决策。例如，苹果规定 2016 年 6 月 1 日之后的应用必须支持 IPv6，这意味着我们可能需要升级全公司共用的网络库，于是我就在群里面发起了这个问题的讨论，一些人（主要是相关产品的 iOS 负责人）自发地参与了这个讨论，然后大家讨论出了一些方案和结论。</p>
<p>这种「同级群体」决策的成功，更大程度上不是某个规则的作用，因为我们很难明确出哪些事情需要跨部门讨论，也很难明确出这些讨论的负责人。所以，我们只能用一些企业文化或者做事方式影响大家。</p>
<p>所以，我感觉格鲁夫在本章其实并不是强调双重报告，而是强调在「任务导向组织」中，还应该有一只看不见的手，让大家在织织之间，产生协同、讨论和决策。</p>
<p>格鲁夫在本章中没有描述清楚这只看不见的手，他只把它称作「企业文化」，而这正是他在下一章将要展开阐述的内容。</p>
<h3 id="u7B2C_u5341_u7AE0__u6BCF_u4E2A_u4EBA_u90FD_u542C_u547D_u4E8E_u4E09_u4E2A__u201C_u957F_u5B98_u201D"><a href="#u7B2C_u5341_u7AE0__u6BCF_u4E2A_u4EBA_u90FD_u542C_u547D_u4E8E_u4E09_u4E2A__u201C_u957F_u5B98_u201D" class="headerlink" title="第十章 每个人都听命于三个 “长官”"></a>第十章 每个人都听命于三个 “长官”</h3><p>格鲁夫通过一个故事（故事中涉及买轮胎、遵守交通规则、主动帮助车祸的人）来说明一个人的行为，受三方面的影响：</p>
<ul>
<li>自由市场因素：大家简单地以自己的利益作为行为指导，例如挑选商品时大多只会考虑价格和质量。</li>
<li>契约义务：通过事先达成的一致，然后履行契约义务。例如我们上班，就是和公司的一种契约义务。</li>
<li>文化价值观：一种为了组织利益，牺牲自我短期利益的行为，通常这种行为长远来看对个人也是有利的。</li>
</ul>
<p>格鲁夫引入了 CUA 指标来帮助我们选择用以上哪方面的因素来指导人们的行为。CUA 分别指：工作环境的复杂性（Complexity）、不确定性（Uncertainty）、指令的模糊度（Ambiguity）。</p>
<p>程序员的工作就充满了复杂性，因为程序员需要不断地学习新知识，代码的逻辑和架构也可能很复杂。而市场的工作充满了不确定性，很多时候上司也无法帮你想出有新意的市场推广方案。</p>
<p>格鲁夫认为，如果一个工作的  CUA 因素高，而个人关注的是团体利益，那么就只能用文化价值观来作为行为的指导。但是如果个人关注的是自身利益，那么就会如下图显示的那样，情况变得「一筹莫展」。</p>
<img src="/images/hom-7.png">
<p>格鲁夫举了一个例子，当海滩上发生灾难时，每个人都只顾及保全自己的性命，而救援工作需要极高的 CUA 因素，所以现场只会是一片混乱。</p>
<p>按这个理论思考，我们就能理解为什么要做火灾演习了，多次火灾演习可以极大地减少火灾发生的 CUA 因素，因为大家在演习中对于火灾已经有着明确的处理方案了，需要做的只是按之前演习中的契约行动就行了。</p>
<p>格鲁夫认为该理论对于指导新人也有意义：</p>
<blockquote>
<p>让我们把这套理论套用在某个刚进公司的新人身上。由于初来乍到，他无疑比较关心自身的利益。因此，你应该给他明确的工作架构，降低复杂性及不确定性。</p>
</blockquote>
<p>另外，该理论对于空降的高管也有意义：</p>
<blockquote>
<p>对于空降的高管来说，就像起用任何新人一样，一开始他还是比较关心自身利益。但身为高级经理，他难免会被指派管理一个有问题的部门—毕竟这是我们从外面找人的原因。此时对这个经理人而言，他面临的不仅是烫手山芋，还有环境里很高的 CUA；同时，他也尚未建立起属于这个企业的价值观与行事准则。在此状况下，大家只能求老天保佑他能赶紧忘却私利，以大我为前提，并设法降低 CUA。如果他做不到这些，恐怕很快就会被撤掉。</p>
</blockquote>
<p>文化价值观也不是银弹，在 CUA 因素低的时候，选择用自由市场因素或契约义务，都比文化价值观来得有效。所以，根据具体工作的 CUA 值，选择具体的控制模式，是经理人需要关注的。</p>
<p>不过话说回来，我仔细想了想互联网企业里面的各种职位，不管是产品、技术、还是运营，似乎都是高 CUA 因素的职位，所以文化价值观应该是互联网公司管理员工的基本方式。</p>
<p>很可惜，格鲁夫在本章中并没有详细介绍如何增强大家的文化价值观，他只是认为，管理者自己的行为示范，比把文化价值观挂在口头上有效。但是本书的第四部分，详细讨论了企业管理中人的问题。</p>
<h2 id="u7B2C_u56DB_u90E8_u5206_uFF1A_u8C0B_u4E8B_u5728_u4EBA"><a href="#u7B2C_u56DB_u90E8_u5206_uFF1A_u8C0B_u4E8B_u5728_u4EBA" class="headerlink" title="第四部分：谋事在人"></a>第四部分：谋事在人</h2><p>本部分涉及激励、工作成熟度、绩效评估、招人与留人、报酬与培训。</p>
<h3 id="u7B2C_u5341_u4E00_u7AE0__u6FC0_u52B1_u90E8_u5C5E_u53C2_u52A0_u6BD4_u8D5B"><a href="#u7B2C_u5341_u4E00_u7AE0__u6FC0_u52B1_u90E8_u5C5E_u53C2_u52A0_u6BD4_u8D5B" class="headerlink" title="第十一章 激励部属参加比赛"></a>第十一章 激励部属参加比赛</h3><p>格鲁夫将员工的问题分为不能和不为两类：</p>
<ul>
<li>不能：能力不够。</li>
<li>不为：能力够，但是不够努力。</li>
</ul>
<p>针对这两类问题，他提出了培训和激励两种解决方案。在本章作者并没有讲培训，主要详细讨论了激励相关的问题。</p>
<p>作者认为，激励应该和马斯洛的需求金字塔理论相符。</p>
<img src="/images/hom-8.png">
<p>在「归属感与认同感」这一层，我们应该让同事们都喜欢当前的工作环境和同事关系，认同当前公司做的事情。同事之间的合作应该是愉快和融洽的，同事中还会有自己欣赏的牛人，有自己的好朋友可以一起吃饭、聊天。</p>
<p>只有产生了归属感与认同感，员工才会追求更高一层的「地位与尊重」。我们给那些表现优秀的员工更重要的事情，更高的职位，使得他能够在这一层上产生明确的目标。很多公司都会做职业发展的内部评级，其实就是给大家一个明确的地位与尊重的目标，让大家为此努力。</p>
<p>但是，「地位与尊重」的目标一旦达到，人们工作的动力又会下降。一些更牛的人，就会追求马斯洛需坟金字塔的顶端：「自我实现」。「自我实现」这一层的需求的差异性在于：</p>
<blockquote>
<p>一旦某个人受激励的来源是自我实现，他工作的动力将不再受局限。这是自我实现有别于其他激励模式最重要的特点。其它的激励来源一旦在需求满足之后便不再生效，但是自我实现将不断激励个体向上突破。</p>
</blockquote>
<p>有两种自我实现的动力可以促使个体将能力发挥到极致：精益求精型和成就导向型。</p>
<p>精益求精型的例子是音乐家、运动员，也包括程序员。拿程序员来说，一个程序员如果不断追求写出更牛逼的代码，那么他可以像<a href="http://baike.baidu.com/view/15099717.htm" target="_blank" rel="external">阿里的多隆</a>那样，成为合伙人级别的重要人物。</p>
<p>成就导向型的人常常怀有达成任务的决心，对于困难，他们喜欢挑战自我。其实做很多事情，刚开始都是需要面对失败的。成就导向型可以坦然地面对失败，然后再次挑战目标。</p>
<p>对于较高需求层次的人，失败的恐惧大多数是来自于内心而不是外界，如果不能克服自我内心的恐惧，那么这个人就会从自我实现的层次往下降。</p>
<blockquote>
<p>一般而言，在较高的需求层次时，恐惧通常源自内在而非外在的威胁。人们经常因为过不了自己那一关而导致行动上的退却。但如果老是如此，这个人很快就会从自我实现的层次往下降落。</p>
</blockquote>
<p>在具体实施激励时，格鲁夫认为，一个好的激励应该是目标明确的，并且这个目标应该是比较难以达到的，这样大家才会全力以付，发挥出尽量大的潜力。</p>
<blockquote>
<p>如果我们想要让员工都能提升自我实现需求的层次，便必须先创造出一个讲求产出的环境。</p>
</blockquote>
<p>另外，可以合理使用一些竞赛，让大家把竞技场上的争胜的心态应用到工作中。</p>
<blockquote>
<p>工作的概念天生就不如竞技，我们干脆将运动场上的竞争精神融入工作。最好的方法便是先制定游戏规则，并让员工有衡量他们表现的尺度。</p>
</blockquote>
<p>关于竞赛，我自己也有一些真实的感悟。我们公司很多人中午都会去游泳，之前大家都自己随便游，后来有一个同事说，我们分成两组，搞接力赛吧。虽然这是一个没有任何奖励的比赛，但是大家因为比赛，就会不自觉得更加努力游泳，连续多日下来，大家的体力都上升了很多。</p>
<p>关于激励，格鲁夫最后总结道：</p>
<blockquote>
<p>经理人的角色在此便极为明显：他应当是个教练，身为教练，首先必须不居功，团队的成功来自于队员对教练指导的信赖；其次，他的训练必须严格。通过当一个铁面教头，他努力激发出队员的潜能，并刺激团队做出最佳表现。一个教练应该曾经是个好选手，因此他了解竞赛的规则以及选手在练习及比赛时可能面临的问题。</p>
</blockquote>
<h3 id="u7B2C_u5341_u4E8C_u7AE0__u5DE5_u4F5C_u6210_u719F_u5EA6"><a href="#u7B2C_u5341_u4E8C_u7AE0__u5DE5_u4F5C_u6210_u719F_u5EA6" class="headerlink" title="第十二章 工作成熟度"></a>第十二章 工作成熟度</h3><blockquote>
<p>令人惊讶的是，即使较早建立起的管理理论多半靠直觉，后来的实证科学也并没有办法将它们推翻，或是证实某种管理风格确实较其他的更胜一筹。研究学者似乎必须下没有所谓最佳管理风格的定论。</p>
</blockquote>
<p>格鲁夫首先通过英特尔在轮换经理人上的故事，引出了用「工作成熟度」（Task Relevant Maturity，TRM）来评估个人或部门。</p>
<p>根据工作成熟度的不同，格鲁夫建议用不同的办法来指导：</p>
<ul>
<li>工作成熟度低时，指导应该是明确和具体的。包括做什么事情，何时完成，如何着手等。</li>
<li>工作成熟度中时，指导应该从具体的事情，转移到沟通、情绪上的支持与鼓励。</li>
<li>工作成熟度高时，指导只需要关注努力方向是否正确上。</li>
</ul>
<p>格鲁夫说，我们在指导小孩的时候，也是符合这套理论的。刚孩子还小的时候，我们只会说做什么，不做什么；等他们长大一些之后，我们变成一些叮嘱和指导；等他们成人之后，我们基本上不再管教他们了。</p>
<p>指导的时候，我们应该注意建立共同的价值观。我们在猿题库也在这方面做了很多具体的尝试，比如我们强调：按时发布产品、代码质量、信息尽量共享、指导新人比日常开发工作更重要。这些都是在努力建立共同的价值观。</p>
<blockquote>
<p>一旦员工了解了组织的营运价值观，又具有较高的工作成熟度时，主管便可以开始分权，进而提高自身的管理杠杆率。</p>
</blockquote>
<p>格鲁夫在本章中也讨论了一个非常有意思的话题，管理者是否应该与员工建立友谊。他对此有两个观点：</p>
<ol>
<li>我们不应该把友谊相关的社交活动与工作上的指导混为一谈。因为社交活动并不能直接在工作上产生帮助，当然，友谊对工作是有一些间接帮助的，因为它使得你们之间在沟通的时候会更加有效一些。</li>
<li>命令朋友其实是一件不愉快的事情。当你需要批评或直接命令朋友时，友谊可能会是一个阻碍。格鲁夫举了一个例子：当你需要给你的朋友打很低的绩效时，你是否感觉到非常难受？</li>
</ol>
<p>对此我个人的感受是，适当的友谊还是非常有必要的，对于一些同事，经过一段时间的合作，我们其实是能够比较清楚地判断出来他们的潜力。如果我们认为他们的潜力是足够大的，在建立友谊的同时，在工作上也给予更多的指导，应该是一个更好的做法。</p>
<p>另外，建立共同的「就事论事」的价值观也是非常有必要的。大家是朋友，但是工作上应该批评就批评，如果大家有着对事不对人的共同价值观，批评就不是那么不可接受了。</p>
<h3 id="u7B2C_u5341_u4E09_u7AE0__u518D_u96BE_u4E5F_u5F97_u505A_uFF1A_u7EE9_u6548_u8BC4_u4F30"><a href="#u7B2C_u5341_u4E09_u7AE0__u518D_u96BE_u4E5F_u5F97_u505A_uFF1A_u7EE9_u6548_u8BC4_u4F30" class="headerlink" title="第十三章 再难也得做：绩效评估"></a>第十三章 再难也得做：绩效评估</h3><p>格鲁夫认为绩效评估是一个高杠杆率的工作，可以使得优秀的员工得到激励，从而更加努力。但是绩效评估又是一个非常难的事情，因为很容易产生冲突和争议。</p>
<p>绩效评估大致可以分成两部分：评估部属的绩效，以及将评估的结果告诉部属。作者认为，一个有效的评估报告应该包括：优点（需要有实例证明），缺点（需要有实例证明），如果在未来提高绩效。其实对于很多公司来说，绩效评估都是含混过去的。我现在所在的公司也没有详细到格鲁夫描述的那样的绩效评估报告。</p>
<p>不过，格鲁夫介绍了如何向一个完全不合格的员工传达绩效评估，我感觉很有价值。格鲁夫用解决问题的阶段来描述不合格员工的状态。</p>
<img src="/images/hom-9.png">
<p>这些阶段具体解释如下：</p>
<ul>
<li>忽视：表现不佳的员工最初会忽视问题。所以你需要找到具体的证据，让他无法抵赖。</li>
<li>否认：当员工开始否认问题时，事情其实已经有进展了，因为至少问题被提出来了。</li>
<li>责怪别人：责怪别人是一种很有效的防卫机制，因为员工可以以此为理由拒绝承担责任。所以这一步是关键，如果让他意识到不是别人的问题，那么就很容易进入到担起责任阶段。责怪别人到担起责任涉及的是克服心理障碍的问题，而从担起责任到寻找解决方案是能力问题，后者要简单得多。</li>
<li>担起责任：承认问题。</li>
<li>找出对策：双方一起找出问题的解决方案，并且实施。</li>
</ul>
<p>格鲁夫把阶段分得很多，其实我倒觉得关键的阶段就是从否认责任到承担责任的过程，这个过程中，经理人需要收集到足够多的证据，尽量客观地沟通，另外强调就事论事的工作态度，才可能帮助员工克服心理障碍。</p>
<p>另外，即使到了最后的「找出对策」阶段，大家也可能无法达成一致，这个时候，格鲁夫建议不必在这阶段强求一致，只要员工承诺按经理的方案实施即可。我们不应该强求说服别人，因为这更多是一种心理上的需求。</p>
<blockquote>
<p>你当然希望看到部属心悦诚服地同意你的看法，但如果他不是完全同意，只要他愿意采取改进行动，你就不该再在这上面伤脑筋。不要混淆了情绪问题和工作的需要。为了完成任务，你最需要的是部属愿意施行你决定的行动方案，至于他是否与你抱持同样的想法则是其次。期望别人凡事都和你想得一样其实并不是件好事，在工作上我们主要追求的是绩效，而并不是心里舒不舒服</p>
</blockquote>
<p>我们在做绩效评估时，也应该把重点放在那些重要的员工身上，他们已经非常优秀了，所以找出他们的问题将会相对困难，但是他们在未来很可能承担更重要的工作，所以把心思花在他们身上是值得的。</p>
<p>格鲁夫在本章的最后建议，应该提前把评估报告发给员工阅读，之后再组织讨论，这样会使得员工对评价有所思考，之后的讨论更加有效率。</p>
<h3 id="u7B2C_u5341_u56DB_u7AE0__u62DB_u4EBA_u4E0E_u7559_u4EBA"><a href="#u7B2C_u5341_u56DB_u7AE0__u62DB_u4EBA_u4E0E_u7559_u4EBA" class="headerlink" title="第十四章 招人与留人"></a>第十四章 招人与留人</h3><p>关于招人，格鲁夫提到，仅仅靠一小时的面试，根本就不足以客观地评价面试者的水平。对此我是非常同意的。但是企业的成本有限，确实也没办法花费更多时间来考查面试者了，所以这是一件非常难，但是又不得不做的事情。</p>
<p>关于如何招人，其实无非就是建立一套方法论，然后希望以「较大概率」招到满意的员工。我听过很多别的公司的方法论，大家的面试方法都差别很大，但是我觉得都是做到了刚刚说的原则。我自己长久以来针对程序员、产品经理、产品实习生面试分别都有总结，在此就不展开介绍书中的办法了。</p>
<p>关于留人，书中提到最麻烦的就是重要的优秀员工想离开。对待想离职的优秀员工，第一步需要做到的是足够的倾听。</p>
<blockquote>
<p>你应该马上放下手上的事情，请他到办公室坐下来谈，问他为什么要辞职。让他畅所欲言，千万不要和他起任何争执。相信我，你的爱将已经在不止一个失眠的夜里将这套词儿演练过千百遍。等到他讲完所有他要辞职的理由（没有一个会是好理由），你再多问他一些问题。先让他说个够，因为当他讲完了事先准备好的那一套词儿后，真正的理由也许才会显现。千万不要争辩，不要说教，也不要动气。</p>
</blockquote>
<p>倾听之后，找到离职真正的原因，只能站在对方立场上考虑，如果是薪水问题，看看是否合理，该调整的话就调整。如果是工作内容，看看能否做一些公司内部的工作变动来帮助他找到更喜欢的工作。如果是当前公司的一些具体的问题，看看能不能做一些改进。但是，这些做法的前提都是：这是一个优秀的、重要的员工。如果是一个表现普通的员工提出的不合理要求，那么倾听之后可能也只能做一些形式上的挽留了，因为我们不能破坏公司的薪酬体系来挽留他。</p>
<h3 id="u7B2C_u5341_u4E94_u7AE0__u62A5_u916C_u7684_u8BF1_u60D1"><a href="#u7B2C_u5341_u4E94_u7AE0__u62A5_u916C_u7684_u8BF1_u60D1" class="headerlink" title="第十五章 报酬的诱惑"></a>第十五章 报酬的诱惑</h3><p>大部分人的薪资都是结合他的工作表现+工作年限的综合评价，这其实是建立员工稳定期望和公平的一个方案。在我们公司，有一些优秀的应届生能够比一些老员工贡献更多的产出，但是我们确实无法一下子就给他老员工那样的薪水，大部分的时候，我们会给他超出同样工作年限的人的薪水。</p>
<p>以工作年限作为薪资的重要衡量手段，算不上特别公平，但是确实也没有特别好的办法。不过，当前互联网公司已经有一些创业公司开始打破这样的规则，他们给那些工作一两年的优秀员工非常高的薪水，因为事实上，这些员工的产出和那些工作五六年的员工差别不大，但是从性价比上讲，他们比那些工作五六年的员工要价少得多，所以多给一些也没关系。</p>
<p>在互联网公司抢人的时候，这种策略被大量的采用了。这造成了互联网人才薪资水平的差异被进一步缩小，大部分人的年薪都集中在某一个很小的范围区间。而那些工作多年的人，如果不能进一步提升自己的能力，就会陷入薪资基本停止不前的怪圈。</p>
<p>在本章，作者也提到，一般职务的提升都会面临工作内容的巨大变化，很多人处理不好，反倒会表现得很差劲，这便是著名的 <a href="http://baike.baidu.com/subview/39071/14321969.htm" target="_blank" rel="external">彼得原理</a>。</p>
<blockquote>
<p>一名称职的教授被提升为大学校长后无法胜任；一个优秀的运动员被提升为主管体育的官员，导致无所作为。对一个组织而言，一旦相当部分人员被推到其不称职的级别，就会造成组织的人浮于事，效率低下，导致平庸者出人头地，发展停滞。</p>
</blockquote>
<p>但是，对此我们又有什么办法呢？我们不提拔优秀的员工，难道提拔糟糕的员工吗？所以除了对提拔的员工悉心培养之外，也没什么好办法。</p>
<p>如果一个员工实在对新工作不感兴趣，作者建议还是让他回到以前表现优秀的岗位上。虽然刚开始有一些难堪，但总比他主动离职要好得多。</p>
<h3 id="u7B2C_u5341_u516D_u7AE0__u522B_u7B49_u706B_u70E7_u7709_u6BDB_u624D_u57F9_u8BAD"><a href="#u7B2C_u5341_u516D_u7AE0__u522B_u7B49_u706B_u70E7_u7709_u6BDB_u624D_u57F9_u8BAD" class="headerlink" title="第十六章 别等火烧眉毛才培训"></a>第十六章 别等火烧眉毛才培训</h3><p>作者认为经理人应该是培训的责任人，不应该把培训交给外面的公司负责。因为经理人本身在公司内部具有权威性和可信度，他的培训内容更容易被理解，另外，每个公司的做事方式和文化都不太一样，自己参与培训才能够把正确的做事方式传递给大家。</p>
<p>设计培训课程花费的精力相当大，我当前就在设计产品实习生的培训课程，还好我之前有一些总结，否则第一次课可能都会耗费我大量时间。就算这样，我也不知道培训能否一直按计划进行下去。不管怎么样，只要开始了，总归是有产出的，而且我相信多做几次之后，我就可以建立起优秀的、系统的培训课程。</p>
<h3 id="u6700_u540E_u7684_u95EE_u9898_u5217_u8868"><a href="#u6700_u540E_u7684_u95EE_u9898_u5217_u8868" class="headerlink" title="最后的问题列表"></a>最后的问题列表</h3><p>作者在最后留了一些很棒的问题，值得大家回答一翻。</p>
<blockquote>
<p>如果你能从下列各项检验中拿到100分以上，以这本书的标准，你算是个杰出的经理人了。<br>★ 试着将你工作中的操作分为编制流程、组装及测试三个步骤。【10分】<br>★ 针对你手头开展的方案，找出限制步骤，并依此设计你的工作流程。【10分】<br>★ 找出你工作中最适合进行验货、线上检验与最终检验的地方。决定这些检验应该采用“海关”还是“监视器”的方式。然后考虑在什么时机下，你可以升格至“随机检验”。【10分】<br>★ 找出至少6项以上的新产出指标。这些指标应该要能衡量产出的质与量。【10分】<br>★ 将这些新的指标变成工作上的例行事项，并在部门会议中定期审视。【20分】<br>★ 你现在正寻找的最重要的战略（行动计划）是什么？描述你面临的环境需求以及计划进度。如果计划能成功地执行，是否能将你或你的公司带到理想中的境界？【20分】<br>★ 简化你最烦琐、最耗时的工作。至少让原有的步骤减少30%。【10分】<br>★ 找出什么是你真正的产出？你所管理的部门及影响力所及的部门的产出元素为何？按重要顺序排列。【10分】<br>★ 实际在公司中走动走动。然后，列出这次“出巡”中和你有关的事项。【10分】<br>★ 找一些借口让你一个月可以在公司内巡视一次。【10分】<br>★ 描述下一次你授权给部属时会如何督导。你将以什么为标准？怎么做？督导的频率是怎样的？【10分】<br>★ 列出你可以利用零碎时间进行的项目。【10分】<br>★ 列出和每一个部属“一对一会议”的时间表。（在会议之前向他们解释会议的目的，并要求他们作准备。）【20分】<br>★ 找出你上星期的日程表，将做的活动分为高、中、低杠杆率三类。设法多做一些高杠杆率的活动。（有哪些活动该减少或干脆不做？）【10分】<br>★ 预测下周有哪些事要瓜分你的时间。有多少时间要花在开会上？其中有多少是过程导向会议？多少是任务导向会议？如果后者占去的时间超过25%，你该如何设法删减？【10分】<br>★ 列出你的组织在未来三个月中最重要的三个目标，并一路验收成果。【20分】<br>★ 在与部属充分讨论过以上目标后，要他们也“依葫芦画瓢”—制定他们的目标并一路验收。【20分】<br>★ 写出“悬而未决”需作决策的事项。找出其中三项，试着运用决策制定过程的架构以及“六点问题”的方法。【10分】<br>★ 依据马斯洛的需求理论评估你自己的需求层次。并为部属找出他们所属的层次。【10分】<br>★ 给部属勾画他们的跑道，并找出每一个人的绩效指标。【20分】<br>★ 列出你给部属各种形式的工作所给予的相关回馈。他们是否能借着这些回馈来测量自己的进度？【10分】<br>★ 将你部属的工作成熟度分为低、中、高三类。并针对个人选出最适当的管理风格。并在你的管理风格及最适当的管理风格之间作比较。【10分】<br>★ 评估你上一次收到的或你对部属所作的绩效报告。这些报告对提高绩效有多大的影响？在上司告诉你报告内容或你告诉部属时，你们的沟通形式是怎样的？【20分】<br>★ 如果有哪一份报告不够理想，重做。【10分】</p>
</blockquote>
<h2 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h2><p>我整理这份笔记花费了好几周，我从本书中收获巨大，希望你能从这篇总结中也有所收获，祝大家玩得开心～</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5E8F"><a href="#u5E8F" class="headerlink" title="序"></a>序</h2><img src="/images/high-output-management-book.png">
<p><a href="http:]]>
    </summary>
    
      <category term="books" scheme="http://blog.devtang.com/tags/books/"/>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[技术演讲中最容易被忽视的问题]]></title>
    <link href="http://blog.devtang.com/2016/06/05/tech-talk-notes/"/>
    <id>http://blog.devtang.com/2016/06/05/tech-talk-notes/</id>
    <published>2016-06-05T08:08:35.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/tech-talk.jpg">
<p>我在国内的大大小小技术会议（比如 QCon, ArchSummit，MDCC，SwiftCon 等）中做过不少演讲，也听过很多别人的演讲。作为一个一路走过来的技术演讲者，我见过很多优秀的演讲者，也见过很多干货满满的分享因为嘉宾的演讲水平问题而搞砸。关于演讲的技巧的文章很多，我想找一个侧面，分享一下技术演讲中最容易被忽视的三个问题。</p>
<h2 id="u8D85_u65F6"><a href="#u8D85_u65F6" class="headerlink" title="超时"></a>超时</h2><p>一个演讲，刚开始准备的时候，通常都会感觉要准备 45 分钟好难，于是就会紧张起来，紧张会使得我们准备过度。而大部分演讲者都不会在正式演讲前完整地模似真实的现场演练一遍。加上演讲现场通常都会因为场下黑压压的人群，以及耀眼的灯光而产生兴奋，兴奋有可能产生两种极端，一种是以非常快地语速把 PPT 讲完，但是大部分认真准备的演讲嘉宾都会由于过度兴奋而深入到演讲的细节中忘记了时间，从而把本来就准备过多的 PPT 更加充分阐述。于是，超时随之而来。</p>
<p>一般像 QCon 这种专业的技术会议，对付超时也是相当专业的，台下的工作人员会在演讲只剩 5 分钟的时候，在台下举牌子让你注意到时间。但是这个时候，你会发现一切都晚了，PPT 只讲了一半，而时间只剩下 5 分钟，除了蒙逼还能干嘛？我见到过一次在 QCon 的超时就是这样，一位来自某一线互联网公司的技术人员，用 5 分钟的时间，把他准备的另外几十页 PPT 翻完了，大家甚至都来不及读完他在 PPT 上的写的所有文字，而基本上他除了翻完，也没有什么办法了。</p>
<p>对付超时怎么办？</p>
<p>第一步：控制 PPT 页数。通常情况下，一页 PPT 演讲时间花费大概是一分钟，一个 45 分钟的演讲一般也要留 10 分钟提问，所以准备 30 - 35 分钟的分享就够了，这样对应的页数大概是 30 - 40 页。当然，如果你的 PPT 中还有大量非摘要的、可以快速翻过的动效内容，页数可以适当增加（比如我在 SwiftCon 中演讲的 PPT 就有 60 页，但其实很多都是动画效果）。</p>
<p>第二步：提前试讲。其实这是最简单的办法，在公司内部直接把自己的演讲主题讲一遍，这样就能够精确地知道会花费多少时间了。如果不方便在公司的分享会上讲，也可以拉几个同事给他们私下分享。如果拉不到同事，自己找个小黑屋，开个计时器，完整地给自己讲一遍，也都是准确了解时间花费的办法。我在 SwiftCon 中的演讲，事先就试讲了 6 次，当然后面很多次是为了打磨内容，而不是了解时间花费。</p>
<h2 id="u5E72_u8D27_u592A_u591A"><a href="#u5E72_u8D27_u592A_u591A" class="headerlink" title="干货太多"></a>干货太多</h2><p>有人问：干货太多是问题吗？我想说：是的，问题很大！</p>
<p>我还记得有一次 InfoQ 给演讲嘉宾做培训，当时的演讲培训师给大家提了一个问题：如果让你的演讲在趣味性和技术性中做选择，你会选择哪个？现场有一半选择了前者，另一半选择了后者。我当时选择的是后者，因为我觉得，一个技术演讲，讲得没意思没关系，只要有干货就行。但是，培训师却告诉我，应该选择趣味性。</p>
<p>培训师的理由是这样的：大部分 45 分钟的演讲，都不足以完整地阐述大量的知识，获取大量的知识有更多方便的途径，比如看书。一个好的演讲者，不是应该让观众在现场接受多少内容的知识，而是让观众在现场产生对演讲内容大体框架的理解，进而在演讲结束后，观众可以进一步通过别的途径获得更多相关的知识。</p>
<p>所以，如果你的演讲原本要讲 10 个干货，那还不如把其中的最重要的 5 个整理得更加生动，形象，有趣。让观众现场能够对你演讲的主题产生兴趣，而另外那 5 个干货，你完全可以附在最后一页 PPT 上，作为延伸学习的推荐话题。如果你的演讲能让观众产生兴趣，在会后学习几个小时，那么听众在知识性上的获取效果绝对比你「填鸭」式的干货分享要好。</p>
<p>所以，适度收敛，少即是多。</p>
<h2 id="u7F3A_u4E4F_u7EC3_u4E60"><a href="#u7F3A_u4E4F_u7EC3_u4E60" class="headerlink" title="缺乏练习"></a>缺乏练习</h2><p>在这个世界上，有很多技巧都不是学来的，而是练出来的。比如我最近在学自由泳，无论我如何熟记姿势的各种要领，我也无法短时间内让自己的身体产生记忆，我能做的只是不停地练习，纠正错误，产生肌肉记忆。演讲也是一样。</p>
<p>你看到的大部分优秀的演讲者，在台上口若悬河，侃侃而谈，其实都是因为他们在之前做了大量的练习。</p>
<p>而大部分技术人员通常都是没有兴趣一遍一遍讲同样的内容，所以，缺乏练习使得他们在台上过度紧张，有些人因为紧张，只能对着讲稿把演讲内容一个字一个字读出来，这样和观众的互动就差太多了。</p>
<p>在这一点上，解决办法除了练习别无它法。我个人会有意识地每个月都做一些分享，很多时候是公司内部的或小范围的分享，这样可以不断提高自己的演讲能力。另外培训师也提到一个办法，就是自己对着摄像机做演讲，然后通过回放录像，来审视自己的表现。我试过一次，确实发现了自己很多问题，感兴趣的同学也可一试。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>超时、干货太多、缺乏练习，这就是技术演讲中我看到的最大的 3 个问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/tech-talk.jpg">
<p>我在国内的大大小小技术会议（比如 QCon, ArchSummit，MDCC，SwiftCon 等）中做过不少演讲，也听过很多别人的演讲。作为一个一路走过来的技术演讲者，我见过很多优秀的演讲者，也见过很多干]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何指导新人 - Mentor 指导手册]]></title>
    <link href="http://blog.devtang.com/2016/05/26/mentor-guide/"/>
    <id>http://blog.devtang.com/2016/05/26/mentor-guide/</id>
    <published>2016-05-26T14:22:21.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/mentor-guide.jpg">
<h1 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h1><p>本文希望帮助 Mentor 在指导实习生和新员工时，建立一些基本的共识和准则。本文主要讨论的是技术类的岗位。</p>
<h2 id="u6211_u4EEC_u4E3A_u4EC0_u4E48_u8981_u62DB_u5B9E_u4E60_u751F_u548C_u5E94_u5C4A_u751F_uFF1F"><a href="#u6211_u4EEC_u4E3A_u4EC0_u4E48_u8981_u62DB_u5B9E_u4E60_u751F_u548C_u5E94_u5C4A_u751F_uFF1F" class="headerlink" title="我们为什么要招实习生和应届生？"></a>我们为什么要招实习生和应届生？</h2><p>猿题库在招实习生上，向来是非常大方的。那么，我们为什么要花大价钱，招那些可能都没有任何实习经验和工程经验的学生？我们是为了让他们做一些简单低级的事情，还是想培养有潜力的学生？相信大家都能明白是后者。</p>
<p>那么，我们为什么想培养有潜力的学生？因为，找到一个靠谱的同事不容易，我们希望帮助这些有潜力的学生成长，在他们在成长的同时，最终能够喜欢上这里，最后能够成为正式员工。所以，为了吸引最优秀的实习生，我们开出来非常高的实习工资和有挑战的工作内容。</p>
<p>对待应届生也是一样，我们非常看重他的学校，成绩，数据结构和算法知识，兴趣，这也是为潜力买单。</p>
<p>但是，我们做的这些，得到的只是有潜力的实习生和应届生。他们离一个优秀的员工还有很大的差距，所以 Mentor 对他们的指导非常重要。如果把他们比做一个好树苗的话，Mentor 就是帮助他们最终成长成参天大树的人。相信大家都能明白，培养人其实比招人难得多。</p>
<p>那么，作为 Mentor，我们应该如何指导这些新人呢？</p>
<h2 id="u5EFA_u7ACB_u53CB_u8C0A"><a href="#u5EFA_u7ACB_u53CB_u8C0A" class="headerlink" title="建立友谊"></a>建立友谊</h2><p>好的老师和学生的关系有些时候更像朋友。大家不但会交流技术，也会一起吃饭聊天，扯淡八卦。互联网公司推崇平等，朋友式的关系更适合讨论技术。</p>
<p>如何建立友谊呢？作为 Mentor，应该在新同事刚刚入职时，带他熟悉公司环境和同事，陪他一起吃饭。平常休息的时候，聊聊工作之外的话题。有些时候，大方一点，请他吃吃饭。</p>
<p>良好的私人友谊，对于新人融入团队是非常重要的，遇到困难时，他会更加主动地向你寻求帮助。等他成长起来后，你们会成为很好的同事。即使以后你和他不在一个项目组，甚至不在一家公司了，但是你们的友谊会使得你们相互尊重并欣赏，谁知道你们以后不会再次合作呢？</p>
<h2 id="u52AA_u529B_u57F9_u517B_u65B0_u4EBA"><a href="#u52AA_u529B_u57F9_u517B_u65B0_u4EBA" class="headerlink" title="努力培养新人"></a>努力培养新人</h2><p>如果说建立友谊算是铺垫的话，那么努力培养新人才算是正题。</p>
<p>虽然大家都懂道理，但是就我观察，很多人都没有意识到培养新人的重要性，当项目太忙，自己精力不够时，就忽略了这方面的工作。而这方面的工作又没有实际明确的标准，就很容易做得不好。</p>
<p>所以，我想了一个评判培养新人重要程度的标准：培养新人的重要程度应该高于所有线上的功能开发，仅仅低于线上的紧急 Bug 修复。如果你手头有重要的开发工作，同时有重要的新人需要培养，那么你应该优先把培养新人的事情做了，再做重要的开发工作。</p>
<p>为什么这么说呢？因为，培养新人是「一次性」的投资，假如一个新人成长起来所需要的指导时间是 20 个小时，那么你尽早的完成这 20 个小时的指导，新人就可以尽早地产出有质量的工作。而如果你因为项目紧张而忽略了这件事情，那么新人可能会养成一些不好的编程习惯或做事方式，之后，你可能需要更多的时间来纠正他。</p>
<p>具体来说，努力培养新人要做好的事情包括：</p>
<ul>
<li>定期主动和新人讨论他遇到的问题。</li>
<li>开始的几周 Code Review，非常详细地审核，保证代码风格达成一致，一些不好的编程习惯得到立即纠正。</li>
<li>教会新人一些正确的学习方式，例如 Google，Github，Stackoverflow。</li>
<li>推荐一些深入的学习资料给新人。并且发现他在某方面没有提高时，持续 PUSH 他看相关的书籍。</li>
</ul>
<h3 id="u5B9A_u671F_u4E3B_u52A8_u548C_u65B0_u4EBA_u8BA8_u8BBA_u4ED6_u9047_u5230_u7684_u95EE_u9898"><a href="#u5B9A_u671F_u4E3B_u52A8_u548C_u65B0_u4EBA_u8BA8_u8BBA_u4ED6_u9047_u5230_u7684_u95EE_u9898" class="headerlink" title="定期主动和新人讨论他遇到的问题"></a>定期主动和新人讨论他遇到的问题</h3><p>建议新人在入职的头一两周可以使用这个办法。比如每天晚上 6 点半，在吃饭前用半小时，让新人把当天学习积累的问题和你讨论。</p>
<p>固定时间做固定的事情，一来使得你被他打断地次数减少，二来也使得他有机会把任何疑问都提出来。</p>
<h3 id="Code_Review"><a href="#Code_Review" class="headerlink" title="Code Review"></a>Code Review</h3><p>基本上刚入职的新人都会有 Code Style 的问题，刚开始的几次 Code Review，我们要首先解决 Code Style 问题。如果新人犯错，可以提供相关的 wiki 或代码风格资料给他，甚至和他进行代码风格的一些讨论，分享一些故事，让他对代码风格产生重视。一个合格的 Mentor 应该让新人在最多三次 Code Review 之后，就能够改正掉几乎所有的代码风格问题。</p>
<p>如果新人对代码风格有不同意见，可以组织一些学习讨论会，也可以在吃饭的时候叫上几个资深一些的同事一起分享这方面的经验。切忌不能只是用强力纠正，而没有让新人产生真正重视代码风格的意识。</p>
<p>在 Code Style 保证的同时，我们还需要让新人了解我们的各种编码约定，例如接口如何定义，目录如何安排，注释的原则，Commit Log 的约定等等。这方面也需要有 wiki 供新人学习。</p>
<p>Code Review 的最难部分，我们需要审核新人的架构和逻辑是否有问题，这方面花费的精力将非常多。对于有问题的架构，和新人的讨论也将花费大量时间。但是这就是新人成长的过程，对于他来说是非常重要的经历。</p>
<p>另外，让新人同时 Review 自己的代码，是一个非常好的学习方式，新人可以模仿和学习到一些好的架构和代码风格习惯。</p>
<h3 id="u6B63_u786E_u7684_u5B66_u4E60_u65B9_u5F0F"><a href="#u6B63_u786E_u7684_u5B66_u4E60_u65B9_u5F0F" class="headerlink" title="正确的学习方式"></a>正确的学习方式</h3><p>部分新人可能对于使用英文查找资料，使用 Google 存在一些障碍。我们应该需要纠正他们不使用百度，不使用中文来进行资料查找，否则对他们知识获取将会有很大的影响。</p>
<p>我们还应该分享一些自己常常学习和提高的方式，推荐一些博客、论坛和社区给新人，让新人学会我们的学习方式。</p>
<h3 id="u63A8_u8350_u5B66_u4E60_u8D44_u6599"><a href="#u63A8_u8350_u5B66_u4E60_u8D44_u6599" class="headerlink" title="推荐学习资料"></a>推荐学习资料</h3><p>在培养一段时间后，你可能就会发现新人在某一些方面的知识有所欠缺，但是显示我们把这些知识系统地讲一遍是不太现实的。我们应该推荐一些相关的书籍给他们，鼓励他们用闲暇的时间来阅读。时不时问问他们学习的进度，或者让他们分享一些学习的体会，都是不错的 PUSH 他们提高的技巧。</p>
<h2 id="u6388_u6743"><a href="#u6388_u6743" class="headerlink" title="授权"></a>授权</h2><p>当你发现新人已经成长起来后，可以尝试将自己熟悉的，同时重要的功能交给他来完成，而你自己做一些其它工作（根据实际情况，可以是更简单的工作，或者是更难的工作）。</p>
<p>这样做的好处是：</p>
<ul>
<li>新人可以借此得到更大的锻炼。</li>
<li>你因为对相关功能很熟悉，所以也能有效地进行指导和监督，控制代码质量和风险。</li>
</ul>
<p>将自己熟悉并且重要的工作交给别人，通常是比较难受的，因为一般人都希望保证效率，而自己因为熟悉，所以效率肯定是最高的。但是长远来看，对于 Mentor 来说，自己也需要成长，将自己擅长的事情交给别人，可以让自己跳出舒适区，尝试更难的事情。这么来看，对 Mentor 自己也是非常有利的。</p>
<h2 id="u56DE_u987E"><a href="#u56DE_u987E" class="headerlink" title="回顾"></a>回顾</h2><p>不管如何用心，刚开始指导新人的时候，总还是会有一些做得不尽人意的地方。Mentor 应该对自己的指导过程有一些总结和回顾，然后总结一些心得，这样在指导下一个新同事的时候，就会做得更加出色。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>在和新人建立良好友谊的基础上，我们需要努力培养他们，并且把这件事情当作最高优先级的事情。具体要做的事情包括：</p>
<ul>
<li>定期主动和新人讨论他遇到的问题</li>
<li>Code Review</li>
<li>教会他正确的学习方式</li>
<li>推荐学习资料</li>
<li>授权给他有挑战的，并且自己熟悉的工作</li>
<li>带完一个新人后，回顾一下自己的工作，看看有哪些值得改进的地方</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/mentor-guide.jpg">
<h1 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h1><p>本文希望帮助 Mentor 在]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[猿题库从 Objective-C 到 Swift 的迁移]]></title>
    <link href="http://blog.devtang.com/2016/05/24/migrate-from-oc-to-swift/"/>
    <id>http://blog.devtang.com/2016/05/24/migrate-from-oc-to-swift/</id>
    <published>2016-05-24T14:15:31.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><p>相信没有人会怀疑，Swift 是 iOS 开发未来的主流语言，但是由于 Swift 语言的不断变化以及庞大的迁移成本，真正把项目迁移到 Swift 语言的公司并不多。而猿题库 iOS 客户端是一个超过 3 年的项目，积累了超过 15 万行的 Objective-C 代码，我相信它在迁移过程中的经验对很多人有所帮助。</p>
<p>蓝晨钰（@晨钰Lancy）是猿题库 iOS 客户端的负责人，他主导了猿题库 iOS 客户端从 Objective-C 到 Swift 的迁移工作。同时他在实践 Swift 的过程中，总结了不少心得，这次他将会在 GMTC 大会上分享这方面的话题，以下是我对他的采访，希望对大家有帮助。</p>
<h3 id="u63D0_u95EE"><a href="#u63D0_u95EE" class="headerlink" title="提问"></a>提问</h3><blockquote>
<p>问题：向读者简单介绍一下自己吧。</p>
</blockquote>
<p>我叫蓝晨钰，iOS 开发者，11 年开始接触 iOS 开发，13 年加入猿题库负责 iOS 客户端开发工作，和猿题库一起经历了从无到拥有数千万用户的成长，和我的团队一起完成了数十个版本的迭代。</p>
<p>我从 14 年底 Apple 发布 Swift 语言开始一直关注和学习其知识理念，并在 15 年初在公司推广和实践 Swift 项目，至今在生产环境实践 Swift 已经超过一年，算是有比较丰富的移动客户端开发经验和 Swift 编程经验吧。个人对 Swift 语言的持乐观态度，在公司内积极推进 Swift 语言的实践，也非常享受 Swift 的编程体验。</p>
<blockquote>
<p>问题：听说你这次打算在 GMTC 上分享的话题是：《当泛型遇上协议 —— Generic Programming with Protcol in Swift》，能简单介绍一下为什么选这个主题吗？</p>
</blockquote>
<p>泛型编程和面向协议编程都是 Objective-C 语言所没有的特性，作为一个老 iOS 开发者来说，当我第一次接触它们时，我的内心是激动的，我迫不及待的想知道，这些个新特性新技术，会给我们的程序和开发带来怎么样的变化。而经过我们团队的不断学习和实践，我们也的确在这当中找到了很多乐趣，积累了不少经验，我希望能通过这次分享讲它们分享给更多人。</p>
<blockquote>
<p>问题：你怎么看待泛型编程和面向协议编程在客户端编程的未来？</p>
</blockquote>
<p>泛型编程是许多现代语言所有的特性，在其他语言的实践经验告诉我们，泛型是一个强大的工具，经常能有效的提高编程效率和提高代码的复用程度。面向协议编程则是由 Swift 提出的编程范式，强大的表达力和抽象能力，毫无疑问会变成一项重要工具。而这两者的结合则是一种全新的体验，这也是我这次分享的一个重要部分。</p>
<p>同时，由于 Swift 语言缺乏类似 objc runtime 的机制，我认为泛型编程和面向协议编程作为实现之前 runtime 所实现功能的替代，将越来越成为 iOS 开发者需要掌握的重要技能。</p>
<blockquote>
<p>问题：猿题库当前对 Swift 的使用到什么程度？已经完全迁移到 Swift 了吗？</p>
</blockquote>
<p>猿题库有两个客户端项目，分别是老师端和学生端，他们都是 Swift 和 Objective-C 混编的项目，并没有完全迁移到 Swift。其中猿题库老师端是在 Swift 发布之后不久启动的项目，我们在这个项目中开始推行 Swift 语言，所以这个项目是一个 Swift 语言为主的项目，Objective-C 部分主要为复用旧代码。</p>
<p>而猿题库学生端是我们的主项目，这个项目从 iOS 5 时代开始，一直使用 Objective-C 编写，直到近期 Swift 升到 2.x 之后，我们认为 Swift 已经足够成熟，并且我们在老师端中积累了足够的经验后才开始向 Swift 迁移的。目前学生端的项目中，大部分还是 Objective-C 语言实现，但新实现的页面和功能基本都使用 Swift 语言来编写。</p>
<blockquote>
<p>问题：你认为猿题库大概还需要多长时间能够完全迁移到 Swift?</p>
</blockquote>
<p>事实上，在生产环境中，几乎没有人愿意在收益甚微的情况下把 Objective-C  代码重写一次，因为重写意味着大量的研发资源和测试资源的消耗，而这基本不会产生实际意义上的产品收益。另外 Apple 在 Swift 和 Objective-C 的桥接上做了相当多的努力，大部分情况下，我们都可以不太费力的在 Swift 中复用 Objective-C 代码。</p>
<p>所以大部分公司的策略都会是新功能用 Swift 语言实现，旧功能先维持现状，等到产品变动或是架构变动的时候再使用 Swift 语言实现，这也是猿题库所采用的策略。所以我想短时间内不太可能完全迁移到 Swift 吧。如果非要说一个时间的话，我推测大约一年之后大部分业务应该会迁移到 Swift，而整个项目彻底迁移恐怕就需要两到三年以上了。</p>
<blockquote>
<p>问题：你认为 Swift 什么时候能够达到 ABI 稳定？</p>
</blockquote>
<p>老实说，我也不知道。Swift 的发展很快，我这次主题要讲的泛型相关的实践，在 Swift 1.x 的时候就没法实现。Swift 项目组的 Chris Lattner 也公开表示 Swfit 3.0 不会达到 ABI 稳定并且会缺少一些重要的泛型功能。我们只能期待在 Swift 3.x 或 Swift 4 的时候会有惊喜吧。</p>
<blockquote>
<p>问题：对比 Swift 和 Objective-C，你觉得 Swift 最大的优势是什么？</p>
</blockquote>
<p>Swift 的优势有很多，我比较喜欢的有几点：更安全的类型，代表更少的 Bug 和更低的崩溃率；更简洁的语法，代表更少的代码和更快的编程速度；强大的函数式、泛型、协议等特性，代表更能发挥程序员的想象力。选一个的话，我选最后一个，强大的特性给了我很大的编程愉悦感。</p>
<blockquote>
<p>问题：对于从 Objective-C 迁移到 Swift，你有遇到什么值得分享的坑吗？</p>
</blockquote>
<p>从 Objective-C 迁移到 Swift 代表着在很长一段时间内都是处于混编的状态，这里我认为最重要的经验是一定要有一个迁移的规范和指南来约束开发团队哪些部分需要迁移 Swift 而哪些部分不要，接口应该如何设计才能兼顾混编调用。举个例子，由于 Swift 调用 Objective-C 是方便的可靠的，反之则有许多的限制，所以设计接口的时候，需要考虑这个模块会不会被 Objective-C 调用，如果是的话，应该避免使用 Swift 语言的特性，又或是制定一套规则，来 Swift 语言的接口如何转成 Objective-C 兼容的接口。</p>
<blockquote>
<p>问题：对于学习 Swift，你有什么推荐的方法或资料吗？</p>
</blockquote>
<p>iBooks 上有 Apple 推出的 Swift Programming 系列书籍是所有 iOS 开发者的必读和参考书目。iTunes U 上有 Stanford 的 Developing iOS  Apps with Swift，讲师是 Apple 工程师 Paul Hegarty，推荐新入门的 iOS 开发者学习。</p>
<p>Objc.io 上的 Advanced Swift 是我最近在读的书，内容绝对对得起 Advanced 这个词，推荐有一定基础 Swift 开发者阅读。此外 Github 上有大量的 Swift 开源项目，可以阅读源码来学习。</p>
<p>最后，也是最重要的，多写，多想，实践是最好的学习方式。</p>
<blockquote>
<p>问题：你对今年 WWDC 有什么期待吗？</p>
</blockquote>
<p>最大的期望是能去一次 WWDC（笑），可惜我们公司每年到 6 月高考的时候就是最忙的时候，所以这个愿望只能等以后了。对 WWDC 本身的话，期望 Apple 能弄出一些新东西，比如我很看好的虚拟现实相关的产品和技术。</p>
<p>另外希望 Apple 能加快 Swift 的推进，比如发布与 Google 合作推进 Swift 语言在 Android 客户端的应用之类。</p>
<p>全文完。</p>
<h3 id="u5E7F_u544A"><a href="#u5E7F_u544A" class="headerlink" title="广告"></a>广告</h3><p>由 InfoQ主办的GMTC全球移动技术大会将于6月24日在北京召开。来自BAT、携程、滴滴和社区的技术专家联袂分享，主题包括应用架构、性能优化、动态化、插件化、Swift、React Native、Weex等。本周移动大会8折最后一周，我的粉丝本周前20人报名享受6折1080的优惠呦，手慢无！手慢无！<br>优惠码：GMTC-TangQiao</p>
<p>购票链接：<a href="http://www.bagevent.com/event/27886?bag_track=tangqiao" target="_blank" rel="external">http://www.bagevent.com/event/27886?bag_track=tangqiao</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><p>相信没有人会怀疑，Swift 是 iOS 开发未来的主流语言，但是由于 Swift 语言的不断变化以及庞]]>
    </summary>
    
      <category term="Interview" scheme="http://blog.devtang.com/tags/Interview/"/>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（六）- 类型推断]]></title>
    <link href="http://blog.devtang.com/2016/05/22/swift-gym-6-type-infer/"/>
    <id>http://blog.devtang.com/2016/05/22/swift-gym-6-type-infer/</id>
    <published>2016-05-22T05:46:26.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<p>前几天，一个朋友在微博上通过私信问了我一个问题，如下的代码，为什么变量 <code>crr</code> 没能把值为 nil 的元素过滤掉？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr:[Int?] = [1, 2, 3, nil, 4, 5]&#10;let brr = arr.flatMap &#123; $0 &#125;&#10;brr&#10;// brr = [1, 2, 3, 4, 5]&#10;&#10;let crr:[Int?] = arr.flatMap &#123; $0 &#125;&#10;crr&#10;// crr = [&#123;Some 1&#125;, &#123;Some 2&#125;, &#123;Some 3&#125;, nil, &#123;Some 4&#125;, &#123;Some 5&#125;]</span><br></pre></td></tr></table></figure>
<p>简单来看，同样是使用 <code>flatMap</code> 函数，brr 变量成功过滤掉了值为 nil 的元素，变量 crr 过滤失败。而 brr 和 crr 的区别就是它们的类型不一样，brr 的类型是 <code>[Int]</code> ，而 crr 的类型是 <code>[Int?]</code>，想必其中原因与此有关，那到底是为什么呢？</p>
<p>在和一些朋友讨论之后，我大概想明白了，这和类型推断有关系。在 crr 相关的代码中，因为 crr 的类型已经被程序员指定为 <code>[Int?]</code>，所以为了编译通过，编译器需要推断出 <code>flatMap</code> 中的闭包的输入和输出变量类型。我们回顾一下 <code>flatMap</code> 在数据中的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension SequenceType &#123;&#10;    public func flatMap&#60;T&#62;(@noescape transform: (Self.Generator.Element) throws -&#62; T?)&#10;                rethrows -&#62; [T]&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，flatMap 返回的结果是 <code>[T]</code>，而闭包 transform 返回的结果是 <code>T?</code>。而在 crr 这个例子中，T 被推断出是 <code>Int?</code> , 因此 tranform 中 <code>T?</code> 就被代入，变成了 <code>(Int?)?</code> 。所以，如果完善一下上面例子的代码，编译器推断出来的类型是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let crr:[Int?] = arr.flatMap &#123;&#10;    (element: Int?) -&#62; (Int?)? in&#10;    return element&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里，返回的变量 element 其实类型并不是 <code>(Int?)?</code>，但是 Optional 是有 conversion 的方法，允许将一个类型的 <code>S</code> 的变量，自动转成 <code>S?</code>，所以转换被自动做了，并没有编译错误发生。</p>
<p>怎么改这个代码呢？</p>
<p>有人说把闭包的类型手工指定成 <code>Int?</code>，我试了一下，确实能够正常了，不过我感觉这更像是一个编译器的 Bug，我们再看看这个接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension SequenceType &#123;&#10;    public func flatMap&#60;T&#62;(@noescape transform: (Self.Generator.Element) throws -&#62; T?)&#10;                rethrows -&#62; [T]&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>按照 <code>flatMap</code> 的接口定义，如果闭包返回的是 Int?，那么按照这个定义，最终 <code>flatMap</code> 的结果就必须是 <code>[Int]</code>，而我们要强制要求结果是 <code>[Int?]</code>，除非这里有自动的转换，否则就应该编译失败。而我自己的试验代码失败，确认出并没有从 [Int] 到 <code>[Int?]</code> 的自动转换。所以我暂时认为这么改能正常工作是一个编译器的 Bug（如有错误，欢迎指出）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: cannot convert value of type &#39;[Int]&#39; to specified type &#39;[Int?]&#39;</span><br></pre></td></tr></table></figure>
<p>另外，也有朋友说，在这种场景下并不应该使用 <code>flatMap</code> 函数。确实是这样，flatMap 函数本来就有着 flat 的作用在里面，在数组的 <code>flatMap</code> 实现中，有两个重载：</p>
<ul>
<li>一个重载版本是为了打平嵌套的多维数据。</li>
<li>另一个重载版本，就是我们刚刚讨论的版本，flat 是为了去掉 Optional 的封包，同时把 nil 元素去掉。</li>
</ul>
<p>而这个示例代码调用了 <code>flatMap</code> 函数，却希望仍然得到 Optional 的数组，实在是不应该使用 <code>flatMap</code> 来做这个事情。如果只是为了去掉 Optional 中的 nil 元素，使用 <code>filter</code> 方法可能更为合适一些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;let arr:[Int?] = [1, 2, 3, nil, 4, 5]&#10;let drr:[Int?] = arr.filter &#123;&#10;    if let _ = $0 &#123;&#10;        return true&#10;    &#125; else &#123;&#10;        return false&#10;    &#125;&#10;&#125;&#10;drr&#10;// drr = [&#123;Some 1&#125;, &#123;Some 2&#125;, &#123;Some 3&#125;, &#123;Some 4&#125;, &#123;Some 5&#125;]</span><br></pre></td></tr></table></figure>
<p>其实函数式编程的方法不止 <code>map</code>, <code>flatMap</code>, <code>filter</code> 这些，在一个名为 <a href="http://reactivex.io/" target="_blank" rel="external">reactiveX</a> 的网站上，列举了 Reactive 编程实践下的一些 <a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="external">常见的函数</a>，里面的很多方法都挺有意思，这些方法也被实现在了 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a> 中，感兴趣的同学可以看看。</p>
<p>祝玩得开心！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天，一个朋友在微博上通过私信问了我一个问题，如下的代码，为什么变量 <code>crr</code> 没能把值为 nil 的元素过滤掉？</p>
<figure class="highlight plain"><table><tr><td class="code"><p]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[济州岛旅游见闻]]></title>
    <link href="http://blog.devtang.com/2016/05/08/jeju-island-tour/"/>
    <id>http://blog.devtang.com/2016/05/08/jeju-island-tour/</id>
    <published>2016-05-08T13:44:12.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>公司五一节给大家放了九天假，于是和家人去了一趟济州岛，记录一些见闻。</p>
<h2 id="u4E71_u6253_u79C0"><a href="#u4E71_u6253_u79C0" class="headerlink" title="乱打秀"></a>乱打秀</h2><img src="/images/nanta-show.jpg">
<p>在观看乱打秀之前，我以为乱打秀就是一种利用各种厨房炊具进行音乐打击演奏的表演。看完之后，我才发现乱打秀其实是一种混合了多种表演形式的艺术混合体。</p>
<p>乱打秀的核心内容是音乐，在表演中，演员会利用各种厨房乐器来进行各种有节奏感的打击。但是如果只是听打击乐声的话，演出难免单调，所以乱打秀在打击音乐的同时，又混入了很多别的表演元素。</p>
<p>首先混入的是不少杂技的表演内容。例如：在奔跑中翻跟头、相互之间非常快速地扔盘子、背对篮筐投篮、耍双截棍以及打斗等等。这些杂技类的元素对于演员的身体素质和协调性要求非常高，现场能够看出女演员的腹肌和手臂肌肉非常结实。乱打秀的故事场景是在厨房，所以还有一些关于刀功的杂技元素，其中一个环节大家比拼切菜的功力，整个表演演员用锋利的菜刀切出各种效果，看得让人心惊动魄。</p>
<p>然后混入的是魔术元素。包括一个把酒瓶变没的魔术，以及一个丝巾变棍子的魔术，现场还利用灯效配合演员做出蜡烛灭掉和点亮的魔术。魔术元素虽然不多，但是因为观众事先并没有预期，所以看到时还挺意外的，有一点惊喜。</p>
<p>接着混入的是小品的元素。整个乱打秀融入在一个紧张的烹饪任务的故事情节中，随着剧情地发展，观众会不自觉地融入到那种紧张的故事剧情中。</p>
<p>乱打秀还融入了大量与观众的互动，这些互动有一些非常深入，已经本身成为了演出的一部分。其中有一个环节是邀请几个观众上台参与包饺子，然后突然演员们都快闪离场了，留下几个观众尴尬地不知所措，现场观众笑翻天了。另外还有一个环节是演员邀请观众和他一起打拍子，演员故意用生气地表演来表示对观众的配合不满意，然后学大家各种搞笑的动作，非常有意思。</p>
<h2 id="u7535_u52A8_u6C7D_u8F66"><a href="#u7535_u52A8_u6C7D_u8F66" class="headerlink" title="电动汽车"></a>电动汽车</h2><p>济州岛的景点离得都比较远，所以一般自由行都需要包车。这次包车的时候，我发现我们乘坐的竟然是一辆新能源电动汽车，进一步了解到，济州岛政府都在推广电动汽车。</p>
<img src="/images/sumsang-car.jpg">
<p>我们乘坐的电动汽车是三星旗下的（如上图），在国内完全搜索不到。与国内不同的是，三星的这款电动汽车快充和慢充是共用一个充电口。另外听司机说，快充充满电只需要 20 分钟，满电可以开 100 多公里，听起来还是非常夸张的。可惜在网上搜不到这款车的中文资料。</p>
<h2 id="u7269_u4EF7"><a href="#u7269_u4EF7" class="headerlink" title="物价"></a>物价</h2><p>济州岛的物价整体还是比北京还是要高一些，吃一碗当地的猪肉面，最少是 7000 韩元，折换成人民币大概 40 多块钱。如果不吃面，人均 80 元左右吧。出租车的话，起价 2800 韩元（约 17 元人民币）。当地的特产橘子，长得有点像国内的丑橘，但是便宜的也要 2000 韩元一个（约 10 元人民币）。</p>
<p>济州岛的海产品非常丰富，按理说海产应该比较便宜对吧？但是也不是，一个当地产的带鱼，好一点的要 6 万韩元一公斤（约 180 元人民币一斤）。</p>
<h2 id="u996E_u98DF"><a href="#u996E_u98DF" class="headerlink" title="饮食"></a>饮食</h2><p>济州岛在古代其实是流放之地，物资比较匮乏。所以济州岛上其实没有什么特别好吃的东西。当地有名的食物，无非就是：猪肉面，参鸡汤，烤黑猪肉，海鲜锅，炸鸡。</p>
<p>从这些食物上可以感受到当地蔬菜匮乏，我个人对参鸡汤的评价还可以，烤肉的话，其实北京的味道一点也不比当地的差。</p>
<h2 id="u514D_u7A0E_u8D2D_u7269"><a href="#u514D_u7A0E_u8D2D_u7269" class="headerlink" title="免税购物"></a>免税购物</h2><p>济州岛为了吸引外国人（其实主要就是中国人）前来旅游，专门有大型的免税店：新罗免税店和乐天免税店。在相关购买流程上，政府做了很多优化的工作。比如在新罗免税店，我们可以直接刷支付宝、微信支付以及银联卡。</p>
<img src="/images/jeju-mall.jpg">
<p>我还记得大概 5 年前来济州岛购物的时候，每件商品都还需要填一个退税申请，然后跑到机场相应的窗口办理退税。但是这一次，我们在一家叫 eMart 的可退税超市，超市的收银机可以直接刷护照，然后将税金当场免去，购物体验相当棒。</p>
<p>免税购物和免签证应该是济州岛吸引中国游客的大杀器，基本上到处都是中国人，各种商店也都有中文导购。</p>
<h2 id="u5929_u6C14"><a href="#u5929_u6C14" class="headerlink" title="天气"></a>天气</h2><p>济州岛有三多：石多、风多、女人多。我们去的第二天就赶上了接近 9 级的大风。基本上大风夹着一些雨水，使得室外的旅游完全无法进行了，还好有很多室内的观光景点可以游玩，不然还是挺遗憾的。济州岛最佳的旅游时间其实是秋季，我们上次来旅游就是那个时节，完全没有大风。</p>
<h2 id="u672A_u6765"><a href="#u672A_u6765" class="headerlink" title="未来"></a>未来</h2><p>济州岛近年来因为旅游火爆，整体物价和房价都涨了很多，不知道这对当地居民来说是祸是福。</p>
<p>这次了解到有很多租车公司提供济州岛自驾服务，车子上还专门有中文的导航，只需要有国际护照即可，希望如果下次带来，能够试一试。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>公司五一节给大家放了九天假，于是和家人去了一趟济州岛，记录一些见闻。</p>
<h2 id="u4E71]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SwiftCon 期间的面基和八卦]]></title>
    <link href="http://blog.devtang.com/2016/05/07/swiftcon-2016-chat-notes/"/>
    <id>http://blog.devtang.com/2016/05/07/swiftcon-2016-chat-notes/</id>
    <published>2016-05-06T16:01:37.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/swiftcon-friends.jpg">
<p>4 月 23 - 24 日，我参加了上海的 <a href="http://www.swiftconchina.com/" target="_blank" rel="external">SwiftCon</a> 大会。有一些人说参加会议主要就是混圈子，也有一些人说参加会议主要是了为听干货，还有一些人在微博上投票，到底我们应该听干货还是去混圈子。好吧，不能都做吗？一次会议演讲嘉宾的质量固然重要，但是一次会议天然地把一群相同趣味的人聚集到了一起，不乘机好好认识一下扯扯蛋聊聊天，多可惜呀。</p>
<p>我这次去上海参会，不但听了很多有意思的分享，私下也见了特别多朋友。和这些朋友面基聊天，很是开心，一些讨论也很有感触，一并记录一下。</p>
<p>本文主要记录聊天扯蛋方面的感受，如果要看技术方面的总结，可以移步到 <a href="/2016/04/25/swiftcon-2016-notes/">《SwiftCon 2016 参会感想》</a>。</p>
<h2 id="tinyfool__26amp_3B__u788E_u6708_u6210_u661F"><a href="#tinyfool__26amp_3B__u788E_u6708_u6210_u661F" class="headerlink" title="tinyfool &amp; 碎月成星"></a>tinyfool &amp; 碎月成星</h2><p>tinyfool 是我面基的第一个人。那天是大会正式开始前一天的下午，我们约在一家咖啡馆聊天。一同来的还有大会的组织者锅巴，触控科技的廖宇雷，tiny 公司的 CTO 碎月成星（陈勇辉）。</p>
<p>第一感受就是，tiny 是一个非常健谈的人。我们几个人在那儿聊天，基本上将近一半的表达时间都被 tiny 霸占了。不过我是那种特别容易冷场的人，所以有一个人不停地叨叨，反倒感觉特别舒服，我只需要听着就可以了。</p>
<p>tiny 的思路转换得特别快，基本上给他一个话题，他就可以一直发散下去，各种观点听起来也挺有意思。我们聊在线教育，聊招人，聊 Remote 的工作方式，聊雾霾，聊创业，聊学习和成长，还有各种八卦。也许是聊得太多吧，好多观点也没能记住。tiny 说他创业做不下去了，打算把公司关了找工作，这一点在第二天的大会演讲中他也提到了。</p>
<p>还记得的就是各种 tiny 和碎月成星的趣事，这两个人的性格就像冰与火一样处在两个极端，碎月成星是那种极度内向的人，但是他们却能够一起合作经营公司。我也私下八卦了一下 tiny 的小女朋友的故事，就不给大家说了，哈哈，祝他们早日成婚。</p>
<p>聊天时，碎月成星讲了一个非常有意思的笑话，现场听他讲完，感觉他也是那种人混熟之后，话也能讲很多的人。</p>
<h2 id="u9505_u5DF4__26amp_3B__u6273_u5B50"><a href="#u9505_u5DF4__26amp_3B__u6273_u5B50" class="headerlink" title="锅巴 &amp; 扳子"></a>锅巴 &amp; 扳子</h2><p>锅巴在忙完大会的一些琐事后，赶过来加入了我和 tiny 的聊天。从锅巴那儿，我了解到这次大会基本上由他和扳子两个人完成，他们都有固定的工作，这种会议是完全民间的行为。锅巴说，之前办 PHP 相关的大会很成功，现在 Swift 语言刚刚兴起，没有人办过，所以就决定办一场。</p>
<p>相比今年年初在北京的 <a href="http://atswift.io/" target="_blank" rel="external">atSwift</a> 大会，锅巴的这次 SwiftCon 大会是两天的时间，时间更长（atSwift 大会是一天），场地租金更贵（atSwift 大会是租的学校的会场），而且锅巴考虑到有很多是外地的嘉宾和参会者，所以选择的会场离机场特别近，这也一定程度上增加了办会的成本。</p>
<p>锅巴私下和我聊的时候说到，他们之前甚至打算亏本办这场大会，不过聊天中我问他卖票情况，他说还比较理想，我估计应该是没有亏本的。办会不亏本应该是非常好的事情，这样才能使得大家有动力持续改进会议质量。锅巴还是一个特别大度的人，他们这次还邀请了算是「竞争对手」的梁杰的 atSwift 大会组委会成员，并且为他们提供了免费的展台。</p>
<p>当然，聊天少不了八卦，锅巴提到关于股票的高频交易一些趣事，很有意思，涉及一些敏感信息就不给大家说了，哈哈。</p>
<h2 id="u5434_u67EF_u7476"><a href="#u5434_u67EF_u7476" class="headerlink" title="吴柯瑶"></a>吴柯瑶</h2><p>吴柯瑶是一个性格外向活泼的美女，从非技术工作转而做 iOS 开发，没有参加培训班，自己一点一点成长起来。她在找工作的时候，因为是女生，遭遇了更多的挑战。本来她找 tinyfool 想让他帮忙推荐，tinyfool 做了一个非常明智的决定，tinyfool 说：「你先找，自己试试看，不行再说」。结果，瑶瑶最后凭自己的能力找到了 iOS 开发的工作，这件事情 tiny 做得太赞了，因为它让瑶瑶获得了相当大的自信心。</p>
<p>这次大会吴柯瑶是主持人，在大会中午休息的时候，瑶瑶分享了一段自己成长的经历，不知道有多少人认真听了，我感觉她的成长过程对于大家的启发或许更多。</p>
<p>和瑶瑶聊天八卦的主要是她以前当模特的故事，嗯，详细的也不给大家说了，哈哈。</p>
<h2 id="u5085_u82E5_u611A__26amp_3B__u65B9_u5FD7_u521A"><a href="#u5085_u82E5_u611A__26amp_3B__u65B9_u5FD7_u521A" class="headerlink" title="傅若愚 &amp; 方志刚"></a>傅若愚 &amp; 方志刚</h2><p>大会第一天结束后，我和 ThoughtWorks 的几个朋友（傅若愚、方志刚、小灰灰）一起去撸串。他们给我介绍了很多关于这家公司的趣事。小灰灰其实是前 ThoughtWorks 员工，现在在 SegmentFault 做市场运营相关的工作。</p>
<p>ThoughtWorks 以前在我眼中总是很神秘，这次和他们聊天，更进一步从各种故事中了解了这家公司。和别的偏咨询的业务不太一样，ThoughtWorks 在移动开发领域，整体上业务还是侧重「外包」开发的工作较多。</p>
<p>在和他们聊天的过程中，我才发现 ThoughtWorks 是在 iOS 开发中，也实践成功了 TDD 的公司。而这一点，其实做到的互联网公司非常少。在我之前的认知中，因为移动开发的单元测试能够覆盖的代码极其有限，加上移动开发中的功能模块（特别是上层的界面和交互逻辑）在快速迭代中反复更改，我认为 TDD 并不适合在移动开发领域。ThoughtWorks 的故事让我再次对自己的观点产生了动摇。</p>
<p>进一步了解到，ThoughtWorks 的一个 App 的业务逻辑，可能由超过 10 个人来完成，另外 ThoughtWorks 的员工也可能分布在不同的城市，他们需要更解耦地工作和协调，而这个时候，TDD 成为一个很简单有效的方式。ThoughtWorks 接的 App 开发的单子，本身也不太可能像移动互联网公司那样，两周发一个版本来快速迭代。综合起来，在移动开发中引入 TDD，或许适合这样的场景：</p>
<ul>
<li>App 开发人员超过 10 人，并且大家代码相互依赖</li>
<li>App 开发人员异地协同工作</li>
<li>App 的迭代周期不算特别频繁</li>
<li>App 的质量非常重要</li>
</ul>
<p>小灰灰还提到，ThoughtWorks 这家公司还有一个比较独特的地方，就是创始人不完全以赢利为目的来经营公司，比如他们会接一些明显亏本的、但是公益性的项目，比如在一些第三世界国家，帮助当地的政府开发一些信息系统。整体 ThoughtWorks 中国区还是很挣钱的，但是补贴给了不少国外的亏本项目。</p>
<p>ThoughtWorks 另外一个文化，就是大量招聘新人，大部分员工都是工作 1-3 年的，使用新人的首要原因其实是因为便宜，ThoughtWorks 在整体互联网行业中给付的薪水并不高，所以使用新人可以使得他们能够控制住成本。同时，ThoughtWorks 还是比较有技术追求的，他们公司内部有一些行业资深的大牛可以指导这些新人，于是那些有潜力的新人，能够得到快速地项目锻炼和恰当的指导，于是快速成长。小灰灰说，有一些新人，刚进公司，就要去给那些年纪比他大十几岁的客户做敏捷咨询，那种压力是巨大的，相对来说成长也是巨大的。</p>
<p>但是，终究 ThoughtWorks 这种模式下，能够到达金字塔顶端的人是少数，所以大部分员工在工作几年之后，能力成长起来了，就会选择跳槽。拿小灰灰的话说：「薪资 double 是至少的，能力强的能够 triple」。</p>
<p>其实对于 ThoughtWorks 来说，这其实是「双赢」的。为什么人离职了还是「双赢」呢？因为 ThoughtWorks 还是留住了少量最最精英的人到达金字塔的顶端，同时 ThoughtWorks 以非常小的人力成本，保证了它能够完成项目，公司能够正常经营。那些离开 ThoughtWorks 的人，在公司经历了历练和成长，何尝不会感恩公司，他们在别的公司做得好，反倒会正面宣传 ThoughtWorks 的技术影响力。</p>
<p>我有一次听到一个类似的故事，四大会计事务也是大量招募新人，很多重要的项目，用老人带新人的方式开展工作，那些新人拿着非常低的薪水，但是工作压力特别大，但是通常三年之后，这些新人成长起来，离职都能够找到非常好的新工作。而少量留下来的四大老员工，又继续着这种老人带新人的模式。</p>
<p>某种程度上，这就是一种商业模式，这些公司选择用低薪 + 成长空间，来吸引应届毕业生，同时获得商业收益，虽然人员不停流动，但是公司依然能够经营得很好。</p>
<h2 id="u9648_u4E58_u65B9"><a href="#u9648_u4E58_u65B9" class="headerlink" title="陈乘方"></a>陈乘方</h2><p>因为陈乘方所在的公司雇佣了图拉鼎，以 Remote 的方式为 ENJOY 工作过。所以我找他聊天时，首先请教了一下在以 Remote 的方式合作时，有哪些注意事项。陈乘方提到最好 Remote 的工作内容还是比较确定，不太会变的产品方案，因为远程修改产品细节将涉及大量的沟通工作，这样效率会非常低下。</p>
<p>陈乘方也介绍了一些远程工作的实践，比如在微信群里面，用微信语音来开每天早上的站会，方便大家沟通上一天的进度和当天的安排。我相信这里面的实践技巧还有很多，因为时间关系，我也没有详细了解。</p>
<h2 id="LYcHEE"><a href="#LYcHEE" class="headerlink" title="LYcHEE"></a>LYcHEE</h2><p>这次去上海，我还专门见了荔枝软件的 LYcHEE。LYcHEE 一直在努力推广正版的 Mac 软件，他经营的 <a href="https://sbcwangka.taobao.com/" target="_blank" rel="external">小店</a> 虽然没挣多少钱，但是也够他日常的生活开销。我之前和他合作推广过 Charles 和 Reveal，都非常愉快。</p>
<p>LYcHEE 的 <a href="https://sbcwangka.taobao.com/" target="_blank" rel="external">淘宝小店</a> 的模式是，和国外的正版软件谈合作，然后一次性地下单购买几百个 License，然后再销售。通常为了保证软件是正版的，这些 License 都是正版软件官方网站购买的兑换码，这样可以保证购买人的注册信息都是兑换时生效的。LYcHEE 的风险其实也来源于这种模式，因为这些 License 都是批量采购，一旦没有卖到一定数量，他就会面临亏本。</p>
<p>和 LYcHEE 聊天，我发现他是一个非常自律的人，因为他自己开淘宝店，所以每天上班的地方就在家里。他会每天早上固定的时间起床，然后健身，然后工作，中午和晚上也会有固定时间休息。我特别佩服这种自律性强的人，LYcHEE 个子很高，整个人看起来非常精神，由于长期健身，身体有明显的肌肉线条，非常帅。</p>
<p>他的淘宝店的客服，也全部都是远程办公的方式在协作。这种 Remote 的方式和图拉鼎的 Remote 有很大的差别，因为客服的 PKI 很好制定，也非常有效（比如回答量，响应时间等），所以 LYcHEE 只需要定好 PKI，就可以很好地管理这些客服的工作了。而淘宝的卖家平台也很方便地提供了这些 PKI 指标。</p>
<p>如果你长期使用 Mac 电脑，以后买正版软件之前，建议都可以去 LYcHEE 的 <a href="https://sbcwangka.taobao.com/" target="_blank" rel="external">淘宝小店</a> 先搜一下，基本上如果有正版的话，都是网上能够买到的最低价了。</p>
<p>另外，LYcHEE 私下告诉我，他在卖正版的 Mac 软件之余，计划再做一些更大的事情，期待着他的新产品发布。</p>
<p>嗯，顺便还见到了 LYcHEE 的女朋友，祝早日成婚～</p>
<h2 id="u6C64_u5723_u7F61"><a href="#u6C64_u5723_u7F61" class="headerlink" title="汤圣罡"></a>汤圣罡</h2><p>汤哥一直是我眼中的全才，运维、开发、设计通吃，这次终于有机会见到了他真人。汤哥性格非常内向，另外感觉有一些固执，对事情有着自己的看法，不太容易说服他，哈哈。</p>
<p>汤哥一直强调会场的凳子坐着屁股疼，到大会第二天中午，马上轮到我分享前，汤哥说屁股实在坐不住了，要走了。吓得我赶紧抽中午的时间，把下午的分享提前给他讲了一遍。但是，结果到大会分享结束前，汤哥都没有走！汤哥不但又听了一遍我的分享，还把傅若愚的分享也听完了才走。我对此表示，以后再也不相信汤哥的屁股会疼了。</p>
<p>关于汤哥的八卦，嗯，汤哥给我讲了讲他们家那边的做相亲 O2O 的大妈，实在是非常有趣，如果你见到了他，一定得让他讲一讲。</p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>每次参加各种技术大会，我都会挑几个感兴趣的主题，认真听演讲嘉宾的分享，然后别的时间，我就会到处找朋友聊天八卦。我想这才是参加技术大会正确的姿势，没人说你一定需要坐在凳子上一直听到「屁股疼」，对吧？</p>
<p>希望明年的 SwiftCon 大会，能够见更多的新朋友，听更多的八卦和趣闻。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/swiftcon-friends.jpg">
<p>4 月 23 - 24 日，我参加了上海的 <a href="http://www.swiftconchina.com/" target="_blank" rel="external">Swi]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SwiftCon 2016 参会感想]]></title>
    <link href="http://blog.devtang.com/2016/04/25/swiftcon-2016-notes/"/>
    <id>http://blog.devtang.com/2016/04/25/swiftcon-2016-notes/</id>
    <published>2016-04-24T16:10:53.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<p>4 月 23 - 24 日，我参加了由 Think 技术社区举办的 <a href="http://www.swiftconchina.com/" target="_blank" rel="external">SwiftCon</a> 大会。这次大会见到了很多新老朋友，也从嘉宾的分享中学习了很多，微博上对于此次大会也有一些争议，一并写个参会感想，分享一下我的观点。</p>
<h2 id="u5206_u4EAB_u7B14_u8BB0"><a href="#u5206_u4EAB_u7B14_u8BB0" class="headerlink" title="分享笔记"></a>分享笔记</h2><p>首先分享一下我两天听分享的收获。</p>
<h3 id="u4E00_u4E2A_Swift__u9879_u76EE_u7684_u7F51_u7EDC_u5C42_u53D8_u8FC1_u2014_u2014_u9648_u4E58_u65B9"><a href="#u4E00_u4E2A_Swift__u9879_u76EE_u7684_u7F51_u7EDC_u5C42_u53D8_u8FC1_u2014_u2014_u9648_u4E58_u65B9" class="headerlink" title="一个 Swift 项目的网络层变迁——陈乘方"></a>一个 Swift 项目的网络层变迁——陈乘方</h3><p>陈乘方负责开发 ENJOY 这个 App，ENJOY 是一个比美团和点评更「上档次」的美食推荐和团购应用。而 ENJOY 是一个由纯 Swift 语言开发出来的 App。陈乘方的这次分享中，我感受到了大家 ENJOY 这个项目对于 Swift 新特性的接受和演进过程。</p>
<p>大家刚开始写 Swift 项目的时候，都是把 Objective-C 翻译成 Swift，那个时候，虽然我们用的语言是 Swift，但是我们的思维方式还是 Objective-C 的，所以，陈乘方首先介绍了在项目演进过程中，大家对于 Swift 新特性的引入，从而带来编码方式的变革过程。</p>
<p>他们使用枚举、范型、以及 protocol extension 作为第一个演进版本，使得自己的项目更加 Swift 化。</p>
<p>接着第二个演进版本，他们将 AFNetworking 进行了替换，改成了 Alamofire。比较关键的一点，他们把成功和失败的双回调，合并成 <code>completion</code> 单回调，所以就产生了 <code>APIResult</code> 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum APIResult&#60;T&#62; &#123;&#10;   case Success(T)&#10;   case Failure(NSError, AnyObject?)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这种改进是更加 Swift 化的尝试，因为 <code>APIResult</code> 这种保存网络结果的方式，是一种对数据的封装，可以更加方便地使用 <code>map</code> 和 <code>flatMap</code> 进行链式调用。</p>
<p>最后一个演进版本，他们：</p>
<ul>
<li>用 ObjectMapper 代替了 Mantle</li>
<li>去掉命名前缀</li>
<li>用 Struct 类型的 Model</li>
<li>尽可能减少 optional 的 Model 属性</li>
<li>为 APIResult 增加了 map 和 flatMap 方法</li>
</ul>
<p>整个演进过程中，我能感受到他们对于 Swift 的最佳实践也是一步一步摸索得更加清晰。除了总结性的介绍外，陈乘方在演讲的后半部分，还以一个具体的 API 请求为例，展示代码的整个生成过程，让我更加清晰地理解了他们的应用架构方式。</p>
<p>这个主题分享非常适合那些刚刚迁移到 Swift 语言的新项目，他们可以从中吸取到宝贵的实践经验。</p>
<p>最后恭喜 ENJOY 获得了 3000 万美元的新一轮融资，以及陈乘方本人抽中了今年 WWDC 的门票，ENJOY 公司会报销陈乘方参加 WWDC 的全部费用，真是良心公司，大家投简历去吧，哈哈。</p>
<h3 id="Objective-C__u548C_Swift__u7684_u8DE8_u5E73_u53F0_u5F00_u53D1_u2014_u2014Tinyfool"><a href="#Objective-C__u548C_Swift__u7684_u8DE8_u5E73_u53F0_u5F00_u53D1_u2014_u2014Tinyfool" class="headerlink" title="Objective-C 和 Swift 的跨平台开发——Tinyfool"></a>Objective-C 和 Swift 的跨平台开发——Tinyfool</h3><p>tinyfool 的这个分享我很早以前听过，当时应该是在网上看的他参加博览网的分享，分享地址 <a href="http://boolan.com/lecture/1000001076" target="_blank" rel="external">在这里</a>，当时他分享的主题是《如何把 iOS 代码编译为 Android 应用》。这次分享的题目虽然不一样，但实质内容是一样的。</p>
<p>这其实是一个非常有技术含量的事情，tinyfool 基本上把他们要做的事情讲了，但是并没有深入到细节讲怎么做。这其实是完全能够理解的，因为这些细节讲起来会非常碎，在场的人也很难有谁有这方面的需求做同样的事情。所以基本上，这件事情大家了解他是如何着手计划和实施的，就可以了。</p>
<p>不过这场分享，很多人表达出不满意。我想 tiny 如果抛出两个技术细节，让大家玩味一下会更有意思一些。</p>
<h3 id="u9006_u5411_u5DE5_u7A0B_uFF1A_u4ECE_Objective-C__u5230_Swift_u2014_u2014_u5305_u6DB5_u537F"><a href="#u9006_u5411_u5DE5_u7A0B_uFF1A_u4ECE_Objective-C__u5230_Swift_u2014_u2014_u5305_u6DB5_u537F" class="headerlink" title="逆向工程：从 Objective-C 到 Swift——包涵卿"></a>逆向工程：从 Objective-C 到 Swift——包涵卿</h3><p>这个分享非常对我的味口，因为我一直对 iOS 安全非常关心。</p>
<p>包涵卿在演讲中，介绍了他使用 Hopper Disassembler， IDA Pro， otool, class-dump 逆向分析 Objective-C 和 Swift 的编译后代码。其中涉及的技术细节都非常有意思。</p>
<p>例如 Non Fragile Layout，这种编译方案，使得父类增加成量变量，不会影响子类的二进制代码运行。这样，苹果就可以在新的 iOS 操作系统中，默默地升级 NSObject，UIView 和 UIViewController 这些大家都会继承的父类的成员变量，而不会影响原有的代码运行。这个技术细节感觉国内并没有多少人是真正理解清楚的。</p>
<p>关于这个，我记得王晓磊给我的公众号投稿过一篇名为 <a href="https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=206233994&amp;idx=1&amp;sn=1d3379abb1cec9306d40efc38910434e&amp;scene=1&amp;srcid=0424ZMkiur8yL1FDeGxrzT9X&amp;key=b28b03434249256bd1853e2fbc502b1a9a19b062d66276afd7aa2c9ab2dc68c0e8368c260f4345ffbf461be0b77510bf&amp;ascene=0&amp;uin=NDU1NzA2MTk1&amp;devicetype=iMac+MacBookAir" target="_blank" rel="external">Objective-C 类成员变量深度剖析</a> 的文章，也对这个特性做了详细的分析。</p>
<p>包涵卿还介绍了 Swift-String 的内部实现，通过介绍它的大小是是 24 字节，一步步分析，最后还原出原来是它有一个 _core 的变量，类型是一个 _StringCore 结构。这个结构里面有三个变量：_baseAddress, _countAndFlags, _owner。</p>
<p>包涵卿接着介绍了 Swift-Demangle 的细节，一个 Swift Protocol 的指针大小是 40 字节的逆向分析。</p>
<p>包涵卿介绍了一个超有用的分析命令<code>ima lookup -a &lt;address&gt;</code> ，可以查对应地址可能是什么对象，有这个命令之后，在分析对象组成的时候，就方便很多了。</p>
<p>最后，我了解到 protocol witness，它是一个类似 C++ 的虚方法表的实现，这让我理解了 Swift 对 Protocol 的实现方式。</p>
<h3 id="u62E5_u62B1_Swift_3-0__u4E0E_u672A_u6765_u5C55_u671B_u2014_u2014_u56FE_u62C9_u9F0E"><a href="#u62E5_u62B1_Swift_3-0__u4E0E_u672A_u6765_u5C55_u671B_u2014_u2014_u56FE_u62C9_u9F0E" class="headerlink" title="拥抱 Swift 3.0 与未来展望——图拉鼎"></a>拥抱 Swift 3.0 与未来展望——图拉鼎</h3><p>图拉鼎是奇点和 Manico 的作者，也以 Remote 的方式为 ENJOY 工作过。</p>
<p>图拉鼎的这次分享，首先介绍了 Swift 3.0 的目标：</p>
<ul>
<li>ABI 稳定</li>
<li>跨平台</li>
<li>Package Manager</li>
</ul>
<p>接着，他分享了 Swift 2.2 在语言演进上的变化，包括：selector、keyPath、去 Objective-C 化、标准化命名、参数化命名、废除 IUO 。</p>
<p>这些语言变化对我都很有帮助，特别是标准化命名这一点，方法名加 ed 结尾统一表示返回新的对象，例如：sort 是在原数组排序，sorted 是返回的是新数组。类似的还有 reversed, enumerated 等。这种命名方式设计是非常舒服的，而我之前并没有注意到这一点。</p>
<p>废除 IUO（Implicityly Unwrapped Optional） 这一点对我启发也很大，我们了解到苹果对于语言的演进过程，其实就能理解哪些是好的设计，哪些是不好的设计。</p>
<p>最后，图拉鼎介绍了 Swift 未来的 <a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">演进方向</a>：</p>
<ul>
<li>SE-0025: Scoped Access Level</li>
<li>SE-0038: Package Manager C Language Target Support</li>
<li>SE-0048: Generic type alias</li>
</ul>
<p>对此，我最大的收获是知道了原来可以 <a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">从这里</a> 看苹果对于 Swift 语言未来的规划，相信我以后会常常到这里翻翻，看看苹果是如何做计划的。</p>
<p>图拉鼎还介绍了一个好的学习平台，IBM 的 Swift sandbox: <a href="https://swiftlang.ng.bluemix.net" target="_blank" rel="external">https://swiftlang.ng.bluemix.net</a>，听他说这个平台更新非常及时，可以方便我们实验 Swift 的新特性。</p>
<h3 id="Redux_in_Swift_u2014_u2014_u65B0_u4E00_u4EE3_u7684_iOS__u5E94_u7528_u67B6_u6784_u2014_u2014_u65B9_u5FD7_u521A"><a href="#Redux_in_Swift_u2014_u2014_u65B0_u4E00_u4EE3_u7684_iOS__u5E94_u7528_u67B6_u6784_u2014_u2014_u65B9_u5FD7_u521A" class="headerlink" title="Redux in Swift——新一代的 iOS 应用架构——方志刚"></a>Redux in Swift——新一代的 iOS 应用架构——方志刚</h3><p>方志刚自己在 playground 上做了一个用于演讲的程序，可以播放 PPT + 看代码，而且你知道吗？这是他在第一天演讲的现场撸出来的。真是后生可畏啊！</p>
<p>在这个分享中，方志刚分享了一个小众的、新颖的架构方案：Redux。在介绍完架构后，方志刚直接上代码，带着我们一步一步演示如果用 Redux 开发出一个 TODO 的应用。Redux 优点：好测，简单，可缓存，时光倒退模式这些都让人感觉耳目一新。</p>
<p>但是，我最大的收获倒不是这个框架本身。我相信一个新的框架肯定也会有各种各样的问题，我最大的收获是方志刚在介绍如何把这个框架改造成支持异步的时候，提出了一个 Inverse Of Control 的方案：把 dispatch 反转控制，交给异步的线程来回调。</p>
<p>我不知道未来我是否会有类似的设计架构的需求，如果我以后也有改造现有框架，让它支持异步的方案时，我应该会仔细评估方志刚的这种设计方式，还是挺有意思的。</p>
<h3 id="How_to_parse_float_numbers_-_the_really_hard_way_u2014_u2014_u5085_u82E5_u611A"><a href="#How_to_parse_float_numbers_-_the_really_hard_way_u2014_u2014_u5085_u82E5_u611A" class="headerlink" title="How to parse float numbers - the really hard way——傅若愚"></a>How to parse float numbers - the really hard way——傅若愚</h3><p>每次听傅若愚的分享，我都有智商被碾压的感觉，不过每次回头再仔细学习他的 keynote，我总是会收获很多。其实我的 Swift 烧脑系列文章，有几篇都是在傅若愚的演讲中得到的启发。</p>
<p>这次我听到他一下子定义了大量操作，将 Monad, Application 和 Functor 都实现并且应用在浮点数转换中时，我又知道我得会后再下功夫了。</p>
<p>其实傅若愚也明白这一点，他将所有的讲稿和代码都放到了 <a href="https://github.com/lingoer/SwiftyCharms" target="_blank" rel="external">GitHub</a> 上，大家可以自行学习。</p>
<h3 id="u8BFB_Swift__u6E90_u7801_uFF0C_u7406_u89E3_Monad_u2014_u2014_u5510_u5DE7"><a href="#u8BFB_Swift__u6E90_u7801_uFF0C_u7406_u89E3_Monad_u2014_u2014_u5510_u5DE7" class="headerlink" title="读 Swift 源码，理解 Monad——唐巧"></a>读 Swift 源码，理解 Monad——唐巧</h3><p>我自己的分享，主办方把我放在中午饭之后，让我压力山大，为了让大家不睡着，我带大家一起伸了懒腰，是的，我们大会所有人一起举起双手伸了一个大懒腰。然后，我结合《引爆点》这本书，给大家讲了一个段子：「如何成为 iOS 大 V」。</p>
<p>热场大概花了 10 分钟吧，然后就进入正题讲 Monad。整体语速还是有点稍快，现场没有提词器，我不得不时不时回头，对观众还是挺不友好的。最后演讲完，我让听懂的同学举手，现场大概有一半的同学举手表示懂了。</p>
<p>我自己学习 Monad 大概断断续续花了一年时间，能够在 40 分钟内让现场有一半的同学听懂，我认为值了。这场演讲是我准备得最多次数的演讲，在正式演讲前，我一共讲了五次（一次给 Lancy，一次公司内部分享，一次给 T 线下沙龙，一次给南京软件技术大会，一次给汤圣罡），也是我认为最有挑战的演讲内容吧，整体来说，我给自己打 90 分。</p>
<p>没听懂的同学，对不住了，我已经尽力了。如果你没听懂，建议再学习一下相关的资料：<a href="http://t.cn/Rq4fwJk" target="_blank" rel="external">http://t.cn/Rq4fwJk</a>、<a href="http://t.cn/Rqp3GiW" target="_blank" rel="external">http://t.cn/Rqp3GiW</a>、<a href="http://t.cn/RL5pYwM" target="_blank" rel="external">http://t.cn/RL5pYwM</a></p>
<h2 id="u5176_u5B83"><a href="#u5176_u5B83" class="headerlink" title="其它"></a>其它</h2><p>以上几个分享，是我认真听了，并且觉得非常值得总结的。除此之外，由于我和会场的朋友聊天，错过了「从数学函数角度理解函数式编程——丁峰」，「Swift 语言的设计取舍及跨语言调用——董一凡」，「Asynchronous Programming in Swift，Swift 异步编程——刘冠杉」这三个分享，所以无法总结。</p>
<p>「Swift 设计模式——老镇 (曾伟) 」这个分享我听了，我觉得稍微有一些问题，因为老镇只是把这些设计模式一一介绍，其实这样并不是很有效。作为分享，还不如选一两个点，结合 Swift 的源码来理解，可能更好一些。不过老镇对这次分享准备得非常认真，写了一万多字的讲稿，举了大量武侠的例子，没能深入也蛮可惜的。我感觉还是他经验太少，在内容组织上没有经验，期待他以后会演讲得更好。</p>
<h2 id="u5173_u4E8E_u5BF9_u4F1A_u8BAE_u7684_u8BA8_u8BBA"><a href="#u5173_u4E8E_u5BF9_u4F1A_u8BAE_u7684_u8BA8_u8BBA" class="headerlink" title="关于对会议的讨论"></a>关于对会议的讨论</h2><p>从昨天开始，twitter 和 微博上就有人开始喷这次 SwiftCon 会议，我感觉实在犯不着，因为这次大会有相当多的内容都是精心准备的，如果有一两场不合你的胃口，也不用攻击整场会议。这次 SwiftCon 会议的分享内容，在我以上总结到的分享，都是高质量的，而这些总结，已经覆盖了超过半数的分享议题了。如果你仅仅拿一两场的分享说事，明显犯了以点盖面的错误。如果有谁觉得不对，建议也能够详细指出每一场分享到底水在哪里，让讨论能够更加客观和公正。</p>
<p>另外，微博上发泄或者互喷是相当浪费时间的，有这个时间还是看看技术文章，看看开源代码吧。整个互联网圈子已经够乱了，我还是希望我们 iOS 圈子能够少一些偏激，多一些心平气和的讨论。</p>
<p>最后，我要说，这次会议其实是非赢利的，首先所有讲师都没有报酬的。我从锅巴和板子那里了解到，所有的大会志愿者，也是没有任何劳务报酬的，大会的主持吴柯瑶（其实她是一个 iOS 开发者）也是没有任何报酬的。那为什么要收门票呢？因为分享的场地设备得花钱，外地讲师的路费和住宿费得花钱，所以这些钱需要通过门票来补贴。</p>
<p>如果你能理解这是一个完全民间的团体，组织的一次非赢利性的大会，他们都是本着做事和分享的态度来做这个会议，那么我相信你的心态会更加宽容一些。这是上海有史以来的第一次 Swift 大会，所有人都希望它办成功，这个过程中有什么不如意的，我们改进就行了，没有那么不可原谅的。</p>
<p>愿大家开心～</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>4 月 23 - 24 日，我参加了由 Think 技术社区举办的 <a href="http://www.swiftconchina.com/" target="_blank" rel="external">SwiftCon</a> 大会。这次大会见到了很多新老朋友，也从]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊聊 WWDC 的八卦]]></title>
    <link href="http://blog.devtang.com/2016/04/19/talk-about-wwdc-2016/"/>
    <id>http://blog.devtang.com/2016/04/19/talk-about-wwdc-2016/</id>
    <published>2016-04-19T13:34:22.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/wwdc-2016.jpg">
<p>就在今天，苹果对外公布了 WWDC 2016 即将举办的消息，具体的举办时间是 6 月 13 日 - 17 日。我虽然从来没有去过 WWDC，但是我的个人提高和 WWDC 是密切相关的。</p>
<p>了解我的朋友都知道，我曾经说过，我是一个视觉型的学习者，所以我在刚刚初学 iOS 的时候，选择了斯坦福的视频课程。而我在入门之后，理所当然地选择了看 WWDC 视频作为我的进一步提高的方法。</p>
<p>由于 iOS 开发在快速发展，每年苹果都会给我们带来很多新的知识。而对于这些知识，第一手的资料就是 WWDC 的视频。通常情况下，一个 iOS 开发的新知识首先会在 WWDC 上被苹果公开，然后 3 个月左右，会有国内外的博客介绍这些知识，再过半年左右，会有国外的图书介绍这些知识。所以如果想尽早地了解这些知识，那么只有通过 WWDC 的视频。</p>
<p>在 2014 年以前，这些视频只能在会议之后获得，但是从 2014 年开始，视频开始随着 WWDC 大会的进程，在会议过程中逐步放出，而且重要的视频会带有英文字幕。坚持阅读这些视频不但可以获得最新的 iOS 开发知识，还可以提高英文听力水平。</p>
<p>很多朋友说他英语听力不好，相信我，其实技术的文档和会议中使用的英语语法和单词都相当简单，你缺少的只是一个坚持一段时间的信心。我当时也是受制于国内资料太少，被逼无赖看的，但是「通过英文资料学习」这个能力一旦获得，你就停不下来了。</p>
<p>WWDC 在早年其实是通过抢票的方式来购买的，所以历年 WWDC 门票售卖期间，各个开发者都如临大敌，为了抢得一张近一万人民币的票，想尽各种办法。这种情型在 2013 年达到了巅峰，那个时候，门票开售仅仅 2 分钟，就销售一空（见下图）。</p>
<img src="/images/wwdc-2013.jpg">
<p>这种情况至到 2014 年改成「摇号」的方式，才得到改变。苹果也意识到 WWDC 对开发者的吸引力太大，于是将视频尽量早地放出。</p>
<p>最近，苹果甚至给去年的 WWDC 视频都补上了中文字幕，不过说回来，字幕里面把 「Tim Cook」 翻译成 「提姆厨师」真的不是开玩笑吗？反正看了一眼这个字幕，我心中升起了「比更大还大」(Biger than biger）的无奈，乖乖切回了英文字幕。</p>
<img src="/images/tim-cook.jpg">
<img src="/images/trans-2.jpg">
<p>我没有去过 WWDC，作为一个 iOS 开发者，我一直希望有一天能够去那个圣地学习一番。不过门票和来回的机票和住宿还是让我的钱包压力山大。所以我一直很羡慕那些公司能够报销参加 WWDC 大会的开发者。如果你在这样的公司，欢迎留言告诉我，我会把留言精选出来，让大家围观羡慕的。我也希望猿题库公司成长到一定阶段之后，也能给优秀的员工这样的福利。</p>
<p>今年的 WWDC 能有什么期待呢？除了例行的 iOS 升级大版本之外，我猜估计就是 Swift 3.0 的推出吧，不过也可能苹果留了一手给我们再次带来惊喜。</p>
<p>或许期待本身，就是一件美妙的事情吧，让我们拭目以待。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/wwdc-2016.jpg">
<p>就在今天，苹果对外公布了 WWDC 2016 即将举办的消息，具体的举办时间是 6 月 13 日 - 17 日。我虽然从来没有去过 WWDC，但是我的个人提高和 WWDC 是密切相关的。</p>
<p>了解]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《把时间当做朋友》：一本关于心智的启蒙书]]></title>
    <link href="http://blog.devtang.com/2016/04/19/control-yourself/"/>
    <id>http://blog.devtang.com/2016/04/19/control-yourself/</id>
    <published>2016-04-19T00:28:17.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img11.360buyimg.com/n1/g13/M06/11/0B/rBEhU1JgnwgIAAAAAAJx6QF6lj0AAER-QGFkaAAAnIB428.jpg" alt=""></p>
<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><p>很早以前就看了李笑来老师的<a href="http://item.jd.com/11338691.html" target="_blank" rel="external">《把时间当做朋友》</a>，最近终于整理完成了学习笔记。《把时间当做朋友》是一本老书，最初写于 2008 年，现在依然在售卖中。李笑来也将本书的 <a href="http://zhibimo.com/read/xiaolai/ba-shi-jian-dang-zuo-peng-you/index.html" target="_blank" rel="external">电子版</a> 公开到了网上，免费供读者下载。</p>
<p>本书的作者李笑来以前是新东方的英语老师，在比特币火爆之前，花 100 万买了比特币，我猜他现在应该是财务自由了。李笑来老师在投资比特币之余，展现出了强大的自学能力，自己学习了编程、设计并且作品都还不错，现在，他在学习社群的运营，并且创建了「学习学习再学习」微信公众号以及多个付费社群。</p>
<p>我看完《把时间当做朋友》之后，最大的感受是：这是一本关于心智的启蒙书。</p>
<p>关于心智的定义，我觉得李笑来在书中的定义稍显复杂。在我看来，所谓心智就是一种高层次的大脑控制技巧。这种高层次的大脑控制技巧主要包括两个部分：</p>
<ul>
<li>内在控制：控制自己的情绪。</li>
<li>外在控制：控制自己的行为。</li>
</ul>
<p>接下来，我会按照上面的理解，来将书本的内容重新梳理和介绍。</p>
<h2 id="u771F_u7684_u5B58_u5728_u9AD8_u5C42_u6B21_u7684_u5927_u8111_u63A7_u5236_u5417_uFF1F"><a href="#u771F_u7684_u5B58_u5728_u9AD8_u5C42_u6B21_u7684_u5927_u8111_u63A7_u5236_u5417_uFF1F" class="headerlink" title="真的存在高层次的大脑控制吗？"></a>真的存在高层次的大脑控制吗？</h2><p>理解心智，首先就得理解高层次的大脑控制的存在。那么，真的存在高层次的大脑控制吗？关于这个，作者在书中举了很多例子，我也给大家举几个我自己想到的例子。</p>
<h3 id="u6CE8_u610F_u529B_u8F6C_u79FB"><a href="#u6CE8_u610F_u529B_u8F6C_u79FB" class="headerlink" title="注意力转移"></a>注意力转移</h3><p>你是否有遇到过这种情况？你在看书，遇到一个不认识的单词，想查一下词典，于是你打开手机。刚刚解锁手机，你发现你的微信上有两个红点，于是你点进去，发现是你的死党发过来的搞笑视频。看了视频把你乐坏了，回了死党一段信息后。你发现微信朋友圈上有红点，于是你就点进去看朋友圈。等你把朋友圈刷完，你早已忘记了你本来在看书这件事情。</p>
<p>在上面这件事情中，你到底是被你的大脑控制，还是被各种外界信号刺激所控制呢？</p>
<h3 id="u60C5_u7EEA_u5931_u63A7"><a href="#u60C5_u7EEA_u5931_u63A7" class="headerlink" title="情绪失控"></a>情绪失控</h3><img src="/images/7sin.jpg">
<p>在电影 <a href="http://baike.baidu.com/subview/22021/7627734.htm" target="_blank" rel="external">《七宗罪》</a> 里（上图），有一个情节是连环杀人案凶手最后利用警员米尔斯的愤怒，让他无法控制自己的情绪，最终当着所有人的面，把凶手杀死。当然，最后等待米尔斯的是被押上警车以及职业生涯的断送。</p>
<p>在这件事情中，米尔斯不是被他的大脑控制，而是被愤怒的情绪所控制。《七宗罪》里面涉及的暴食、贪婪、懒惰、愤怒、骄傲、淫欲和嫉妒，这些情绪都会在某些场景下影响我们，使得我们的行为丧失理智。</p>
<h2 id="u5185_u5728_u63A7_u5236_uFF1A_u63A7_u5236_u81EA_u5DF1_u7684_u60C5_u7EEA"><a href="#u5185_u5728_u63A7_u5236_uFF1A_u63A7_u5236_u81EA_u5DF1_u7684_u60C5_u7EEA" class="headerlink" title="内在控制：控制自己的情绪"></a>内在控制：控制自己的情绪</h2><h3 id="u4E2A_u6027_u662F_u7531_u60C5_u7EEA_u548C_u7ECF_u5386_u5851_u9020_u7684"><a href="#u4E2A_u6027_u662F_u7531_u60C5_u7EEA_u548C_u7ECF_u5386_u5851_u9020_u7684" class="headerlink" title="个性是由情绪和经历塑造的"></a>个性是由情绪和经历塑造的</h3><p>情绪是我们生命重要的组成部分，很多时候，我们的性格和做事方式都是情绪在各种经历下的产物。我接触到的对此最好的阐述，就是电影 <a href="http://baike.baidu.com/item/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F" target="_blank" rel="external">《头脑特工队》</a> 了。顺便说一下，该片由皮克斯与迪士尼合作制作，在 2016 年 2 月，获得了第 88 届奥斯卡最佳动画长片奖。</p>
<img src="/images/insideout-movie.jpg">
<p>在电影《头脑特工队》（上图）中，主人公莱利的行为由五种情绪构成，这五种情绪是 “欢乐”、“恐惧”、“厌恶”、“悲伤”、“愤怒”。在这五种情绪相互影响下，莱利在小时候是一个有着外向，活泼，调皮性格的小女孩，但是随着她搬到新家，没有了朋友，她慢慢变得焦虑，厌恶身边的人，以前的性格被重新塑造。最终，她将自己的痛苦述说出来，使自己的压力得到释放，她的个性中的快乐成份融入了眼泪，使得她更加懂得珍惜。</p>
<h3 id="u63A7_u5236_u60C5_u7EEA"><a href="#u63A7_u5236_u60C5_u7EEA" class="headerlink" title="控制情绪"></a>控制情绪</h3><p>我们说控制自己的情绪，并不是指我们需要压抑所有的不好情绪，在《头脑特工队》中，主人公莱利就是因为过度压抑悲伤，使得自己无处释放压力，最终反倒被自己的愤怒情绪所控制。</p>
<p>所以，当我们说控制自己的情绪的时候，我们其实在说，我们应该为了获得长久的好情绪，而控制自己短期的坏情绪。</p>
<p>我老婆是学幼儿教育的，她给我讲过一个故事，幼儿教育学家为了研究小孩的自控能力，会做一个叫做 <a href="http://baike.baidu.com/link?url=8EKV-tjzMsKQFVnSnr1Ar3VWf8iCbKTdvH1AZHJXzWcBPJO38hQZd12cKIbrjgQIgjl-tmqPhfR4Z8oFPjcpXK" target="_blank" rel="external">延迟满足</a> 的实验。这个实验（<a href="https://www.youtube.com/watch?v=Yo4WF3cSd9Q" target="_blank" rel="external">相关视频</a>）是这样的：</p>
<blockquote>
<p>在一个屋子里面，让小孩坐在一个书桌前，然后给小孩一个糖果，告诉他：「我 15 分钟后回来，如果你在我回来之前都不吃这个糖果，等我回来后就再奖励你一个糖果」。</p>
<p>通常情况下，很多小孩都无法抵抗糖果的诱惑而很快将它吃掉。而研究发现，那些坚持到最后的小孩，自控能力更强，在随后的跟踪研究发现，这些小孩能够在学校取得更好的学习成绩。</p>
</blockquote>
<p>最后，研究人员发现，这些小孩都会非常简单的一招：转移注意力。具体来说，他们会在特别想吃糖果的时候，选择做别的事情来让自己大脑暂时不那么关注糖果。比如他们可能会唱歌，在桌子上写字，将头转向窗外。</p>
<p>所以，在这个故事中，小孩为了获得「得到两个糖果的奖励」这种喜悦的情绪，通过转移注意力的方式，暂时压抑了自己短期「想吃这个糖果」的欲望。</p>
<p>我们在生活中，也在不断地重复着这种事情。当我们工资不高的时候，看到一个想买的东西，我们会理性地压抑自己的购物欲望，为的是这个月不至于交不起房租或者饿肚子。当我们在高三时，我们每天都学习得很辛苦，但是我们会控制自己的压力，为的是高考时能够考出更好的成绩。当我们和别人起冲突时，我们会控制自己想打人的冲动，为的是自己不至于在警察局待上几天。</p>
<p>中国有句古训：「忍一时风平浪静，退一步海阔天空」。其实意思就是我们应该为长久的好情绪，控制自己短期的坏情绪。而这种推迟满足感的能力，就是一种高层次的大脑控制技巧。</p>
<h2 id="u63A7_u5236_u60C5_u7EEA_u7684_u6280_u5DE7"><a href="#u63A7_u5236_u60C5_u7EEA_u7684_u6280_u5DE7" class="headerlink" title="控制情绪的技巧"></a>控制情绪的技巧</h2><p>下面是我总结出来的控制情绪的具体技巧。（注：我将这些技巧在《把时间当做朋友》书中的对应章节，以章名 + 小节名的方式附在每个技巧标题后面，例如 3.2 节表示：第 3 章第 2 节。）</p>
<h3 id="u8F6C_u79FB_u6CE8_u610F_u529B_uFF08_u7B2C_2-4__u8282_uFF09"><a href="#u8F6C_u79FB_u6CE8_u610F_u529B_uFF08_u7B2C_2-4__u8282_uFF09" class="headerlink" title="转移注意力（第 2.4 节）"></a>转移注意力（第 2.4 节）</h3><p>刚刚上面小孩抵抗糖果的诱惑的实验其实已经提到了这种技巧，这种技巧的核心在于，对于一些坏情绪或者痛苦的体验，我们不去想它，那么它的影响就会大大降低。小孩通过简单的把头转向窗外想别的事情，就可以让糖果的诱惑力对大脑的影响大大降低。</p>
<p>类似的场景还包括，当你特别不高兴的时候，找一些你平时喜欢做的事情，甚至简单地让自己做一些事情（比如运动）都可以极大的转移掉你对于糟糕情绪的关注。</p>
<h3 id="u63A8_u8FDF_u6EE1_u8DB3_u611F_uFF08_u7B2C_2-5__u8282_uFF09"><a href="#u63A8_u8FDF_u6EE1_u8DB3_u611F_uFF08_u7B2C_2-5__u8282_uFF09" class="headerlink" title="推迟满足感（第 2.5 节）"></a>推迟满足感（第 2.5 节）</h3><p>人总是倾向于立刻获得满足，如果完成一件事情的满足感来自未来的某一个时间，那么这就需要大脑的控制了。推迟满足感与转移注意力的差别在于，推迟满足感明明知道当前的行为让自己有些难受，但是仍然控制大脑做这件事情。</p>
<p>我最近在学习两个新技能，一个是学自由泳，一个是学骑独轮的思维车。这两个技能的获得过程都是痛苦的。我在学自由泳的时候，由于身体还没有对动作产生记忆，所以身体非常不协调，稍微不小心就呛水了。但是我会明白这是学会游泳的必经过程，所以坚持学下去，以便我在未来的某个时间，可以获得「学会自由泳」带来的喜悦和成就感。</p>
<p>学自由泳是一个很容易达到推迟满足感的例子。真实生活中，有着更多更难做到的事情，需要我们控制好情绪。</p>
<p>在《把时间当做朋友》的书中，作者就举了一个很难的事情：背下 GRE 要求的 2 万个单词。因为 2 万个单词实在太多，所以这件事情必须经过一个相当长的时间才能完成，即使一天背 100 个单词，也需要连续 200 天才能完成，而坚持做这件事情 200 天的难度非常大。</p>
<p>虽然所有人都能理解这个道理，但是真正能坚持做下来的人少之又少，后面我会分享坚持的一些技巧。</p>
<h2 id="u5916_u5728_u63A7_u5236_uFF1A_u63A7_u5236_u81EA_u5DF1_u7684_u884C_u4E3A"><a href="#u5916_u5728_u63A7_u5236_uFF1A_u63A7_u5236_u81EA_u5DF1_u7684_u884C_u4E3A" class="headerlink" title="外在控制：控制自己的行为"></a>外在控制：控制自己的行为</h2><p>我们对情绪的控制，最终反映出来的结果就对自己行为的控制。外在的行为控制表现出来有各种实践技巧，在本书中，用了大量篇幅进行了介绍。下面我们来一一看看这些技巧包括哪些。</p>
<h3 id="u7CBE_u786E_u611F_u77E5_u65F6_u95F4_uFF08_u7B2C_2-3__u8282_uFF09"><a href="#u7CBE_u786E_u611F_u77E5_u65F6_u95F4_uFF08_u7B2C_2-3__u8282_uFF09" class="headerlink" title="精确感知时间（第 2.3 节）"></a>精确感知时间（第 2.3 节）</h3><p>控制行为的第一步是感知时间，这也是书名《把时间当做朋友》的由来。书中也提到《奇特的一生》，我对此书也刚好写过<a href="/2016/02/16/make-friend-with-time/">读书笔记</a>。时间是完成所有事情的基础资源，精确感知时间使得我们能够对时间资源的利用率显著提升。</p>
<h3 id="u7528_u7EB8_u7B14_u6765_u8BB0_u5F55_u65F6_u95F4_uFF0C_u4EE5_u53CA_u5177_u4F53_u7684_u6267_u884C_u6280_u5DE7_uFF08_u7B2C_3-2-3-5__u8282_uFF09"><a href="#u7528_u7EB8_u7B14_u6765_u8BB0_u5F55_u65F6_u95F4_uFF0C_u4EE5_u53CA_u5177_u4F53_u7684_u6267_u884C_u6280_u5DE7_uFF08_u7B2C_3-2-3-5__u8282_uFF09" class="headerlink" title="用纸笔来记录时间，以及具体的执行技巧（第 3.2-3.5 节）"></a>用纸笔来记录时间，以及具体的执行技巧（第 3.2-3.5 节）</h3><p>这部分的内容偏执行，详细讲解了如何用纸笔来记录时间，记录执行时间的技巧和总结方法。虽然李笑来老师在书中没有推荐「番茄工作法」，但是我觉得这部分的实践技巧和「番茄工作法」是能够相互配合使用的。关于「番茄工作法」，我也写过一篇<a href="/2016/04/12/tomato-time-management/">读书笔记</a>。</p>
<h3 id="u5408_u7406_u7684_u3001_u9002_u5EA6_u7684_u8BA1_u5212_uFF08_u7B2C_3-6__u8282_uFF09"><a href="#u5408_u7406_u7684_u3001_u9002_u5EA6_u7684_u8BA1_u5212_uFF08_u7B2C_3-6__u8282_uFF09" class="headerlink" title="合理的、适度的计划（第 3.6 节）"></a>合理的、适度的计划（第 3.6 节）</h3><p>避免过度看重计划的重要性，在打算做一些事情时，没有计划或者简单计划后的快速启动，比花费大量时间计划后再做要更好。比如说健身，与其说研究哪种健身运动更合适，倒不如今天开始就动起来。当然，笑来老师也提到，改变的事情需要快做决策，投资的事情需要慢做决策。</p>
<h3 id="u9605_u8BFB_uFF08_u7B2C_4-1__u8282_uFF09"><a href="#u9605_u8BFB_uFF08_u7B2C_4-1__u8282_uFF09" class="headerlink" title="阅读（第 4.1 节）"></a>阅读（第 4.1 节）</h3><p>阅读是持续获得新知识的技巧。不过我们更应该看重图书的阅读，同时应该压抑自己在社交网络（微博、微信朋友圈）上碎片时间的阅读。因为后者知识不但很碎片化，而且也不成系统，另外同时有很多毫无营养价值的鸡汤 / 假新闻存在。</p>
<p>关于阅读，我之前写过《如何阅读一本书》的<a href="/2016/01/17/how-to-read-a-book-summary/">读书笔记</a>，也推荐给大家。</p>
<h3 id="u5B66_u4F1A_u5982_u4F55_u5B66_u4E60_uFF08_u7B2C_4-2-4-4__u8282_uFF09"><a href="#u5B66_u4F1A_u5982_u4F55_u5B66_u4E60_uFF08_u7B2C_4-2-4-4__u8282_uFF09" class="headerlink" title="学会如何学习（第 4.2-4.4 节）"></a>学会如何学习（第 4.2-4.4 节）</h3><p>「学会如何学习」就是要掌握正确的获取新知识的方法。很多人问我 iOS 开发如何入门，如何提高，好象这些问题就应该通过问别人才能获得答案。但是我觉得，一个学习能力强的人，面对一个新领域的知识，他自己就会找到学习新知识的方法和提高技巧。</p>
<p>这其实就是一种自学能力。书中对于自学能力的解读（第 4.3 节）包括：</p>
<ul>
<li>阅读理解能力</li>
<li>检索能力</li>
<li>写作能力</li>
<li>实践能力</li>
<li>保持开放的心态</li>
<li>了解学习的进程</li>
</ul>
<p>在书中，笑来老师还提到的学习技巧包括：警惕自己的经验造成的「思维误区」，当我们面对不同观点时，常常自省一下，可能才有机会调整自己的认识。我们不光需要自省，同时也要不盲目信服权威和老师（第 4.4 节）。</p>
<p>另外，在判断知识正确的时候，掌握「正确的科学方法论」也非常重要。这一点在《如何阅读一本书》中也有涉及。我们在判断一个理论是否正确时，要考虑它的论点，论据以及推导过程。任何论据不对、论据不充分或者推导过程不严谨的观点，我们都应该加以小心。</p>
<p>在这方面，最应该小心的就是成功学鸡汤了(第 5.1 节），成功学鸡汤常常会犯论据不对或者推导过程不严谨的错误。</p>
<p>罗辑思维有一期节目批判中医，其中就指出了中医粉在为中医辩护中的各种逻辑上的错误，感兴趣的朋友可以翻来听听。</p>
<p>另外我最近和朋友讨论，也颠覆了我的一些观点，其中一个观点是：电动车一定是未来吗？我一直觉得是未来，但是我的这个朋友的观点让我发现了，我的论据还是有一些不充分的地方。</p>
<p>书中同时提到了《少有人走的路》，我还没阅读，稍后应该会补上阅读笔记。</p>
<h3 id="u6539_u53D8_u6001_u5EA6_uFF08_u7B2C_4-5__u8282_uFF09"><a href="#u6539_u53D8_u6001_u5EA6_uFF08_u7B2C_4-5__u8282_uFF09" class="headerlink" title="改变态度（第 4.5 节）"></a>改变态度（第 4.5 节）</h3><p>「改变态度」其实改变的是：思考问题的角度，从而让自己更舒服。</p>
<p>比如我本来 iOS 开发做得很成功，但是转而做管理之后，iOS 方面的技能基本上只能在业余时间提高了。对于此，我可以这么想：这么多年辛辛苦苦学习积累的 iOS 技能不能够派上用场上，慢慢还会忘掉，真是郁闷。但是，换一个角度，我还可以这么想：我在 iOS 方面已经很难提高了，但是我在管理方面还是一个菜鸟，人的一生能够同时经历程序员和管理者两个职业角度来学习，最终我如果能够在新的领域成长起来，何尝不是一件精彩的事情！</p>
<p>我们面对失败，面对困难，面对学习的态度，都可以通过换一个角度，找到更加积极的应对方式。如果你实在找不到角度，我给你出一个办法，你想象一下这个场景：你不是出身在中国，而是出生在非洲的一个平民窟里，你吃不饱，无法受到良好的教育，周围医疗环境糟糕，甚至连喝干净的水都是奢望。你再想想你现在的生活，是不是真的有那么糟糕。</p>
<h3 id="u5C0F_u5FC3_u300C_u6210_u529F_u5B66_u300D_uFF08_u7B2C_5__u7AE0_uFF09"><a href="#u5C0F_u5FC3_u300C_u6210_u529F_u5B66_u300D_uFF08_u7B2C_5__u7AE0_uFF09" class="headerlink" title="小心「成功学」（第 5 章）"></a>小心「成功学」（第 5 章）</h3><p>书中提到的技巧包括：</p>
<ul>
<li>拒绝鸡汤</li>
<li>拒绝简单地强调坚持</li>
<li>拒绝不合理的论证</li>
<li>过于强调自己的独一无二</li>
<li>过于强调人脉和圈子</li>
</ul>
<h3 id="u7406_u89E3_u548C_u63D0_u9AD8_u5B66_u4E60_u6548_u7387_uFF08_u7B2C_6-1-6-7__u8282_uFF09"><a href="#u7406_u89E3_u548C_u63D0_u9AD8_u5B66_u4E60_u6548_u7387_uFF08_u7B2C_6-1-6-7__u8282_uFF09" class="headerlink" title="理解和提高学习效率（第 6.1-6.7 节）"></a>理解和提高学习效率（第 6.1-6.7 节）</h3><p>学会：分割任务，坚持执行，保持合理节奏，不迟到。</p>
<h3 id="u4E0D_u8981_u6D6A_u8D39_u65F6_u95F4_u8BC1_u660E_u81EA_u5DF1_uFF08_u7B2C_6-8__u8282_uFF09"><a href="#u4E0D_u8981_u6D6A_u8D39_u65F6_u95F4_u8BC1_u660E_u81EA_u5DF1_uFF08_u7B2C_6-8__u8282_uFF09" class="headerlink" title="不要浪费时间证明自己（第 6.8 节）"></a>不要浪费时间证明自己（第 6.8 节）</h3><p>活在别人的世界里是很悲惨的，因为大多数时候，除了你特别好的朋友和亲人之外，别的人并不关心你是否过得开心。那些看不起你的人，那些批评你的人，只要不是友善的态度，大可不必回应，更不用证明自己。</p>
<p>我还记得，有一个人在我的公众号留言：「你 iOS 技术文章写得还行，但是非技术的东西写得很烂，麻烦以后别写了，浪费我的时间」。我看了之后，默默地把他拉入了黑名单。</p>
<p>你永远不可能让所有人喜欢你，你也永远无法和那些试图伤害你的人解释，总有一些人喜欢看你的笑话，看你出丑，对于这些人，无视他们的存在是最好的生活方式。实际上，他们的存在对于你确实一点价值也没有。</p>
<h3 id="u4E0D_u540E_u6094_uFF0C_u800C_u662F_u603B_u7ED3_uFF08_u7B2C_6-9__u8282_uFF09"><a href="#u4E0D_u540E_u6094_uFF0C_u800C_u662F_u603B_u7ED3_uFF08_u7B2C_6-9__u8282_uFF09" class="headerlink" title="不后悔，而是总结（第 6.9 节）"></a>不后悔，而是总结（第 6.9 节）</h3><p>这也是一种看问题的角度，当我们失败的时候，专注于总结而不是后悔才有可能让我们进步。</p>
<h3 id="u8010_u5FC3_uFF08_u7B2C_7-3__u8282_uFF09"><a href="#u8010_u5FC3_uFF08_u7B2C_7-3__u8282_uFF09" class="headerlink" title="耐心（第 7.3 节）"></a>耐心（第 7.3 节）</h3><p>耐心其实就是「推迟满足感」的外在表现，但是这件事情其实说起容易做起来难。笑来老师在本节中也没有说应该如何获得耐心。面对一个花费时间较长的工作，我知道的产生耐心的技巧包括：</p>
<ul>
<li>拆解任务，为自己的任务设立阶段性目标。以便从心理上感受到目标容易达成，同时可以更好地追踪进度。</li>
<li>每天用「番茄工作法」来安排当前的工作，使得自己能够聚焦当前的工作。</li>
<li>暗示自己工作时产生焦虑是正常的，所以尽力不去想工作量的事情。</li>
<li>当工作快要完成的时候，暗示自己快要成功了。</li>
<li>一开始就做好充分的估计和准备，不要盲目乐观，避免进度延后之后心理的落差。</li>
<li>通过固定时间和固定频率的工作，培养习惯让身体对任务的执行产生条件反射。</li>
<li>利用 10000 小时定理来鼓励自己。</li>
</ul>
<h3 id="u5176_u5B83"><a href="#u5176_u5B83" class="headerlink" title="其它"></a>其它</h3><p>书中还提到的技巧包括：培养记忆力（第 4.6 节）、不自卑（第 6.10 节）、不要简单地把时间都转换成金钱（第 6.11 节）、专注于当前的工作（第 6.12 节）、提前准备（第 7.1-2 节）</p>
<p>另外，我自己也有一些书中没有提到的一些心得。包括：</p>
<ul>
<li>自省：定期回顾与总结。形式可以是以年度总结、月度总结的方式，审视自己的行为是否有值得改进的地方。</li>
<li>培养好奇心。鼓励自己学习和探索新的事物。</li>
<li>培养习惯。刚刚也说到，习惯让自己对一些事情的坚持变得更加容易。</li>
<li>适度坚持。面对一些不确定收益的事情，不应该随意放弃。</li>
</ul>
<h2 id="u5FC3_u667A_u4E0E_u60C5_u5546_u7684_u5173_u7CFB"><a href="#u5FC3_u667A_u4E0E_u60C5_u5546_u7684_u5173_u7CFB" class="headerlink" title="心智与情商的关系"></a>心智与情商的关系</h2><p>如果说心智这个概念听起来如果比较新的话，那么 <a href="http://wapbaike.baidu.com/subview/305/15912412.htm" target="_blank" rel="external">情商</a> 就是一个历史悠久的概念了。我好奇地翻了一下情商的定义，包括五个部分：自我意识、控制情绪、自我激励、认知他人情绪和处理相互关系。</p>
<p>看完这个定义，我突然觉得，其实心智就是一部分的情商，包括：自我意识、控制情绪、自我激励。这部分主要是偏向于自我的控制。而情商的剩下部分：认知他人情绪和处理相互关系，主要偏向于社会交往能力。</p>
<p>所以说，看起来李笑来老师似乎搞了一个新概念，但是其实是把以前的情商理论，抽取出了一部分偏自我控制的部分，进行了归纳和总结。</p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>李笑来老师的<a href="http://item.jd.com/11338691.html" target="_blank" rel="external">《把时间当做朋友》</a>是一本关于心智的启蒙书，对于我们控制情绪和行为都具有不错的实践指导意义，本书的 <a href="http://zhibimo.com/read/xiaolai/ba-shi-jian-dang-zuo-peng-you/index.html" target="_blank" rel="external">电子版</a> 可以免费下载，推荐各位朋友阅读，早日开始自己的心智。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img11.360buyimg.com/n1/g13/M06/11/0B/rBEhU1JgnwgIAAAAAAJx6QF6lj0AAER-QGFkaAAAnIB428.jpg" alt=""></p>
<h2 id="u5F15_u8A00]]>
    </summary>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[「番茄工作法」- 简单的时间管理方法]]></title>
    <link href="http://blog.devtang.com/2016/04/12/tomato-time-management/"/>
    <id>http://blog.devtang.com/2016/04/12/tomato-time-management/</id>
    <published>2016-04-12T13:20:55.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>「番茄工作法」是一个简单、轻松的提高工作效率的办法。一直在小众圈子里面流行，但是没有被普及。写下此文，希望番茄工作法能够被更多人了解和接受。</p>
<p>「番茄工作法」这个名字的来历是这样：番茄是指番茄外形的定时器（下图）的意思。专门的定时器常常用于烹饪的计时，时间到了之后闹钟就会响起来。</p>
<img src="/images/tomato.jpg">
<p>番茄工作法的思想是：将日常工作分割成若干个计时器单元，每个单元大概 30 分钟左右。在番茄单元之间，进行合理地休息放松。在番茄单元进行时，保证自己精力全部集中在工作的事情上，不接受被打断和分神。</p>
<p>这种思想看起来非常简单，但是我在实际工作中，发现它确实能够非常高效地帮助我集中注意力。程序员在编程时通常需要较长的时间来整理思路和编码，「番茄工作法」使得我们更加容易集中注意力，从而将时间利用率提升。</p>
<h2 id="u4F7F_u7528_u65B9_u6CD5"><a href="#u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="使用方法"></a>使用方法</h2><p>「番茄工作法」的使用主流程如下：</p>
<ol>
<li>每天早上到公司后，首先拿一张纸（或者是本子中的一页），用笔写下当天应该要做完的事情。</li>
<li>将这些事情按优先级排序，然后进行大致的估算后，拆分成若干个「番茄钟」，每个「番茄钟」是 25 分钟。</li>
<li>设置「番茄钟」倒计时，同时开始第一件事情的第一个「番茄钟」。</li>
<li>在「番茄钟」倒计时期间，集中精力只做事先安排好的事情。</li>
<li>在「番茄钟」结束后，休息 5 分钟，走动放松一下，然后继续下一个「番茄钟」，直到完成自己的任务。</li>
<li>每完成 4 个「番茄钟」（即 2 小时），休息 15-30 分钟。</li>
</ol>
<p>一些意外情况：</p>
<ol>
<li>如果你被电话、交谈打断，这个「番茄钟」即宣告失败，可以简单休息 5 分钟，然后重启「番茄钟」。</li>
<li>如果你突然想到一件重要的事情，除非当前非做不可，否则应该在纸上将此事快速记录下来，然后继续你的「番茄钟」。</li>
</ol>
<h2 id="u4E00_u4E9B_u6280_u5DE7_u548C_u5FC3_u5F97"><a href="#u4E00_u4E9B_u6280_u5DE7_u548C_u5FC3_u5F97" class="headerlink" title="一些技巧和心得"></a>一些技巧和心得</h2><ol>
<li><p>在进行「番茄钟」时，我们应该尽量想办法避开一些容易分神的信息源。例如：将手机的消息推送静音，关闭 QQ 和微信。相信我，你大多数时候并不需要立即响应聊天软件中的信息。使用「番茄钟」后，你的消息回复时间最坏情况下也就是晚 25 分钟。如果真的有人有急事，他会直接到你的办公桌来找你，或者直接给你打电话的。对于程序员来说，也可以带个笔记本，找一个相对安静的地方编程。</p>
</li>
<li><p>随着你的注意力控制越来越容易，你可以适当延长「番茄钟」的时间。就我的经验，延长到 45 - 50 分钟是完全没有问题的。其实你如果明白了「番茄钟」的原理，你甚至可以在心中假想一个「番茄钟」，然后让自己快速进入精力集中状态。</p>
</li>
<li><p>一天下来，回顾自己当天的「番茄钟」完成情况，看看主要的问题在于自己的精力无法集中，还是老是被别人打断。针对具体的问题可以做一些调整的尝试。比如，如果是精力无法集中，则看看是否是干扰源过多，尽量减少干扰。如果是老被打断，则可以和同事商量一些工作方式，比如让同事尽量用邮件和 QQ 找你，而不是当面打扰你。</p>
</li>
<li><p>「番茄工作法」是一种简单轻松的工作法，我们应该尽量简单地使用它来辅助自己的工作，而不应该让任务计划和管理本身成为一件麻烦。所以，建议不要使用复杂的 App 来记录你的番茄钟完成情况，一张 A4 纸和一支笔就够了。另外，记录档案和思考如何提高不应该超过一个番茄时间，我们不应该让「番茄工作法」成为一种负担。</p>
</li>
<li><p>我们应该认识到，工作被打断是在所难免的，总会有一些临时的沟通工作无法被计划，并且是有价值的。所以，「番茄钟」失败后，不应该有过多的情绪，尽快重启一个「番茄钟」，你的工作应该很快就会进入状态。</p>
</li>
<li><p>各位做 iOS 开发的同学有多少买了 Apple Watch？我发现 Apple Watch 就是最好的「番茄钟」，我将 Apple Watch 的计时器放到了表盘上，抬手就可以开始一个番茄时间，非常方便（下图）。时间到了就会震动，也不会影响到旁边的同事。</p>
</li>
</ol>
<img src="/images/apple-watch-timer.jpg">
<h2 id="u63A8_u8350_u8BFB_u7269"><a href="#u63A8_u8350_u8BFB_u7269" class="headerlink" title="推荐读物"></a>推荐读物</h2><p><img src="http://img14.360buyimg.com/n1/g12/M00/00/03/rBEQYFMn13UIAAAAAAY-iISkO8AAAC2dgKel0kABj6g946.jpg" alt=""></p>
<ul>
<li><a href="http://item.jd.com/10406129.html" target="_blank" rel="external">《番茄工作法图解：简单易行的时间管理方法》</a>：一本 10 几块钱的、薄薄的充满图案的小册子，让你轻松理解番茄工作法。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>「番茄工作法」是一个简单、轻松的提高工作效率的办法。一直在小众圈子里面流行，但是没有被普及。写下此文，希]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[应该如何管理密码 - 我的密码管理心得]]></title>
    <link href="http://blog.devtang.com/2016/04/07/my-password-management-way/"/>
    <id>http://blog.devtang.com/2016/04/07/my-password-management-way/</id>
    <published>2016-04-07T15:59:37.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/password.jpg">
<h2 id="u6211_u7684_u5BC6_u7801_u5347_u7EA7_u4E4B_u8DEF"><a href="#u6211_u7684_u5BC6_u7801_u5347_u7EA7_u4E4B_u8DEF" class="headerlink" title="我的密码升级之路"></a>我的密码升级之路</h2><p>我最早接触密码这个概念是在高中的时候，那个时候我第一次申请 QQ 号，需要想一个超过 6 位数的密码。于是，我填上了我爸爸的手机号。老实说，手机号作为密码还不算最糟糕的。比起生日来说，手机号更长一些，可能的组合也更多一些。</p>
<p>我很快就了解了撞库这种攻击方式，你的密码如果在任何平台都用一样的话，如果有一个平台不靠谱，明文存储了密码（在那个年代其实并不少见，CSDN 都曾经存的是明文），那么黑客就可以用这个账号密码尝试登录其它平台。</p>
<p>于是，我把自己的密码分成了几套，简单的一套用于注册一些不太重要的服务，复杂的一套用于一些比较重要的服务，支付相关的还有一套。</p>
<p>对于每一套密码，我在密码后面加上了平台的名字。比如 QQ 的密码就是基础密码后面加 qq，网易邮箱的密码就是基础密码后面加 mail。</p>
<p>用了一段时间之后，我又增加了一些变化，我希望我尾部增加的与平台相关的名字不那么明显，于是，我把平台的首字母简单的取其字典序的下一个字母，然后插入到一个中间的位置。比如 qq 的密码，就是去 q 的下一个字母 r，然后把 r 插入到密码中间位置。因为我的基础密码本来就是一段随机的数字字母（真是随机的，只不过我背下来了），所以要看出规律可能需要爆出两个库才行。</p>
<p>但是，这么管理密码还是很累。而且，现在不断出现的安全事故让我觉得爆出两个网站被拖库也不算什么让人意外的事情。</p>
<h2 id="1password"><a href="#1password" class="headerlink" title="1password"></a>1password</h2><p>终于，我尝试购买了 1password，开始用 1password 来管理密码。1password 常常有 5 折的优惠活动，今年春节趁他家 APP 优惠，我开始了我的密码迁移之旅。</p>
<p>1password 完全采用随机的方式来生成每一个网站的密码，通常推荐的是 12 位的字母数字组合。我花了好几天，才把所有自己在用的账号密码做了更新。</p>
<p>1password 支持各种方式（iCloud 或 Dropbox）在云端同步你的密码。这样你也不用担心换了电脑找不到密码了。对于云端数据安全，1password 使用的是加密的方式来保存。即使黑客获得了你们密码文件，也需要一个解密的密码来解开它。而这个密码，就是你需要牢牢记住的那最后一个密码。</p>
<p>使用 1password 之后，每次在 chrome 中需要输入密码时，直接使用 1password 的插件进行自动的填充即可。习惯 Safari 的朋友，1password 也有 safari 的插件。值得一提的是，1password 还支持在 iOS 系统的 Safari 中填充密码，如下所示：</p>
<img src="/images/safari-1p.jpg">
<p>除去浏览器后，主要需要输入密码的地方就是 Mac 的原生应用和手机 APP 了。对于原生应用和手机 APP，1password 都支持把密码用复制的方式，粘贴到应用的密码输入界面。对了，买了 Mac 版的 1password，手机版的 1password 高级功能也自动解锁了。</p>
<p>1password 唯一搞不定的是那些不允许粘贴密码的应用，比如支付宝。对于这些应用，我另外有一套密码独立管理，没有放在 1password 管理中。</p>
<p>有了 1password 之后，一些软件的 License 也可以集中管理了，这还是一件挺爽的事情。1password 可以自动识别出软件的图标，如下所示。</p>
<img src="/images/1p-license-list.jpg">
<p>反思过来，密码确实是一个非常反人类的事情，因为人们天然怕麻烦，所以大多数人都只有一套密码，并且密码规则非常弱。</p>
<p>现在我们也慢慢看到越来越多的应用开始抛弃密码，用手机随机短信验证码来登录。还有一次公司，尝试用指纹（比如 iPhone)、声音 (比如微信的声音锁）、头像视频（比如借贷宝的认证）等来作为安全认证的替代品，都是不错的兼顾用户体验和安全的尝试。</p>
<h2 id="u5BC6_u7801_u88AB_u76D7"><a href="#u5BC6_u7801_u88AB_u76D7" class="headerlink" title="密码被盗"></a>密码被盗</h2><p>悲剧的是，就在我刚刚改完各种密码之后，我的百度云账号被盗，而且我通过正常渠道申诉失败。后来发现原因是我百度云账号绑定的网易邮箱被盗了，而那个邮箱我很久没有使用，都忘记了，所以也没有用 1password 改过密码。盗号者盗完我的网易邮箱后，从里面看到了我的注册百度云的确认邮件，于是申请了百度云找回密码，从而重置了我的百度云密码。重置之后，我的绑定邮箱被解绑，于是我就没有方法找回百度云密码了。</p>
<p>最终多亏在百度的朋友帮忙和担保，我才得以用非正常的渠道申诉成功。看到家里的所有照片失而复得，我第一次感觉到安全问题离自己这么近。</p>
<p>最后推荐 Mac 的各位朋友都使用 1password 来管理密码，并且对于一些非常重要的账号，用独立的非 1password 密码来管理。</p>
<p>安全问题，真的就在我们身边，大家还是小心一点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/password.jpg">
<h2 id="u6211_u7684_u5BC6_u7801_u5347_u7EA7_u4E4B_u8DEF"><a href="#u6211_u7684_u5BC6_u7801_u5347_u7EA7_u4E4]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（五）- Monad]]></title>
    <link href="http://blog.devtang.com/2016/04/05/swift-gym-5-monad/"/>
    <id>http://blog.devtang.com/2016/04/05/swift-gym-5-monad/</id>
    <published>2016-04-05T14:56:07.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第五节，练习前请做好准备运动，保持头脑清醒。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/65dc76a3gw1f0sz15ou0fj20cx07d0u3.jpg" alt=""></p>
<h2 id="Why_Monad_3F"><a href="#Why_Monad_3F" class="headerlink" title="Why Monad?"></a>Why Monad?</h2><p>因为 Monad 的定义有点复杂，我们先说为什么要理解和学习它。业界对于 Monad 的用处有着各种争论，特别是学术派喜欢用 Haskell 来解释它，因为「Haskell 是纯函数式编程语言」。但这往往让问题更加复杂了—-我为了理解一个概念，还需要先学习一门新语言。</p>
<p>所以我希望就 Swift 这门语言，分享一下理解 Monad 有什么用。实际上，即使在 Wikipedia 上，<a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="external">Monad</a>) 也没有被强行用 Haskell 来解释。所以我相信基于 Swift 语言，还是可以把 Monad 的概念讲清楚。</p>
<p>在我看来，之所以有 Monad 这种结构，实际上是为了链式调用服务的。什么是链式调用呢？我们来看看下面一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tq: Int? = 1&#10;tq.flatMap &#123;&#10;    $0 * 100&#10;&#125;.flatMap &#123;&#10;    &#34;image&#34; + String($0)&#10;&#125;.flatMap &#123;&#10;    UIImage(named: $0)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>所以，如果一句话解释 Monad，那就是：Monad 是一种设计模式，使得业务逻辑可以用链式调用的方式来书写。</p>
<p>在某些情况下，链式调用的方式组织代码会特别有效，比如当你的调用步骤是异步的时候，很容易写成多层嵌套的 <code>dispatch_async</code>，使用 Monad 可以使得多层嵌套被展开成链式调用，逻辑更加清楚。除了异步调用之外，编程中涉及输入输出、异常处理、并发处理等情况，使用 Monad 也可以使得代码逻辑更清晰。</p>
<h2 id="u57FA_u7840_u77E5_u8BC6"><a href="#u57FA_u7840_u77E5_u8BC6" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="u5C01_u88C5_u8FC7_u7684_u503C_uFF08wrapped_value_29"><a href="#u5C01_u88C5_u8FC7_u7684_u503C_uFF08wrapped_value_29" class="headerlink" title="封装过的值（wrapped value)"></a>封装过的值（wrapped value)</h3><p>这个中文词是我自己想出来的，有一些人把它叫做「上下文中的值」（value with a context），有一些人把它叫做「容器中的值」（value in a container)，意思是一样的。</p>
<p>什么叫做「封装过的值」呢？即把裸露的数据放到另一个结构中。例如：</p>
<ul>
<li>数组就是对值的一种封装，因为数组把裸露的元素放到了一个线性表结构中。</li>
<li>Optional 也是对值的一种封装，因为 Optional 把值和空放到了一个枚举（enum）类型中。</li>
</ul>
<p>如果你愿意，你也可以自己封装一些值，比如把网络请求的结果和网络异常封装在一起，做成一个 enum (如下所示）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Result&#60;T&#62; &#123;&#10;    case Success(T)&#10;    case Failure(ErrorType)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>判断一个数据类型是不是「封装过的值」，有一个简单的办法：就是看这个数据类型能不能「被打开」，拿出里面的裸露的元素。</p>
<ul>
<li>数组可以被打开，拿出里面的数组元素。</li>
<li>Optional 可以被打开，拿出里面的值或者 .None。</li>
<li>一个 Int 类型的值，无法「被打开」，所以它不是「封装过的值」。</li>
</ul>
<p>一个字符串是不是「封装过的值」呢？前提是你如何定义它「被打开」，如果你把它的打开定义成获得字符串里面的每个字符，那么字符串也可以是一个「封装过的值」。</p>
<!--
那要这么说，其实 Int 也可以被看作一个「封装过的值」，如果你把它的打开，定义成获得这个 Int 的每个 bit 位的值就行。
-->
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>在上一篇烧脑文章中我们也提到过，要识别一个类型是不是 Monad，主要就是看它是否实现了 <code>flatMap</code> 方法。但是，如果你像下面这么实现 <code>flatMap</code>，那也不能叫 Monad：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TangQiao &#123;&#10;    func flatMap() &#123;&#10;        print(&#34;Hello world&#34;)&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Monad 对于 <code>flatMap</code> 函数有着严格的定义，在 Haskell 语言中，这个函数名叫 bind，但是定义是一样的，这个函数应该：</p>
<ul>
<li>作用在一个「封装过的值」M 上。</li>
<li>它的参数应该是另一个闭包 F，这个闭包 F：接受一个解包后的值，返回一个「封装过的值」。</li>
</ul>
<p>具体在执行的时候，<code>flatMap</code> 会对 M 进行解包得到 C，然后调用闭包 F，传入解包后的 C，获得新的「封装过的值」。</p>
<p>我们来看看 Optional 的 <code>flatMap</code> 实现，验证一下刚刚说的逻辑。源码地址是：<a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func flatMap&#60;U&#62;(@noescape f: (Wrapped) throws -&#62; U?) &#10;        rethrows -&#62; U? &#123;&#10;    switch self &#123;&#10;    case .Some(let y):&#10;        return try f(y)&#10;    case .None:&#10;        return .None&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Optional 的 <code>flatMap</code>：</p>
<ul>
<li>作用在一个「封装过的值」：<code>self</code> 身上。</li>
<li>接受一个闭包参数 <code>f</code>，这个 <code>f</code> 的定义是：接受解包后的值，返回一个「封装过的值」: <code>U?</code> 。</li>
<li>在执行时，<code>flatMap</code> 先对 <code>self</code> 进行解包，代码是 <code>case .Some(let y)</code>。</li>
<li>如果解包成功，则调用函数 f，得到一个新的「封装过的值」，代码是 <code>try f(y)</code>。</li>
<li>如果解包出来是 .None，则返回 .None。</li>
</ul>
<h2 id="u8BBE_u8BA1_u80CC_u540E_u7684_u8FFD_u95EE"><a href="#u8BBE_u8BA1_u80CC_u540E_u7684_u8FFD_u95EE" class="headerlink" title="设计背后的追问"></a>设计背后的追问</h2><p><code>flatMap</code> 接受的这个闭包参数，直观看起来很奇怪。接受的是解包的值，返回的又是封装过的值，一点都没有对称的美！</p>
<p>为什么要这么设计？不这么设计就不能完成链式调用吗？我想了半天，答案就是一个字：懒！</p>
<p>为什么这么说呢？因为「封装过的值」大多数时候不能直接计算，所以要计算的时候都要先解包，如果我们为了追求「对称的美」，使得函数接受的参数和返回的值都是「封装过的值」，当然是可以的。不过如果这么设计的话，你就会写大量雷同的解包代码。程序设计的时候追求「Don’t Repeat Yourself」原则，这么做当然是不被接受的。</p>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>刚刚我们说，在设计上为了复用代码，我们必须保证闭包的参数是解包后的值。</p>
<p>那么，同样的道理，每次返回之前都封包一下，不一样很重复么？我们返回的值能不能是解包后的原始值，然后自动封装它？</p>
<p>答案是可以的，但是这就不是 Monad 了，这成了 Functor 了。我们上一讲提到过，Functor 中实现的 <code>map</code> 方法，就是一个接受解包后的值，返回结果仍然是解包后的值。为了保证链式调用，map 会自动把结果再封包一次。</p>
<p>我们再来回顾一下 <code>map</code> 的源码吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func map&#60;U&#62;(@noescape f: (Wrapped) throws -&#62; U) &#10;        rethrows -&#62; U? &#123;&#10;    switch self &#123;&#10;    case .Some(let y):&#10;        return .Some(try f(y))&#10;    case .None:&#10;        return .None&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在该源码中，函数 <code>f</code> 在被执行完后，结果会被封包成 Optional 类型，相关代码是：<code>.Some(try f(y))</code>。</p>
<p>所以，Optional 的 <code>map</code> 和 <code>flatMap</code> 差别真的非常非常小，就看你的闭包想不想自己返回封装后的值了。</p>
<p>在具体业务中，我们也有一些实际的需求，需要我们自己控制返回封装后的值。比如 Optional 在操作的时候，如果要返回 .None，则需要使用 <code>flatMap</code>，错误的使用了 <code>map</code> 函数的话，就会带来多重嵌套 nil 的问题。比如下面这个代码，变量 <code>b</code> 因为是一个两层嵌套的 nil，所以 <code>if let</code> 失效了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tq: Int? = 1&#10;let b = tq.map &#123; (a: Int) -&#62; Int? in&#10;    if a % 2 == 0 &#123;&#10;        return a&#10;    &#125; else &#123;&#10;        return nil&#10;    &#125;&#10;&#125;&#10;if let _ = b &#123;&#10;    print(&#34;not nil&#34;)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>归根结底，你在编程时使用 Monad 还是 Functor，取决于你的具体业务需求：</p>
<ul>
<li>如果你在处理「封装过的值」时，不会（或不需要）返回异常数据，则可以使用 Functor，让数据的封装过程交给 <code>map</code> 函数来处理。</li>
<li>如果你在处理「封装过的值」时，需要在闭包函数里返回类似 nil（或 ErrorType）一类的数据，则可以使用 Monad，自己返回新的「封装过的值」。</li>
</ul>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>Swift 语言中并没有原生的 Applicative，但是 Applicative 和 Functor、Monad 算是三个形影不离的三兄弟，另外它们三者的差异都很小，所以干脆一并介绍了。</p>
<p>刚刚我们讨论 Functor 与 Monad 时，都是说把值放在一个容器里面。但是我们别忘了，Swift 是函数式语言，函数是一等公民，所以，函数本身也是一种值，它也可以放到一个容器里面，而我们要讨论的 Applicative，就是一种关于「封装过的函数」的规则。</p>
<p>Applicative 的定义是：使用「封装过的函数」处理「封装过的值」。这个「封装过的函数」解包之后的参数类型和 Functor 的要求是一样的。</p>
<p>按照这个定义，我们可以自己改造数组和 Optional，使它们成为 Applicative，以下代码就是一个示例，来自 <a href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" target="_blank" rel="external">这里</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Optional &#123;&#10;    func apply&#60;U&#62;(f: (T -&#62; U)?) -&#62; U? &#123;&#10;        switch f &#123;&#10;        case .Some(let someF): return self.map(someF)&#10;        case .None: return .None&#10;        &#125;&#10;    &#125;&#10;&#125;&#10;&#10;extension Array &#123;&#10;    func apply&#60;U&#62;(fs: [Element -&#62; U]) -&#62; [U] &#123;&#10;        var result = [U]()&#10;        for f in fs &#123;&#10;            for element in self.map(f) &#123;&#10;                result.append(element)&#10;            &#125;&#10;        &#125;&#10;        return result&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们为数组和 Optional 增加了一个 <code>apply</code> 方法，而这个方法符合 Applicative 的定义。如果和 <code>map</code> 方法对比，它们的唯一差别就是闭包函数是封装过后的了：</p>
<ul>
<li>对于 Optional 来说，<code>apply</code> 的闭包函数也变成 Optinoal 的了。</li>
<li>对于数组来说，<code>apply</code> 的闭包函数也是一个数组（我们之前介绍过，数组也是对数据的一种封装）。</li>
</ul>
<h2 id="Monad__u7684_u5E94_u7528"><a href="#Monad__u7684_u5E94_u7528" class="headerlink" title="Monad 的应用"></a>Monad 的应用</h2><p>理论都离不开应用，否则就是「然并卵」了，讲完了概念，我们来看看除了 Swift 语言中的数组和 Optional，业界还有哪些对于 Monad 的应用。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><a href="http://promisekit.org/" target="_blank" rel="external">PromiseKit</a> 是一个同时支持 Objective-C 和 Swift 的异步库。它用 Promise 来表示一个未来将要执行的操作，使用它可以简化我们的异步操作。因为篇幅有限，本文并不打算展开详细介绍 Promise，我们就看一个实际的使用示例吧。</p>
<p>假设我们有一个业务场景，需要用户先登录，然后登录成功后发API获取数据，获取数据后更新 UITableView 的内容，整个过程如果有错误，显示相应的错误信息。</p>
<p>传统情况下，我们需要把每个操作都封装起来，然后我们可以选择：</p>
<ul>
<li>方法一：用多层嵌套的 <code>dispatch_async</code> 把逻辑写到一起，但是这样嵌套代码，可读性和可维护性很差。</li>
<li>方法二：每一步有一个 delegate 回调函数，把业务逻辑分散到各个回调函数中。但是这样不但逻辑分散了，而且关键的函数调用的依赖关系被我们隐藏起来了。</li>
</ul>
<p>另外，以上两种方法处理错误逻辑都可能会有多处，虽然我们可以把报错也封装成一个函数，但是在多个地方调用也不太舒服。使用 PromiseKit 之后，刚刚提到的业务场景可以用如下的示意代码来完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login().then &#123;&#10;    return API.fetchKittens()&#10;&#125;.then &#123; fetchedKittens in&#10;    self.kittens = fetchedKittens&#10;    self.tableView.reloadData()&#10;&#125;.catch &#123; error in&#10;    UIAlertView(&#8230;).show()&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果你的逻辑涉及并发，PromiseKit 也可以很好地处理，例如，你希望发两个网络请求，当两个网络请求都结束时，做相应的处理。那就可以让 PromiseKit 的 <code>when</code> 方法与 <code>then</code> 结合工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let search1 = MKLocalSearch(request: rq1).promise()&#10;let search2 = MKLocalSearch(request: rq2).promise()&#10;&#10;when(search1, search2).then &#123; response1, response2 in&#10;    //&#8230;&#10;&#125;.catch &#123; error in&#10;    // called if either search fails&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在 PromiseKit 的设计中，<code>then</code> 方法接受的闭包的类型和 <code>flatMap</code> 是一样的，所以它本质上就是 <code>flatMap</code>。Promise 其实就是一种 Monad。</p>
<h3 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h3><p>比起 PromiseKit，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a> 的名气要大得多。最新的 ReactiveCocoa 4.0 同时支持 Objective-C 和 Swift，我们在源码中发现了 RAC 的 <code>SignalType</code> 就是一个 Monad：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension SignalType &#123;&#10;&#10;    public func flatMap&#60;U&#62;(strategy: FlattenStrategy, transform: Value -&#62; SignalProducer&#60;U, Error&#62;)&#10;        -&#62; Signal&#60;U, Error&#62; &#123;&#10;        return map(transform).flatten(strategy)&#10;    &#125;&#10;&#10;    public func flatMap&#60;U&#62;(strategy: FlattenStrategy, transform: Value -&#62; Signal&#60;U, Error&#62;) &#10;        -&#62; Signal&#60;U, Error&#62; &#123;&#10;        return map(transform).flatten(strategy)&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>我们再次总结一下 Monad、Functor、Applicative：</p>
<ul>
<li>Monad：对一种封装过的值，使用 <code>flatMap</code> 函数。</li>
<li>Functor：对一种封装过的值，使用 <code>map</code> 函数。</li>
<li>Applicative：对一种封装过的值，使用 <code>apply</code> 函数。</li>
</ul>
<p>我们再对比一下<code>flatMap</code>、<code>map</code> 和 <code>apply</code>：</p>
<ul>
<li><code>flatMap</code>：对自己解包，然后应用到一个闭包上，这个闭包：接受一个「未封装的值」，返回一个「封装后的值」。</li>
<li><code>map</code>：对自己解包，然后应用到一个闭包上，这个闭包：接受一个「未封装的值」，返回一个「未封装的值」。</li>
<li><code>apply</code>：对自己解包，然后对闭包解包，解包后的闭包：接受一个「未封装的值」，返回一个「未封装的值」。</li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" target="_blank" rel="external">Swift Functors, Applicatives, and Monads in Pictures</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/" target="_blank" rel="external">Functor、Applicative 和 Monad</a></li>
<li><a href="https://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/" target="_blank" rel="external">Promises are the monad of asynchronous programming</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何实现自己没实现过的需求之文本动画]]></title>
    <link href="http://blog.devtang.com/2016/03/20/text-animation-guide/"/>
    <id>http://blog.devtang.com/2016/03/20/text-animation-guide/</id>
    <published>2016-03-20T13:34:23.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>吕伟（<a href="http://weibo.com/u/1660258615" target="_blank" rel="external">@我在罪恶坑的日子</a>）iOS 开发者，这些年在上海工作。专业：扯淡，兼职：开发。<br>感谢投稿，<a href="http://www.ismash.cn/post/ru-he-shi-xian-zi-ji-mei-shi-xian-guo-de-xu-qiu-zhi-wen-ben-dong-hua-pian" target="_blank" rel="external">原文链接</a>。</p>
</blockquote>
<p>大家好，我是非知名程序员，想跟大家说一段传统相声节目，额，对不起，说错了。想跟大家分享一点关于文本和动画的东西。这不是一篇纯血统，高、精、尖的技术文章，但依然希望有人能像喜欢混血美女一样喜欢。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>记得以前看到过一个很赞的文字效果的动画，类似于这样：</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13845905/1e55a5d0-ec7e-11e5-9631-68aaf6b07ba1.gif" alt="textanimation"></p>
<p>当时被惊艳到了，最近偶然间又再次见到，依然还是那么喜欢。假设我们现在需要实现这样的需求。一般碰到需求我们都会去 GitHub 上看看，俗称找轮子（GitHub 基本上只有你想不到的，就没有它没有的）。大多数情况下，没有问题。或者说有点小问题：轮子太多，无从下嘴。</p>
<h2 id="u9009_u62E9"><a href="#u9009_u62E9" class="headerlink" title="选择"></a>选择</h2><blockquote>
<p>选轮子就像选姑娘，你不知道后面等着你的是什么 —–罪恶坑小程如是说</p>
</blockquote>
<p>程序员江湖，每位大侠的武功和套路不尽一样，少林，武当，昆仑各门各派，百花争艳。实现轮子的思路自然也不一样。有的轮子高深晦涩难懂，功能强大，有的清晰明了，功能简单。不过有一点相同是，选错了就会被坑，只是坑大坑小问题。选轮子自然需要无比谨慎，既要匹配需求同时也要能在掉坑里的时候填上（废话，出 bug 了，你不填，谁填），要能 hold 住。然而填坑哪能那么简单呢，首先轮子实现思路，代码的结构，运行时序你要搞清楚吧，提供了哪些功能，没提供哪些功能，你要了解吧。基本上一个复杂点的轮子，研究下来就要好些时间了。这还不包括你开会，沟通，解 bug，喝茶，倒水，上厕所，抽烟，骂娘，吐槽产品需求的时间。所以，妹子们，不要问我们今天加不加班，要问今天能不能在你睡前下班。（项目快上线了，小程不加班谁加班。嗯哼。）</p>
<h2 id="u521B_u9020"><a href="#u521B_u9020" class="headerlink" title="创造"></a>创造</h2><blockquote>
<p>如果能用代码扮演上帝话，苍老师的量产不是问题，就看产品经理定的需求是拟物还是扁平。—-罪恶坑小程如是说</p>
</blockquote>
<p>既然选轮子的时间成本也不低，那有时候我们可以自己造一个轮子。其实写一个的好处也多，有成就感，写好了可以吹牛逼，写坏了填坑速度快。但问题是，以前没写过怎么办？没把握怎么办？比如我们现在需要实现上面的文字效果，但是又不知道怎么写，怎么办？</p>
<p>没关系，上帝创造世间也分了七步走，跟着这位带头大哥后面学，总不会错的。</p>
<h2 id="u5F00_u59CB"><a href="#u5F00_u59CB" class="headerlink" title="开始"></a>开始</h2><blockquote>
<p>罗马不是一天建成的，毛片不是一次性拍完的 —-罪恶坑小程如是说 </p>
</blockquote>
<p>咦，好像扯得有点多了。对不起，现在开始正式拍（苍老师准备下，小程也准备下，Action）：</p>
<h4 id="1-__u5206_u89E3_u4EFB_u52A1"><a href="#1-__u5206_u89E3_u4EFB_u52A1" class="headerlink" title="1.  分解任务"></a>1. <strong> 分解任务 </strong></h4><p>通过简单观察我们可以马上知道，上面那个动画效果是通过对每个字符做动画完成的。而在 iOS 里，文本显示控件最常见和常用的是 UILabel。而 iOS 的 Explicit Animation 有 Properties Animation 和 keyframe Animation 两种。</p>
<p>但是 UILabel 控件没有提供对其 Text 中每个字符的控制的功能，我们需要改造下。既然要对每个字符做动画，那少不了需要<code>frame</code>，<code>bounds</code>，<code>position</code>，<code>transform</code>，这些属性。<br>这样看来我们需要两个武器：一个做排版功能的 framework，不用说，肯定是 <a href="http://objccn.io/issue-5-1/" target="_blank" rel="external">TextKit</a>。而另一个是能显示单个字符也拥有<code>frame</code>，<code>bounds</code>，<code>position</code>，<code>transform</code>等属性的类，很自然，我们想到<code>CATextLayer</code>。</p>
<h4 id="2-__u5148_u89E3_u51B3_u6587_u672C_u5E03_u5C40"><a href="#2-__u5148_u89E3_u51B3_u6587_u672C_u5E03_u5C40" class="headerlink" title="2.  先解决文本布局"></a>2. <strong> 先解决文本布局 </strong></h4><p>TextKit 里主要是三个类 <code>NSTextStorage</code>，<code>NSLayoutManager</code>，<code>NSContainer</code>。它们一起帮组我们解决文字布局，排版的工作。</p>
<ul>
<li><p><strong>NSTextStorage</strong>：<code>NSMutableAttributedString</code>的子类，持有文字内容，当字符发生改变时，通知<code>NSLayoutManager</code>对象</p>
</li>
<li><p><strong>NSLayoutManager</strong>: 我们的男主角，从<code>NSTextStorage</code>里获取文字内容后，转换成对应的 glyph，根据<code>NSTextContainer</code>的 visible Region 显示 glyph。</p>
</li>
<li><p><strong>NSContainer</strong>: 确定一个 region 来放置 text。这个 region 被<code>NSLayoutManager</code>用来决定哪里可以 break lines</p>
</li>
</ul>
<p>不过可惜 UILabel 没有这三个类作为自己的属性对象，我们需要自己解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TextAnimationLabel: UILabel,NSLayoutManagerDelegate &#123;   &#10;     let textStorage:NSTextStorage = NSTextStorage(string: &#34;&#34;)&#10;     let textLayoutManager:NSLayoutManager = NSLayoutManager()&#10;     let textContainer:NSTextContainer = NSTextContainer()&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>除此以外我们还需要两个 Array 用来保存文本变换前的旧字符和变换后的新字符:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var oldCharacterTextLayers:[CATextLayer] = [] &#10;var newCharacterTextLayers:[CATextLayer] = []</span><br></pre></td></tr></table></figure>
<p>因为我们需要用我们自己的 textStorage 对象，所以我们需要覆盖 text 和 attributedText 等属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override var text:String!&#123;&#10;    get &#123;&#10;        return super.text&#10;    &#125;&#10;    set &#123;&#10;        super.text = text&#10;        let attributedText = NSMutableAttributedString(string: newValue)&#10;        let textRange = NSMakeRange(0,newValue.characters.count)&#10;        attributedText.setAttributes([NSForegroundColorAttributeName:self.textColor], range: textRange)&#10;        attributedText.setAttributes([NSFontAttributeName:self.font], range: textRange)&#10;        let paragraphyStyle = NSMutableParagraphStyle()&#10;        paragraphyStyle.alignment = self.textAlignment&#10;        attributedText.addAttributes([NSParagraphStyleAttributeName:paragraphyStyle], range: textRange)&#10;        self.attributedText = attributedText&#10;        &#125;&#10;        &#10; &#125;&#10;    &#10;override var attributedText:NSAttributedString!&#123;&#10;    get &#123;&#10;        return self.textStorage as NSAttributedString&#10;    &#125;&#10;    set&#123;&#10;        cleanOutOldCharacterTextLayers()&#10;        oldCharacterTextLayers = Array(newCharacterTextLayers)&#10;        textStorage.setAttributedString(newValue)&#10;        self.startAnimation &#123; () -&#62; () in&#10;        &#125;&#10;            self.endAnimation(nil)&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当 TextStorage 的文本内容改变时，会触发一个通知 send textLayoutManager 以便重新布局排版。显然我们可以在排版布局完成后来为每个字符创建设置一个 CATextLayer，并设置相应的 frame 以便正确的显示内容。我们可以有个函数来完成计算。并且 layout finish 完成时调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Mark:NSLayoutMangerDelegate&#10;func layoutManager(layoutManager: NSLayoutManager, didCompleteLayoutForTextContainer textContainer: NSTextContainer?, atEnd layoutFinishedFlag: Bool) &#123;&#10;        calculateTextLayers()&#10;        print(&#34;\(textStorage.string)&#34;)&#10;&#125;&#10;    &#10;    &#10;//MARK:CalculateTextLayer&#10;func calculateTextLayers()&#10;&#123;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们的主要想法，是找到 text 里每个 character 以及对应的 glyph rect. 然后用 character 和 glyph rect 创建 CATextLayer</p>
<p>首先我们要有一个空数组用来存放新的 CATextLayer。并且获取 textStorage 的 attributedText。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func calculateTextLayers()&#10;&#123;&#10;    newCharacterTextLayers.removeAll(keepCapacity:false)&#10;    let attributedText = textStorage.string&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们要通过 LayoutManger 找到 TextContainer 的 used Rect，这样方便我们可以让文本垂直居中，就像普通的 Label 那样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func calculateTextLayers()&#10;&#123;&#10;    newCharacterTextLayers.removeAll(keepCapacity:false)&#10;    let attributedText = textStorage.string&#10;    let wordRange = NSMakeRange(0, attributedText.characters.count)&#10;    let attributedString = self.internalAttributedText();&#10;    let layoutRect = textLayoutManager.usedRectForTextContainer(textContainer)&#10;    var index = wordRange.location&#10;    let totalLength = NSMaxRange(wordRange)&#10;    while index &#60; totalLength &#123;&#10;         ...&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们开始迭代处理文本里的每个字符，创建一个 glyphRange 并且用这个 glyphRange 找到对应的 character，然后我们将 glyph index 丢给 LayoutManager 得到 textContainer，再用 container 和 glyphRange 取得 glyphRect(这里需要注意下 kerning 的问题)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let glyphRange = NSMakeRange(index, 1)&#10;let characterRange = textLayoutManager.characterRangeForGlyphRange(glyphRange, actualGlyphRange: nil)&#10;let textContainer = textLayoutManager.textContainerForGlyphAtIndex(index, effectiveRange: nil)&#10;var glyphRect = textLayoutManager.boundingRectForGlyphRange(glyphRange, inTextContainer: textContainer!)</span><br></pre></td></tr></table></figure>
<p>最终我们还需要注意的就是 glyph 的 kerning，如果 <code>kerningRange.location == index</code>，我们需要将前一个 textLayer 取出来调整其 Rect 的宽度至新的 glyphRect 的最右边，保证 glyph 不会被裁切掉（可以对比下面两张图片）</p>
<p><img width="122" src="https://cloud.githubusercontent.com/assets/3759810/13854816/4a6b5258-eca8-11e5-9870-15ed2d4f0d70.png"></p>
<p><img width="122" src="https://cloud.githubusercontent.com/assets/3759810/13854821/4c5b947e-eca8-11e5-811e-e9abb161345f.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let kerningRange = textLayoutManager.rangeOfNominallySpacedGlyphsContainingIndex(index)&#10;if kerningRange.location == index &#38;&#38; kerningRange.length &#62; 1 &#123;&#10;    if newCharacterTextLayers.count &#62; 0 &#123;&#10;        // &#22914;&#26524;&#21069;&#19968;&#20010; textlayer &#30340; frame.size.width &#19981;&#21464;&#22823;&#30340;&#35805;&#65292;&#10;        // &#24403;&#21069;&#30340; textLayer &#20250;&#36974;&#25377;&#20303;&#23383;&#20307;&#30340;&#19968;&#37096;&#20998;&#65292;&#27604;&#22914; &#8220;Yes&#8221; &#30340; Y &#21491;&#19978;&#35282;&#20250;&#34987;&#20999;&#25481;&#19968;&#37096;&#20998;&#10;        let previousLayer = newCharacterTextLayers[newCharacterTextLayers.endIndex - 1]&#10;        var frame = previousLayer.frame&#10;        frame.size.width += CGRectGetMaxX(glyphRect) - CGRectGetMaxX(frame)&#10;        previousLayer.frame = frame&#10;     &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里关于 kerning 和 glyph 要多说一点。先来说下 glyph，简单来说 glyph 是表示一个 character 的具体样式 , 但他们却不是一一对应的关系，比如一个字母 “A” 可以有不同的写法来表示例如：</p>
<p><img width="417" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878224/e142bef8-ed4a-11e5-9c84-798cb5939f36.png"></p>
<p>除此以外，还有这种情况：</p>
<p><img width="243" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878392/fab15e02-ed4b-11e5-9d38-2dc00ed45b0b.png"></p>
<p>上面是的 “ff” 虽然是两个 character，但是 glyph 却是一个。<br>不过不用担心，强大 LayoutManager 提供了两个方法帮助我们通过一个找到对应另外那个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func characterIndexForGlyphAtIndex(_ glyphIndex: Int) -&#62; Int&#10;func glyphIndexForCharacterAtIndex(_ charIndex: Int) -&#62; Int</span><br></pre></td></tr></table></figure>
<p>现在我们说下 kerning。通常，在水平排布的文本中，glyph 都是一个挨着一个放置的，但是在某些时候为了让文本的可读性更好，看上去更加优雅美观，一个字形和另外一个字形之间可能会稍微的错位下，比如下面这种情况：</p>
<p><img width="601" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878767/7631a33c-ed4e-11e5-9d03-46d89d8af9c8.png"><br>这也是上面为什么”Y“会出现显示不全的原因了。</p>
<p>接下来就比较简单了，创建 Textlayer, 设置垂直居中，添加到数组当中，<code>index += characterRange.length</code>，开始下次循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glyphRect.origin.y += (self.bounds.size.height/2)-(layoutRect.size.height/2)&#10;let textLayer = CATextLayer(frame: glyphRect, string: attributedString.attributedSubstringFromRange(characterRange));&#10;layer.addSublayer(textLayer);&#10;newCharacterTextLayers.append(textLayer);&#10;index += characterRange.length</span><br></pre></td></tr></table></figure>
<h4 id="3-__u52A8_u753B_u5B9E_u73B0"><a href="#3-__u52A8_u753B_u5B9E_u73B0" class="headerlink" title="3.  动画实现"></a>3. <strong> 动画实现 </strong></h4><p>上面我们解决了字符排版的问题，接下来动画的实现就相对的容易了，仔细观察那个动画，很容易得出主要是对 <code>opacity</code> 和 <code>transform</code> 两个属性做属性动画，<code>opacity</code> 让每个字体逐渐显示和逐渐消失，而 <code>transform</code>则做了两种变形，一种是往下移动，另外一种是旋转。用 <code>CABasicAnimation</code> 可以解决单个属性动画，而 <code>CAAnimationGroup</code> 则帮我们解决多个动画叠加的复合效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func groupAnimationWithLayerChanges(old olderLayer:CALayer, new newLayer:CALayer) &#10;     -&#62; CAAnimationGroup? &#123;&#10;&#10;    var animationGroup:CAAnimationGroup?&#10;    var animations:[CABasicAnimation] = [CABasicAnimation]()&#10;&#10;    if !CATransform3DEqualToTransform(olderLayer.transform,&#10;    newLayer.transform) &#123;&#10;         let basicAnimation = CABasicAnimation(keyPath: &#34;transform&#34;)&#10;         basicAnimation.fromValue = NSValue(CATransform3D: olderLayer.transform)&#10;         basicAnimation.toValue = NSValue(CATransform3D: newLayer.transform)&#10;         animations.append(basicAnimation)&#10;         &#125;&#10;&#10;    if olderLayer.opacity != newLayer.opacity &#123;&#10;       let basicAnimation = CABasicAnimation(keyPath: &#34;opacity&#34;)&#10;       basicAnimation.fromValue = olderLayer.opacity&#10;       basicAnimation.toValue = newLayer.opacity&#10;       animations.append(basicAnimation)&#10;       &#125;&#10;&#10;    if animations.count &#62; 0 &#123;&#10;       animationGroup = CAAnimationGroup()&#10;       animationGroup!.animations = animations&#10;   &#125;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一个问题，就是隐式动画的问题，Core Animation 基于一个假说，就是屏幕上的任何东西都可以 (或者可能) 做动画，我们平时在写代码时应该有这种印象就是你只是 layer 设置了一个值，没有添加动画，但是你会看到一个平滑过渡的显示效果而不是非常突兀的变化。这就是隐式动画。当我们改变一个属性时，Core Animation 帮我们做了一个动画，动画时间取决于当前 NSTransaction 的设置，而动画类型取决于图层行为。</p>
<p>这里有个有趣的东西，多说一点，就是当我们对 UIView 关联的图层做动画而不是一个单独的图层做动画，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func changeColor()&#10;&#123;&#10;    CATransaction.begin();&#10;    CATransaction.setAnimationDuration(1.0)&#10;    CGFloat red = CGFloat(arc4random() / (CGFloat)INT_MAX);&#10;    CGFloat green = CGFloat(arc4random() / (CGFloat)INT_MAX);&#10;    CGFloat blue = CGFloat(arc4random() / (CGFloat)INT_MAX);&#10;    self.layerView.layer.backgroundColor = UIColor.(colorWithRed:red green:green blue:blue alpha:1.0).CGColor;&#10;    CATransaction.commit();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>图层的颜色瞬间切换到新的值，而不是之前的平滑过渡，隐式动画似乎给关闭了。<br>我们知道 UIView 和 CALayer 最重要的关系就是 UIView 是 CALayer 的 delegate，<br>当我们改变 CALayer 的属性时，它会调用 <code>func actionForKey(_ event: String) -&gt; CAAction?</code> </p>
<p>这个方法，接下来发生的事情在官方文档里都有写，实际上是如下几步:</p>
<ul>
<li><p><em>If the layer has a delegate that implements the actionForLayer:forKey: method, the layer calls that method. The delegate must do one of the following:</em></p>
<ol>
<li><p>Return the action object for the given key.</p>
</li>
<li><p>Return the NSNull object if it does not handle the action.</p>
</li>
</ol>
</li>
<li><p><em>The layer looks in the layer’s actions dictionary for a matching key/action pair.</em></p>
</li>
<li><em>The layer looks in the style dictionary for an actions dictionary for a matching key/action pair.</em></li>
<li><em>The layer calls the defaultActionForKey: class method to look for any class-defined actions.</em></li>
</ul>
<p>UIView 作为它关联图层的 Delegate，实现了 <code>actionForLayer(_ layer: CALayer, forKey event: String) -&gt; CAAction?</code> ，当不在一个动画块中，UIView 返回 nil，而在动画块中则返回一个非空值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#34;OutSide:\(self.view.actionForLayer(self.view.layer, forKey: &#34;backgroundColor&#34;))&#34;)&#10;UIView.beginAnimations(nil, context: nil)&#10;print(&#34;InSide:\(self.view.actionForLayer(self.view.layer,&#10;forKey: &#34;backgroundColor&#34;))&#34;)&#10;UIView.commitAnimations()</span><br></pre></td></tr></table></figure>
<p>显示结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OutSide:Optional(&#60;null&#62;)&#10;InSide:Optional(&#60;CABasicAnimation: 0x7f7f93ff81b0&#62;)</span><br></pre></td></tr></table></figure>
<p>当然返回 nil 并不是禁用隐式动画的唯一方法，下面这样也行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CATransaction.setDisableActions(true)</span><br></pre></td></tr></table></figure>
<p>那为什么说这个问题呢？因为我们在对每个字符做动画的时候需要先将隐式动画关闭，否者将会做两次动画，比如下面这样:</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13857496/2443d70a-ecb5-11e5-8661-a499e9c8719d.gif" alt="closeimplicitanimation"></p>
<p>那么，我们先生成一份 oldlayer, 然后改变相应的属性，生产新的 newLayer。然后创建相应的动画组，添加显式动画。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let olderLayer = animationObjc.animatableLayerCopy(layer)&#10;CATransaction.begin()&#10;CATransaction.setDisableActions(true)&#10;newLayer = effectAnimationClosure(layer: layer)&#10;CATransaction.commit()&#10;var animationGroup:CAAnimationGroup?&#10;animationGroup = groupAnimationWithLayerChanges(old: olderLayer, new: newLayer!)&#10;layer.addAnimation(textAniamtionGroup, forKey: textAnimationGroupKey)</span><br></pre></td></tr></table></figure>
<h2 id="u6536_u5DE5"><a href="#u6536_u5DE5" class="headerlink" title="收工"></a>收工</h2><p>好了，当上面所有的工作完成之后，就是我们最开始看到的那个效果，代码已经上传 GitHub，你可以从 <a href="https://github.com/morpheus1984/TextKitAndAnimationEffect.git" target="_blank" rel="external">这里</a> 下载。其实这个 demo 里实现的 label 还有很大优化的空间。比如支持多种类型的动画效果，动画效果可配置等等。这是我接下来打算做的事情。<br>本人才疏学浅，错漏难免，欢迎大家批评指正。如果你发现 bug，可以提个 pull request。如果你有更好地思路也请告诉我，让我进步，我请你喝咖啡 ：）。</p>
<p>这是我的微信号（未完结，请往下看）：</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13864468/9fdcae9c-ecdc-11e5-9c49-278b327d1ba7.png" alt="wechat"></p>
<h2 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h2><p>不知不觉工作许多年了，这几年萝莉变成了姑娘，姑娘变成了孩子妈。大家从 QQ 空间杀到朋友圈。从晒女朋友，到晒结婚照继而到晒娃。这几年鸣人同志都不负众望当上了火影 (丫也不请吃饭)。大家都在发生变化。</p>
<p>学会开始写点东西分享可能是我想要的一个变化。</p>
<p>本来作为非知名程序员，平时都是自己上 GitHub 玩，自认为比起一干牛人既没本领可以提振民心士气，又没有独门绝技可以分享。直到我收到了一封来自组织的信。</p>
<p>最近我加入了一个公会，里面云集了各类高手，轻功，内力，暗器，大家各有所长，时不时分享下自己的看家本领。还是那句老话，不看不知道，一看吓一跳。世界还是外面的大，姑娘还是城里的靓。在群里，大家都很积极活跃，学习氛围异常的好。其实自打做起程序员起，这么多年来，虽然生性慵懒，但是自学却未敢放下，毕竟逆水行舟，不进则退。不可否认的是一个人的学习是很苦闷无聊的，但一群人陪着你一起苦闷无聊也是很欣慰的。</p>
<p>最后我想引用那封邮件里面的话来表达下我对公会的看法:</p>
<blockquote>
<p>这个社群的意义证明了，在互联网时代，依然有这么多人愿意为知识的积累和个人的成长付费，知识本身的价值得到重新的认知，人们以一种去中心化的方式连接起来，P2P 的创作和分享，可能会让知识和技能的积累、传播达到了一种新的高度、深度和广度</p>
</blockquote>
<p>我想一贯懒散的我为何突然想写这么个 blog 可能也是因为这个，毕竟知识的受益者永远是那些积极参与学习并持续思考的人。</p>
<p>额，最后想说的是，是的，那段引用的文字你没看错，这是个需要付费的群，免费时代的付费群，它叫 <a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=402078207&amp;idx=1&amp;sn=c0b437784c7fc789e06767eedf5cdf87&amp;scene=18#wechat_redirect" target="_blank" rel="external">攻城狮之路</a>。</p>
<p>知识是很昂贵的，我一直这么认为。另外，其实这是篇硬广。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>吕伟（<a href="http://weibo.com/u/1660258615" target="_blank" rel="external">@我在罪恶坑的日子</a>）iOS 开发者，这些年在上海工作。专业：扯淡，兼职：开发。<br>感谢投]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="投稿" scheme="http://blog.devtang.com/tags/%E6%8A%95%E7%A8%BF/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 视图控制器转场详解]]></title>
    <link href="http://blog.devtang.com/2016/03/13/iOS-transition-guide/"/>
    <id>http://blog.devtang.com/2016/03/13/iOS-transition-guide/</id>
    <published>2016-03-13T08:15:47.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：<a href="http://weibo.com/u/1815689155" target="_blank" rel="external">seedante</a>，神秘人士，他的 <a href="https://github.com/seedante" target="_blank" rel="external">GitHub</a>。<br>感谢投稿，<a href="https://github.com/seedante/iOS-Note/wiki/ViewController-Transition" target="_blank" rel="external">原文链接</a>。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>屏幕左边缘右滑返回，TabBar 滑动切换，你是否喜欢并十分依赖这两个操作，甚至觉得 App 不支持这类操作的话简直反人类？这两个操作在大屏时代极大提升了操作效率，其背后的技术便是今天的主题：视图控制器转换(View Controller Transition)。</p>
<p>视图控制器中的视图显示在屏幕上有两种方式：最主要的方式是内嵌在容器控制器中，比如 UINavigationController，UITabBarController, UISplitController；由另外一个视图控制器显示它，这种方式通常被称为模态(Modal)显示。View Controller Transition 是什么？在 NavigationController 里 push 或 pop 一个 View Controller，在 TabBarController 中切换到其他 View Controller，以 Modal 方式显示另外一个 View Controller，这些都是 View Controller Transition。在 storyboard 里，每个 View Controller 是一个 Scene，View Controller Transition 便是从一个 Scene 转换到另外一个 Scene；为方便，以下对 View Controller Transition 的中文称呼采用 Objccn.io 中的翻译「转场」。</p>
<p>在 iOS 7 之前，我们只能使用系统提供的转场效果，大部分时候够用，但仅仅是够用而已，总归会有各种不如意的小地方，但我们却无力改变；iOS 7 开放了相关 API 允许我们对转场效果进行全面定制，这太棒了，自定义转场动画以及对交互手段的支持带来了无限可能。</p>
<p>本文并非华丽的转场动画教程，相反，文中的转场动画效果都十分简单，但本文的内容并不简单，我将带你探索转场背后的机制，缺陷以及实现过程中的技巧与陷阱。阅读本文需要读者至少要对 ViewController 和 View 的结构以及协议有基本的了解，最好自己亲手实现过一两种转场动画。如果你对此感觉没有信心，推荐观看官方文档：<a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1" target="_blank" rel="external">View Controller Programming Guide for iOS</a>，学习此文档将会让你更容易理解本文的内容。对你想学习的小节，我希望你自己亲手写下这些代码，一步步地看着效果是如何实现的，至少对我而言，看各种相关资料时只有字面意义上的理解，正是一步步的试验才能让我理解每一个步骤。本文涉及的内容较多，为了避免篇幅过长，我只给出关键代码而不是从新建工程开始教你每一个步骤。本文基于 Xcode 7 以及 Swift 2，Demo 合集地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo.git" target="_blank" rel="external">iOS-ViewController-Transition-Demo</a>。</p>
<h2 id="Chapter1">Transition 解释</h2>

<p>前言里从行为上解释了转场，那在转场时发生了什么？下图是从 WWDC 2013 Session 218 整理的，解释了转场时视图控制器和其对应的视图在结构上的变化：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/The%20Anatomy%20of%20Transition.png?raw=true" alt="The Anatomy of Transition"></p>
<p>转场过程中，作为容器的父 VC 维护着多个子 VC，但在视图结构上，只保留一个子 VC 的视图，所以转场的本质是下一场景(子 VC)的视图替换当前场景(子 VC)的视图以及相应的控制器(子 VC)的替换，表现为当前视图消失和下一视图出现，基于此进行动画，动画的方式非常多，所以限制最终呈现的效果就只有你的想象力了。图中的 Parent VC 可替换为 UIViewController, UITabbarController 或 UINavigationController 中的任何一种。</p>
<p>目前为止，官方支持以下几种方式的自定义转场：</p>
<ol>
<li>在 UINavigationController 中 push 和 pop;</li>
<li>在 UITabBarController 中切换 Tab;</li>
<li>Modal 转场：presentation 和 dismissal，俗称视图控制器的模态显示和消失，仅限于<code>modalPresentationStyle</code>属性为 UIModalPresentationFullScreen 或 UIModalPresentationCustom 这两种模式;</li>
<li>UICollectionViewController 的布局转场：UICollectionViewController 与 UINavigationController 结合的转场方式，实现很简单。</li>
</ol>
<p>官方的支持包含了 iOS 中的大部分转场方式，还有一种自定义容器中的转场并没有得到系统的直接支持，不过借助协议这种灵活的方式，我们依然能够实现对自定义容器控制器转场的定制，在压轴环节我们将实现这一点。</p>
<p>iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，非常灵活。转场协议由5种协议组成，在实际中只需要我们提供其中的两个或三个便能实现绝大部分的转场动画：</p>
<p>1.<strong>转场代理(Transition Delegate)：</strong></p>
<p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。有如下三种转场代理，对应上面三种类型的转场：</p>
<pre><code>&lt;UINavigationControllerDelegate&gt; //UINavigationController 的 delegate 属性遵守该协议。
&lt;UITabBarControllerDelegate&gt; //UITabBarController 的 delegate 属性遵守该协议。
&lt;UIViewControllerTransitioningDelegate&gt; //UIViewController 的 transitioningDelegate 属性遵守该协议。
</code></pre><p>这里除了<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerTransitioningDelegate_protocol/index.html#//apple_ref/doc/uid/TP40013060" target="_blank" rel="external"><code>&lt;UIViewControllerTransitioningDelegate&gt;</code></a>是 iOS 7 新增的协议，其他两种在 iOS 2 里就存在了，在 iOS 7 时扩充了这两种协议来支持自定义转场。</p>
<p>转场发生时，UIKit 将要求转场代理将提供转场动画的核心构件：动画控制器和交互控制器(可选的)；由我们实现。</p>
<p>2.<strong>动画控制器(Animation Controller)：</strong></p>
<p>最重要的部分，负责添加视图以及执行动画；遵守<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerAnimatedTransitioning_Protocol/index.html#//apple_ref/doc/uid/TP40013387" target="_blank" rel="external"><code>&lt;UIViewControllerAnimatedTransitioning&gt;</code></a>协议；由我们实现。</p>
<p>3.<strong>交互控制器(Interaction Controller)：</strong></p>
<p>通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerInteractiveTransitioning_protocol/index.html#//apple_ref/doc/uid/TP40013059" target="_blank" rel="external"><code>&lt;UIViewControllerInteractiveTransitioning&gt;</code></a>协议；系统已经打包好现成的类供我们使用。</p>
<p>4.<strong>转场环境(Transition Context):</strong></p>
<p>提供转场中需要的数据；遵守<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerContextTransitioning_protocol/index.html#//apple_ref/doc/uid/TP40013057" target="_blank" rel="external"><code>&lt;UIViewControllerContextTransitioning&gt;</code></a>协议；由 UIKit 在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。</p>
<p>5.<strong>转场协调器(Transition Coordinator)：</strong></p>
<p>可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerTransitionCoordinator_Protocol/index.html#//apple_ref/doc/uid/TP40013295" target="_blank" rel="external"><code>&lt;UIViewControllerTransitionCoordinator&gt;</code></a>协议；由 UIKit 在转场时生成，UIViewController 在 iOS 7 中新增了方法<code>transitionCoordinator()</code>返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。</p>
<p>总结下，5个协议只需要我们操心3个；实现一个最低限度可用的转场动画，我们只需要提供上面五个组件里的两个：转场代理和动画控制器即可，还有一个转场环境是必需的，不过这由系统提供；当进一步实现交互转场时，还需要我们提供交互控制器，也有现成的类供我们使用。</p>
<h2 id="Chapter2">阶段一：非交互转场</h2>

<p>这个阶段要做两件事，提供转场代理并由代理提供动画控制器。在转场代理协议里动画控制器和交互控制器都是可选实现的，没有实现或者返回 nil 的话则使用默认的转场效果。动画控制器是表现转场效果的核心部分，代理部分非常简单，我们先搞定动画控制器吧。</p>
<h3 id="Chapter2.1">动画控制器协议</h3>

<p>动画控制器负责添加视图以及执行动画，遵守<code>UIViewControllerAnimatedTransitioning</code>协议，该协议要求实现以下方法：</p>
<pre><code>//执行动画的地方，最核心的方法。
(Required)func animateTransition(_ transitionContext: UIViewControllerContextTransitioning)
//返回动画时间，&quot;return 0.5&quot; 已足够，非常简单，出于篇幅考虑不贴出这个方法的代码实现。
(Required)func transitionDuration(_ transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval
//如果实现了，会在转场动画结束后调用，可以执行一些收尾工作。
(Optional)func animationEnded(_ transitionCompleted: Bool)
</code></pre><p>最重要的是第一个方法，该方法接受一个遵守<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议的转场环境对象，上一节的 API 解释里提到这个协议，它提供了转场所需要的重要数据：参与转场的视图控制器和转场过程的状态信息。</p>
<p>UIKit 在转场开始前生成遵守转场环境协议<code>&lt;UIViewControllerContextTransitioning&gt;</code>的对象 transitionContext，它有以下几个方法来提供动画控制器需要的信息：</p>
<pre><code>//返回容器视图，转场动画发生的地方。
func containerView() -&gt; UIView?
//获取参与转场的视图控制器，有 UITransitionContextFromViewControllerKey 和 UITransitionContextToViewControllerKey 两个 Key。 
func viewControllerForKey(_ key: String) -&gt; UIViewController?
//iOS 8新增 API 用于方便获取参与参与转场的视图，有 UITransitionContextFromViewKey 和 UITransitionContextToViewKey 两个 Key。
func viewForKey(_ key: String) -&gt; UIView? AVAILABLE_IOS(8_0)
</code></pre><p>通过<code>viewForKey:</code>获取的视图是<code>viewControllerForKey:</code>返回的控制器的根视图，或者 nil。<code>viewForKey:</code>方法返回 nil 只有一种情况： UIModalPresentationCustom 模式下的 Modal 转场 ，通过此方法获取 presentingView 时得到的将是 nil，在后面的 Modal 转场里会详细解释。</p>
<p>前面提到转场的本质是下一个场景的视图替换当前场景的视图，从当前场景过渡下一个场景。下面称即将消失的场景的视图为 fromView，对应的视图控制器为 fromVC，即将出现的视图为 toView，对应的视图控制器称之为 toVC。几种转场方式的转场操作都是可逆的，一种操作里的 fromView 和 toView 在逆向操作里的角色互换成对方，fromVC 和 toVC 也是如此。<strong>在动画控制器里，参与转场的视图只有 fromView 和 toView 之分，与转场方式无关。转场动画的最终效果只限制于你的想象力。</strong>这也是动画控制器在封装后可以被第三方使用的重要原因。</p>
<p>在 iOS 8 中可通过以下方法来获取参与转场的三个重要视图，在 iOS 7 中则需要通过对应的视图控制器来获取，为避免 API 差异导致代码过长，示例代码中直接使用下面的视图变量：</p>
<pre><code>let containerView = transitionContext.containerView()
let fromView = transitionContext.viewForKey(UITransitionContextFromViewKey)
let toView = transitionContext.viewForKey(UITransitionContextToViewKey)
</code></pre><h3 id="Chapter2.2">动画控制器实现</h3>

<p>转场 API 是协议的好处是不限制具体的类，只要对象实现该协议便能参与转场过程，这也带来另外一个好处：封装便于复用，尽管三大转场代理协议的方法不尽相同，但它们返回的动画控制器遵守的是同一个协议，因此可以将动画控制器封装作为第三方动画控制器在其他控制器的转场过程中使用。</p>
<p>三种转场方式都有一对可逆的转场操作，你可以为了每一种操作实现单独的动画控制器，也可以实现通用的动画控制器。处于篇幅的考虑，本文示范一个比较简单的 Slide 动画控制器：Slide left and right，而且该动画控制器在三种转场方式中是通用的，不必修改就可以直接在工程中使用。效果示意图：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/SlideAnimation.gif?raw=true" alt="SlideAnimation"></p>
<p>在交互式转场章节里我们将在这个基础上实现文章开头提到的两种效果：NavigationController 右滑返回 和 TabBarController 滑动切换。尽管对动画控制器来说，转场方式并不重要，可以对 fromView 和 toView 进行任何动画，但上面的动画和 Modal 转场风格上有点不配，主要动画的方向不对，不过我在这个 Slide 动画控制器里为 Modal 转场适配了和系统的风格类似的竖直移动动画效果；另外 Modal 转场并没有比较合乎操作直觉的交互手段，而且和前面两种容器控制器的转场在机制上有些不同，所以我将为 Modal 转场示范另外一个动画。</p>
<p>在转场中操作是可逆的，返回操作时的动画应该也是逆向的。对此，Slide 动画控制器需要针对转场的操作类型对动画的方向进行调整。Swift 中 enum 的关联值可以视作有限数据类型的集合体，在这种场景下极其合适。设定转场类型：</p>
<pre><code>enum SDETransitionType{
    //UINavigationControllerOperation 是枚举类型，有 None, Push, Pop 三种值。
    case NavigationTransition(UINavigationControllerOperation) 
    case TabTransition(TabOperationDirection)
    case ModalTransition(ModalOperation)
}

enum TabOperationDirection{
    case Left, Right
}

enum ModalOperation{
    case Presentation, Dismissal
}
</code></pre><p>使用示例：在 TabBarController 中切换到左边的页面。</p>
<pre><code>let transitionType = SDETransitionType.TabTransition(.Left)
</code></pre><p>Slide 动画控制器的核心代码：</p>
<pre><code>class SlideAnimationController: NSObject, UIViewControllerAnimatedTransitioning {
    init(type: SDETransitionType) {...}

    func animateTransition(transitionContext: UIViewControllerContextTransitioning) {
        ...
         //1
        containerView.addSubview(toView)

        //计算位移 transform，NavigationVC 和 TabBarVC 在水平方向进行动画，Modal 转场在竖直方向进行动画。
        var toViewTransform = ...
        var fromViewTransform = ...
        toView.transform = toViewTransform

        //根据协议中的方法获取动画的时间。
        let duration = self.transitionDuration(transitionContext)
        UIView.animateWithDuration(duration, animations: {
            fromView.transform = fromViewTransform
            toView.transform = CGAffineTransformIdentity
            }, completion: { _ in
                //考虑到转场中途可能取消的情况，转场结束后，恢复视图状态。
                fromView.transform = CGAffineTransformIdentity
                toView.transform = CGAffineTransformIdentity
                //2
                let isCancelled = transitionContext.transitionWasCancelled()
                transitionContext.completeTransition(!isCancelled)
        })
    }
}
</code></pre><p>注意上面的代码有2处标记，是动画控制器必须完成的：</p>
<ol>
<li>将 toView 添加到容器视图中，使得 toView 在屏幕上显示( Modal 转场中此点稍有不同，下一节细述)；</li>
<li>正确地结束转场过程。转场的结果有两种：完成或取消。非交互转场的结果只有完成一种情况，不过交互式转场需要考虑取消的情况。如何结束取决于转场的进度，通过<code>transitionWasCancelled()</code>方法来获取转场的状态，使用<code>completeTransition:</code>来完成或取消转场。</li>
</ol>
<p>实际上，这里示范的简单的转场动画和那些很复杂的转场动画在转场的部分要做的事情都是上面提到的这两点，它们的区别主要在于动画的部分。</p>
<p>转场结束后，fromView 会从视图结构中移除，UIKit 自动替我们做了这事，你也可以手动处理提前将 fromView 移除，这完全取决于你。<code>UIView</code>的类方法<code>transitionFromView:toView:duration:options:completion:</code>也能做同样的事，使用下面的代码替换上面的代码，甚至不需要获取 containerView 以及手动添加 toView 就能实现一个类似的转场动画：</p>
<pre><code>UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: { _ in
    let isCancelled = transitionContext.transitionWasCancelled()
    transitionContext.completeTransition(!isCancelled)
})
</code></pre><h3 id="Chapter2.3">特殊的 Modal 转场</h3>

<h4 id="Chapter2.3.1">Modal 转场的差异</h4>

<p>Modal 转场中需要做的事情和两种容器 VC 的转场一样，但在细节上有些差异。</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/ContainerVC%20VS%20Modal.png?raw=true" alt="ContainerVC VS Modal"></p>
<p>UINavigationController 和 UITabBarController 这两个容器 VC 的根视图在屏幕上是不可见的(或者说是透明的)，可见的只是内嵌在这两者中的子 VC 中的视图，转场是从子 VC 的视图转换到另外一个子 VC 的视图，其根视图并未参与转场；而 Modal 转场，以 presentation 为例，是从 presentingView 转换到 presentedView，根视图 presentingView 也就是 fromView 参与了转场。而且 NavigationController 和 TabBarController 转场中的 containerView 也并非这两者的根视图。</p>
<p>Modal 转场与两种容器 VC 的转场的另外一个不同是：Modal 转场结束后 presentingView 可能依然可见，UIModalPresentationPageSheet 模式就是这样。这种不同导致了 Modal 转场和容器 VC 的转场对 fromView 的处理差异：容器 VC 的转场结束后 fromView 会被主动移出视图结构，这是可预见的结果，我们也可以在转场结束前手动移除；而 Modal 转场中，presentation 结束后 presentingView(fromView) 并未主动被从视图结构中移除。准确来说，是 UIModalPresentationCustom 这种模式下的 Modal 转场结束时 fromView 并未从视图结构中移除；UIModalPresentationFullScreen 模式的 Modal 转场结束后 fromView 依然主动被从视图结构中移除了。这种差异导致在处理 dismissal 转场的时候很容易出现问题，没有意识到这个不同点的话出错时就会毫无头绪。下面来看看 dismissal 转场时的场景。</p>
<p>ContainerView 在转场期间作为 fromView 和 toView 的父视图。三种转场过程中的 containerView 是 UIView 的私有子类，不过我们并不需要关心 containerView 具体是什么。在 dismissal 转场中：</p>
<ol>
<li>UIModalPresentationFullScreen 模式：presentation 后，presentingView 被主动移出视图结构，在 dismissal 中 presentingView 是 toView 的角色，其将会重新加入 containerView 中，实际上，我们不主动将其加入，UIKit 也会这么做，前面的两种容器控制器的转场里不是这样处理的，不过这个差异基本没什么影响。</li>
<li>UIModalPresentationCustom 模式：转场时 containerView 并不担任 presentingView 的父视图，后者由 UIKit 另行管理。在 presentation 后，fromView(presentingView) 未被移出视图结构，在 dismissal 中，注意不要像其他转场中那样将 toView(presentingView) 加入 containerView 中，否则本来可见的 presentingView 将会被移除出自身所处的视图结构消失不见。如果你在使用 Custom 模式时没有注意到这点，就很容易掉进这个陷阱而很难察觉问题所在，这个问题曾困扰了我一天。</li>
</ol>
<p>对于 Custom 模式，我们可以参照其他转场里的处理规则来打理：presentation 转场结束后主动将 fromView(presentingView) 移出它的视图结构，并用一个变量来维护 presentingView 的父视图，以便在 dismissal 转场中恢复；在 dismissal 转场中，presentingView 的角色由原来的 fromView 切换成了 toView，我们再将其重新恢复它原来的视图结构中。测试表明这样做是可行的。但是这样一来，在实现上，需要在转场代理中维护一个动画控制器并且这个动画控制器要维护 presentingView 的父视图，第三方的动画控制器必须为此改造。显然，这样的代价是无法接受的。</p>
<p><strong>小结</strong>：经过上面的尝试，建议是，不要干涉官方对 Modal 转场的处理，我们去适应它。在 Custom 模式下，由于 presentingView 不受 containerView 管理，在 dismissal 转场中不要像其他的转场那样将 toView(presentingView) 加入 containerView，否则 presentingView 将消失不见，而应用则也很可能假死；而在 presentation 转场中，切记不要手动将 fromView(presentingView) 移出其父视图。</p>
<p>iOS 8 为<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议添加了<code>viewForKey:</code>方法以方便获取 fromView 和 toView，但是在 Modal 转场里要注意，从上面可以知道，Custom 模式下，presentingView 并不受 containerView 管理，这时通过<code>viewForKey:</code>方法来获取 presentingView 得到的是 nil，必须通过<code>viewControllerForKey:</code>得到 presentingVC 后来获取。因此在 Modal 转场中，较稳妥的方法是从 fromVC 和 toVC 中获取 fromView 和 toView。</p>
<p>顺带一提，前面提到的<code>UIView</code>的类方法<code>transitionFromView:toView:duration:options:completion:</code>能在 Custom 模式下工作，却与 FullScreen 模式有点不兼容。</p>
<h4 id="Chapter2.3.2">Modal 转场实践</h4>

<p>UIKit 已经为 Modal 转场实现了多种效果，当 UIViewController 的<code>modalPresentationStyle</code>属性为<code>.Custom</code> 或<code>.FullScreen</code>时，我们就有机会定制转场效果，此时<code>modalTransitionStyle</code>指定的转场动画将会被忽略。</p>
<p>Modal 转场开放自定义功能后最令人感兴趣的是定制 presentedView 的尺寸，下面来我们来实现一个带暗色调背景的小窗口效果。Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CustomModalTransition" target="_blank" rel="external">CustomModalTransition</a>。</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/ModalTransition.gif?raw=true" alt="ModalTransition"></p>
<p>由于需要保持 presentingView 可见，这里的 Modal 转场应该采用 UIModalPresentationCustom 模式，此时 presentedVC 的<code>modalPresentationStyle</code>属性值应设置为<code>.Custom</code>。而且与容器 VC 的转场的代理由容器 VC 自身的代理提供不同，Modal 转场的代理由 presentedVC 提供。动画控制器的核心代码：</p>
<pre><code>class OverlayAnimationController: NSobject, UIViewControllerAnimatedTransitioning{
    ... 
    func animateTransition(transitionContext: UIViewControllerContextTransitioning) {            
        ...
        //不像容器 VC 转场里需要额外的变量来标记操作类型，UIViewController 自身就有方法跟踪 Modal 状态。
        //处理 Presentation 转场：
        if toVC.isBeingPresented(){
            //1
            containerView.addSubview(toView)
            //在 presentedView 后面添加暗背景视图 dimmingView，注意两者在 containerView 中的位置。
            let dimmingView = UIView()
            containerView.insertSubview(dimmingView, belowSubview: toView)

            //设置 presentedView 和 暗背景视图 dimmingView 的初始位置和尺寸。
            let toViewWidth = containerView.frame.width * 2 / 3
            let toViewHeight = containerView.frame.height * 2 / 3
            toView.center = containerView.center
            toView.bounds = CGRect(x: 0, y: 0, width: 1, height: toViewHeight)

            dimmingView.backgroundColor = UIColor(white: 0.0, alpha: 0.5)
            dimmingView.center = containerView.center
            dimmingView.bounds = CGRect(x: 0, y: 0, width: toViewWidth, height: toViewHeight)

            //实现出现时的尺寸变化的动画：
            UIView.animateWithDuration(duration, delay: 0, options: .CurveEaseInOut, animations: {
                toView.bounds = CGRect(x: 0, y: 0, width: toViewWidth, height: toViewHeight)
                dimmingView.bounds = containerView.bounds
                }, completion: {_ in
                    //2
                    let isCancelled = transitionContext.transitionWasCancelled()
                    transitionContext.completeTransition(!isCancelled)
            })
        }
        //处理 Dismissal 转场，按照上一小节的结论，.Custom 模式下不要将 toView 添加到 containerView，省去了上面标记1处的操作。
        if fromVC.isBeingDismissed(){
            let fromViewHeight = fromView.frame.height
            UIView.animateWithDuration(duration, animations: {
                fromView.bounds = CGRect(x: 0, y: 0, width: 1, height: fromViewHeight)
                }, completion: { _ in
                    //2
                    let isCancelled = transitionContext.transitionWasCancelled()
                    transitionContext.completeTransition(!isCancelled)
            })
        }
    }
}
</code></pre><h4 id="Chapter2.3.3">iOS 8的改进：UIPresentationController</h4>

<p>iOS 8 针对分辨率日益分裂的 iOS 设备带来了新的适应性布局方案，以往有些专为在 iPad 上设计的控制器也能在 iPhone 上使用了，一个大变化是在视图控制器的(模态)显示过程，包括转场过程，引入了<code>UIPresentationController</code>类，该类接管了 UIViewController 的显示过程，为其提供转场和视图管理支持。当 UIViewController 的<code>modalPresentationStyle</code>属性为<code>.Custom</code>时(不支持<code>.FullScreen</code>)，我们有机会通过控制器的转场代理提供<code>UIPresentationController</code>的子类对 Modal 转场进行进一步的定制。官方对该类参与转场的流程和使用方法有非常详细的说明：<a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1" target="_blank" rel="external">Creating Custom Presentations</a>。</p>
<p><code>UIPresentationController</code>类主要给 Modal 转场带来了以下几点变化：</p>
<ol>
<li>定制 presentedView 的外观：设定 presentedView 的尺寸以及在 containerView 中添加自定义视图并为这些视图添加动画；</li>
<li>可以选择是否移除 presentingView；</li>
<li>可以在不需要动画控制器的情况下单独工作；</li>
<li>iOS 8 中的适应性布局。</li>
</ol>
<p>以上变化中第1点 iOS 7 中也能做到，3和4是 iOS 8 带来的新特性，只有第2点才真正解决了 iOS 7 中的痛点。在 iOS 7 中定制外观时，动画控制器需要负责管理额外添加的的视图，<code>UIPresentationController</code>类将该功能剥离了出来独立负责，其提供了如下的方法参与转场，对转场过程实现了更加细致的控制，从命名便可以看出与动画控制器里的<code>animateTransition:</code>的关系：</p>
<pre><code>func presentationTransitionWillBegin()
func presentationTransitionDidEnd(_ completed: Bool)
func dismissalTransitionWillBegin()
func dismissalTransitionDidEnd(_ completed: Bool)
</code></pre><p>除了 presentingView，<code>UIPresentationController</code>类拥有转场过程中剩下的角色：</p>
<pre><code>//指定初始化方法。
init(presentedViewController presentedViewController: UIViewController, presentingViewController presentingViewController: UIViewController)
var presentingViewController: UIViewController { get }
var presentedViewController: UIViewController { get }
var containerView: UIView? { get }
//提供给动画控制器使用的视图，默认返回 presentedVC.view，通过重写该方法返回其他视图，但一定要是 presentedVC.view 的上层视图。
func presentedView() -&gt; UIView?     
</code></pre><p>没有 presentingView 是因为 Custom 模式下 presentingView 不受 containerView 管理，<code>UIPresentationController</code>类并没有改变这一点。iOS 8 扩充了转场环境协议，可以通过<code>viewForKey:</code>方便获取转场的视图，而该方法在 Modal 转场中获取的是<code>presentedView()</code>返回的视图。因此我们可以在子类中将 presentedView 包装在其他视图后重写该方法返回包装后的视图当做 presentedView 在动画控制器中使用。</p>
<p>接下来，我用<code>UIPresentationController</code>子类实现上一节「Modal 转场实践」里的效果，presentingView 和 presentedView 的动画由动画控制器负责，剩下的事情可以交给我们实现的子类来完成。</p>
<p>参与角色都准备好了，但有个问题，无法直接访问动画控制器，不知道转场的持续时间，怎么与转场过程同步？这时候前面提到的用处甚少的转场协调器(Transition Coordinator)将在这里派上用场。该对象可通过 UIViewController 的<code>transitionCoordinator()</code>方法获取，这是 iOS 7 为自定义转场新增的 API，该方法只在控制器处于转场过程中才返回一个与当前转场有关的有效对象，其他时候返回 nil。</p>
<p>转场协调器遵守<code>&lt;UIViewControllerTransitionCoordinator&gt;</code>协议，它含有以下几个方法：</p>
<pre><code>//与动画控制器中的转场动画同步，执行其他动画
animateAlongsideTransition:completion:
//与动画控制器中的转场动画同步，在指定的视图内执行动画
animateAlongsideTransitionInView:animation:completion:
</code></pre><p>由于转场协调器的这种特性，动画的同步问题解决了。</p>
<pre><code>class OverlayPresentationController: UIPresentationController {
    let dimmingView = UIView()

    //Presentation 转场开始前该方法被调用。
    override func presentationTransitionWillBegin() {
        self.containerView?.addSubview(dimmingView)

        let initialWidth = containerView!.frame.width*2/3, initialHeight = containerView!.frame.height*2/3
        self.dimmingView.backgroundColor = UIColor(white: 0.0, alpha: 0.5)
        self.dimmingView.center = containerView!.center
        self.dimmingView.bounds = CGRect(x: 0, y: 0, width: initialWidth , height: initialHeight)
        //使用 transitionCoordinator 与转场动画并行执行 dimmingView 的动画。
        presentedViewController.transitionCoordinator()?.animateAlongsideTransition({ _ in
            self.dimmingView.bounds = self.containerView!.bounds
        }, completion: nil)
    }
    //Dismissal 转场开始前该方法被调用。添加了 dimmingView 消失的动画，在上一节中并没有添加这个动画，
    //实际上由于 presentedView 的形变动画，这个动画根本不会被注意到，此处只为示范。
    override func dismissalTransitionWillBegin() {
        presentedViewController.transitionCoordinator()?.animateAlongsideTransition({ _ in
            self.dimmingView.alpha = 0.0
            }, completion: nil)
    }    
}
</code></pre><p><code>OverlayPresentationController</code>类接手了 dimmingView 的工作后，需要回到上一节<code>OverlayAnimationController</code>里把涉及 dimmingView 的部分删除，然后在 presentedVC 的转场代理属性<code>transitioningDelegate</code>中提供该类实例就可以实现和上一节同样的效果。</p>
<pre><code>func presentationControllerForPresentedViewController(_ presented: UIViewController, 
                              presentingViewController presenting: UIViewController, 
                                      sourceViewController source: UIViewController) -&gt; UIPresentationController?{
    return OverlayPresentationController(presentedViewController: presented, presentingViewController: presenting)
}
</code></pre><p>在 iOS 7 中，Custom 模式的 Modal 转场里，presentingView 不会被移除，如果我们要移除它并妥善恢复会破坏动画控制器的独立性使得第三方动画控制器无法直接使用；在 iOS 8 中，<code>UIPresentationController</code>解决了这点，给予了我们选择的权力，通过重写下面的方法来决定 presentingView 是否在 presentation 转场结束后被移除：</p>
<pre><code>func shouldRemovePresentersView() -&gt; Bool
</code></pre><p>返回 true 时，presentation 结束后 presentingView 被移除，在 dimissal 结束后 UIKit 会自动将 presentingView 恢复到原来的视图结构中。通过<code>UIPresentationController</code>的参与，Custom 模式完全实现了 FullScreen 模式下的全部特性。</p>
<p>你可能会疑惑，除了解决了 iOS 7中无法干涉 presentingView 这个痛点外，还有什么理由值得我们使用<code>UIPresentationController</code>类？除了能与动画控制器配合，<code>UIPresentationController</code>类也能脱离动画控制器独立工作，在转场代理里我们仅仅提供后者也能对 presentedView 的外观进行定制，缺点是无法控制 presentedView 的转场动画，因为这是动画控制器的职责，这种情况下，presentedView 的转场动画采用的是默认的动画效果，转场协调器实现的动画则是采用默认的动画时间。</p>
<p>iOS 8 带来了适应性布局，<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIContentContainer_Ref/index.html#//apple_ref/doc/uid/TP40014526" target="_blank" rel="external"><code>&lt;UIContentContainer&gt;</code></a>协议用于响应视图尺寸变化和屏幕旋转事件，之前用于处理屏幕旋转的方法都被废弃了。UIViewController 和 UIPresentationController 类都遵守该协议，在 Modal 转场中如果提供了后者，则由后者负责前者的尺寸变化和屏幕旋转，最终的布局机会也在后者里。在<code>OverlayPresentationController</code>中重写以下方法来调整视图布局以及应对屏幕旋转：</p>
<pre><code>override func containerViewWillLayoutSubviews() {
    self.dimmingView.center = self.containerView!.center
    self.dimmingView.bounds = self.containerView!.bounds

    let width = self.containerView!.frame.width * 2 / 3, height = self.containerView!.frame.height * 2 / 3
    self.presentedView()?.center = self.containerView!.center
    self.presentedView()?.bounds = CGRect(x: 0, y: 0, width: width, height: height)
}
</code></pre><h3 id="Chapter2.4">转场代理</h3>

<p>完成动画控制器后，只需要在转场前设置好转场代理便能实现动画控制器中提供的效果。转场代理的实现很简单，但是在设置代理时有不少陷阱，需要注意。</p>
<h4 id="Chapter2.4.1">UINavigationControllerDelegate</h4>

<p>定制 UINavigationController 这种容器控制器的转场时，很适合实现一个子类，自身集转场代理，动画控制器于一身，也方便使用，不过这样做有时候又限制了它的使用范围，别人也实现了自己的子类时便不能方便使用你的效果，这里采取的是将转场代理封装成一个类。</p>
<pre><code>class SDENavigationControllerDelegate: NSObject, UINavigationControllerDelegate {
    //在&lt;UINavigationControllerDelegate&gt;对象里，实现该方法提供动画控制器，返回 nil 则使用系统默认的效果。
    func navigationController(navigationController: UINavigationController, 
         animationControllerForOperation operation: UINavigationControllerOperation, 
                         fromViewController fromVC: UIViewController, 
                             toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
        //使用上一节实现的 Slide 动画控制器，需要提供操作类型信息。
        let transitionType = SDETransitionType.NavigationTransition(operation)
        return SlideAnimationController(type: transitionType)
    }
}
</code></pre><p>如果你在代码里为你的控制器里这样设置代理：</p>
<pre><code>//错误的做法，delegate 是弱引用，在离开这行代码所处的方法范围后，delegate 将重新变为 nil，然后什么都不会发生。
self.navigationController?.delegate = SDENavigationControllerDelegate()
</code></pre><p>可以使用强引用的变量来引用新实例，且不能使用本地变量，在控制器中新增一个变量来维持新实例就可以了。</p>
<pre><code>self.navigationController?.delegate = strongReferenceDelegate
</code></pre><p>解决了弱引用的问题，这行代码应该放在哪里执行呢？很多人喜欢在<code>viewDidLoad()</code>做一些配置工作，但在这里设置无法保证是有效的，因为这时候控制器可能尚未进入 NavigationController 的控制器栈，<code>self.navigationController</code>返回的可能是 nil；如果是通过代码 push 其他控制器，在 push 前设置即可；<code>prepareForSegue:sender:</code>方法是转场前更改设置的最后一次机会，可以在这里设置；保险点，使用<code>UINavigationController</code>子类，自己作为代理，省去到处设置的麻烦。</p>
<p>不过，通过代码设置终究显得很繁琐且不安全，在 storyboard 里设置一劳永逸：在控件库里拖拽一个 NSObject 对象到相关的 UINavigationControler 上，在控制面板里将其类别设置为<code>SDENavigationControllerDelegate</code>，然后拖拽鼠标将其设置为代理。</p>
<p>最后一步，像往常一样触发转场：</p>
<pre><code>self.navigationController?.pushViewController(toVC, animated: true)//or
self.navigationController?.popViewControllerAnimated(true)
</code></pre><p>在 storyboard 中通过设置 segue 时开启动画也将看到同样的 Slide 动画。Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/NavigationControllerTransition" target="_blank" rel="external">NavigationControllerTransition</a>。</p>
<h4 id="Chapter2.4.2">UITabBarControllerDelegate</h4>

<p>同样作为容器控制器，UITabBarController 的转场代理和 UINavigationController 类似，通过类似的方法提供动画控制器，不过<code>&lt;UINavigationControllerDelegate&gt;</code>的代理方法里提供了操作类型，但<code>&lt;UITabBarControllerDelegate&gt;</code>的代理方法没有提供滑动的方向信息，需要我们来获取滑动的方向。</p>
<pre><code>class SDETabBarControllerDelegate: NSObject, UITabBarControllerDelegate {
    //在&lt;UITabBarControllerDelegate&gt;对象里，实现该方法提供动画控制器，返回 nil 则没有动画效果。
    func tabBarController(tabBarController: UITabBarController, animationControllerForTransitionFromViewController 
                                    fromVC: UIViewController, 
                     toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?{
        let fromIndex = tabBarController.viewControllers!.indexOf(fromVC)!
        let toIndex = tabBarController.viewControllers!.indexOf(toVC)!

        let tabChangeDirection: TabOperationDirection = toIndex &lt; fromIndex ? .Left : .Right
        let transitionType = SDETransitionType.TabTransition(tabChangeDirection)
        let slideAnimationController = SlideAnimationController(type: transitionType)
        return slideAnimationController
    }
}
</code></pre><p>为 UITabBarController 设置代理的方法和陷阱与上面的 UINavigationController 类似，注意<code>delegate</code>属性的弱引用问题。点击 TabBar 的相邻页面进行切换时，将会看到 Slide 动画；通过以下代码触发转场时也将看到同样的效果：</p>
<pre><code>tabBarVC.selectedIndex = ...//or
tabBarVC.selectedViewController = ...
</code></pre><p>Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/ScrollTabBarController" target="_blank" rel="external">ScrollTabBarController</a>。</p>
<h4 id="Chapter2.4.3">UIViewControllerTransitioningDelegate</h4>

<p>Modal 转场的代理协议<code>&lt;UIViewControllerTransitioningDelegate&gt;</code>是 iOS 7 新增的，其为 presentation 和 dismissal 转场分别提供了动画控制器。在「特殊的 Modal 转场」里实现的<code>OverlayAnimationController</code>类可同时处理 presentation 和 dismissal 转场。<code>UIPresentationController</code>只在 iOS 8中可用，通过<code>available</code>关键字可以解决 API 的版本差异。 </p>
<pre><code>class SDEModalTransitionDelegate: NSObject, UIViewControllerTransitioningDelegate {
    func animationControllerForPresentedController(presented: UIViewController, 
                             presentingController presenting: UIViewController, 
                                     sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
        return OverlayAnimationController()
    }

    func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
        return OverlayAnimationController()
    }

    @available(iOS 8.0, *)
    func presentationControllerForPresentedViewController(presented: UIViewController, 
                                presentingViewController presenting: UIViewController, 
                                        sourceViewController source: UIViewController) -&gt; UIPresentationController? {
        return OverlayPresentationController(presentedViewController: presented, presentingViewController: presenting)
    }
}
</code></pre><p>Modal 转场的代理由 presentedVC 的<code>transitioningDelegate</code>属性来提供，这与前两种容器控制器的转场不一样，不过该属性作为代理同样是弱引用，记得和前面一样需要有强引用的变量来维护该代理，而 Modal 转场需要 presentedVC 来提供转场代理的特性使得 presentedVC 自身非常适合作为自己的转场代理。另外，需要将 presentedVC 的<code>modalPresentationStyle</code>属性设置为<code>.Custom</code>或<code>.FullScreen</code>，只有这两种模式下才支持自定义转场，该属性默认值为<code>.FullScreen</code>。自定义转场时，决定转场动画效果的<code>modalTransitionStyle</code>属性将被忽略。</p>
<p>开启转场动画的方式依然是两种：在 storyboard 里设置 segue 并开启动画，但这里并不支持<code>.Custom</code>模式，不过还有机会挽救，转场前的最后一个环节<code>prepareForSegue:sender:</code>方法里可以动态修改<code>modalPresentationStyle</code>属性；或者全部在代码里设置，示例如下：</p>
<pre><code>let presentedVC = ...
presentedVC.transitioningDelegate = strongReferenceSDEModalTransitionDelegate
//当与 UIPresentationController 配合时该属性必须为.Custom。
presentedVC.modalPresentationStyle = .Custom/.FullScreen      
presentingVC.presentViewController(presentedVC, animated: true, completion: nil)
</code></pre><p>Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CustomModalTransition" target="_blank" rel="external">CustomModalTransition</a>。</p>
<h2 id="Chapter3">阶段二：交互式转场</h2>

<p>激动人心的部分来了，好消息是交互转场的实现难度比你想象的要低。</p>
<h3 id="Chapter3.1">实现交互化</h3>

<p>在非交互转场的基础上将之交互化需要两个条件：</p>
<ol>
<li><p>由转场代理提供交互控制器，这是一个遵守<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>协议的对象，不过系统已经打包好了现成的类<code>UIPercentDrivenInteractiveTransition</code>供我们使用。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。</p>
</li>
<li><p>交互控制器还需要交互手段的配合，最常见的是使用手势，或是其他事件，来驱动整个转场进程。</p>
</li>
</ol>
<p>满足以上两个条件很简单，但是很容易犯错误。</p>
<p><strong>正确地提供交互控制器</strong>：</p>
<p>如果在转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程(比如手势)，转场过程将一直处于开始阶段无法结束，应用界面也会失去响应：在 NavigationController 中点击 NavigationBar 也能实现 pop 返回操作，但此时没有了交互手段的支持，转场过程卡壳；在 TabBarController 的代理里提供交互控制器存在同样的问题，点击 TabBar 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。</p>
<p>以为 NavigationController 提供交互控制器为例：</p>
<pre><code>class SDENavigationDelegate: NSObject, UINavigationControllerDelegate {
    var interactive = false
    let interactionController = UIPercentDrivenInteractiveTransition()
    ...

    func navigationController(navigationController: UINavigationController, interactionControllerForAnimationController 
                               animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? {
        return interactive ? self.interactionController : nil
    }
}
</code></pre><p>TabBarController 的实现类似，Modal 转场代理分别为 presentation 和 dismissal 提供了各自的交互控制器，也需要注意上面的问题。</p>
<p>问题的根源是交互控制的工作机制导致的，交互过程实际上是由转场环境对象<code>&lt;UIViewControllerContextTransitioning&gt;</code>来管理的，它提供了如下几个方法来控制转场的进度：</p>
<pre><code>func updateInteractiveTransition(_ percentComplete: CGFloat)//更新转场进度，进度数值范围为0.0~1.0。
func cancelInteractiveTransition()//取消转场，转场动画从当前状态返回至转场发生前的状态。
func finishInteractiveTransition()//完成转场，转场动画从当前状态继续直至结束。
</code></pre><p>交互控制协议<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>只有一个必须实现的方法：</p>
<pre><code>func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning)
</code></pre><p>在转场代理里提供了交互控制器后，转场开始时，该方法自动被 UIKit 调用对转场环境进行配置。</p>
<p>系统打包好的<code>UIPercentDrivenInteractiveTransition</code>中的控制转场进度的方法与转场环境对象提供的三个方法同名，实际上只是前者调用了后者的方法而已。系统以一种解耦的方式使得动画控制器，交互控制器，转场环境对象互相协作，我们只需要使用<code>UIPercentDrivenInteractiveTransition</code>的三个同名方法来控制进度就够了。如果你要实现自己的交互控制器，而不是<code>UIPercentDrivenInteractiveTransition</code>的子类，就需要调用转场环境的三个方法来控制进度，压轴环节我们将示范如何做。</p>
<p>交互控制器控制转场的过程就像将动画控制器实现的动画制作成一部视频，我们使用手势或是其他方法来控制转场动画的播放，可以前进，后退，继续或者停止。<code>finishInteractiveTransition()</code>方法被调用后，转场动画从当前的状态将继续进行直到动画结束，转场完成；<code>cancelInteractiveTransition()</code>被调用后，转场动画从当前的状态回拨到初始状态，转场取消。</p>
<p>在 NavigationController 中点击 NavigationBar 的 backBarButtomItem 执行 pop 操作时，由于我们无法介入 backBarButtomItem 的内部流程，就失去控制进度的手段，于是转场过程只有一个开始，永远不会结束。其实我们只需要有能够执行上述几个方法的手段就可以对转场动画进行控制，用户与屏幕的交互手段里，手势是实现这个控制过程的天然手段，我猜这是其被称为交互控制器的原因。</p>
<p><strong>交互手段的配合</strong>：</p>
<p>下面使用演示如何利用屏幕边缘滑动手势<code>UIScreenEdgePanGestureRecognizer</code>在 NavigationController 中控制 Slide 动画控制器提供的动画来实现右滑返回的效果，该手势绑定的动作方法如下：</p>
<pre><code>func handleEdgePanGesture(gesture: UIScreenEdgePanGestureRecognizer){
    //根据移动距离计算交互过程的进度。
    let percent = ...
    switch gesture.state{
    case .Began:
        //转场开始前获取代理，一旦转场开始，VC 将脱离控制器栈，此后 self.navigationController 返回的是 nil。
        self.navigationDelegate = self.navigationController?.delegate as? SDENavigationDelegate
        //更新交互状态
        self.navigationDelegate?.interactive = true
        //1.交互控制器没有 start 之类的方法，当下面这行代码执行后，转场开始；
        //如果转场代理提供了交互控制器，它将从这时候开始接管转场过程。
        self.navigationController?.popViewControllerAnimated(true)
    case .Changed:
        //2.更新进度：
        self.navigationDelegate?.interactionController.updateInteractiveTransition(percent)
    case .Cancelled, .Ended:
        //3.结束转场：
        if percent &gt; 0.5{
            //完成转场。
            self.navigationDelegate?.interactionController.finishInteractiveTransition()
        }else{
            //或者，取消转场。
            self.navigationDelegate?.interactionController.cancelInteractiveTransition()
        }
        //无论转场的结果如何，恢复为非交互状态。
        self.navigationDelegate?.interactive = false
    default: self.navigationDelegate?.interactive = false
    }
}
</code></pre><p>交互转场的流程就是三处数字标记的代码。不管是什么交互方式，使用什么转场方式，都是在使用这三个方法控制转场的进度。<strong>对于交互式转场，交互手段只是表现形式，本质是驱动转场进程。</strong>很希望能够看到更新颖的交互手法，比如通过点击页面不同区域来控制一套复杂的流程动画。TabBarController 的 Demo 中也实现了滑动切换 Tab 页面，代码是类似的，就不占篇幅了；示范的 Modal 转场我没有为之实现交互控制，原因也提到过了，没有比较合乎操作直觉的交互手段，不过真要为其添加交互控制，代码和上面是类似的。</p>
<p>转场交互化后结果有两种：完成和取消。取消后动画将会原路返回到初始状态，但已经变化了的数据怎么恢复？</p>
<p>一种情况是，控制器的系统属性，比如，在 TabBarController 里使用上面的方法实现滑动切换 Tab 页面，中途取消的话，已经变化的<code>selectedIndex</code>属性该怎么恢复为原值；上面的代码里，取消转场的代码执行后，<code>self.navigationController</code>返回的依然还是是 nil，怎么让控制器回到 NavigationController 的控制器栈顶。对于这种情况，UIKit 自动替我们恢复了，不需要我们操心(可能你都没有意识到这回事)；</p>
<p>另外一种就是，转场发生的过程中，你可能想实现某些效果，一般是在下面的事件中执行，转场中途取消的话可能需要取消这些效果。</p>
<pre><code>func viewWillAppear(_ animated: Bool)
func viewDidAppear(_ animated: Bool)
func viewWillDisappear(_ animated: Bool)
func viewDidDisappear(_ animated: Bool)
</code></pre><p>交互转场介入后，视图在这些状态间的转换变得复杂，WWDC 上苹果的工程师还表示转场过程中 view 的<code>Will</code>系方法和<code>Did</code>系方法的执行顺序并不能得到保证，虽然几率很小，但如果你依赖于这些方法执行的顺序的话就可能需要注意这点。而且，<code>Did</code>系方法调用时并不意味着转场过程真的结束了。另外，fromView 和 toView 之间的这几种方法的相对顺序更加混乱，具体的案例可以参考这里：<a href="http://wangling.me/2014/02/the-inconsistent-order-of-view-transition-events.html" target="_blank" rel="external">The Inconsistent Order of View Transition Events</a>。</p>
<p>如何在转场过程中的任意阶段中断时取消不需要的效果？这时候该转场协调器(Transition Coordinator)再次出场了。</p>
<h3 id="Chapter3.2">Transition Coordinator</h3>

<p>转场协调器(Transition Coordinator)的出场机会不多，但却是关键先生。Modal<br>转场中，<code>UIPresentationController</code>类只能通过转场协调器来与动画控制器同步，并行执行其他动画；这里它可以在交互式转场结束时执行一个闭包：</p>
<pre><code>func notifyWhenInteractionEndsUsingBlock(_ handler: (UIViewControllerTransitionCoordinatorContext) -&gt; Void)
</code></pre><p>当转场由交互状态转变为非交互状态(在手势交互过程中则为手势结束时)，无论转场的结果是完成还是被取消，该方法都会被调用；得益于闭包，转场协调器可以在转场过程中的任意阶段搜集动作并在交互中止后执行。闭包中的参数是一个遵守<code>&lt;UIViewControllerTransitionCoordinatorContext&gt;</code>协议的对象，该对象由 UIKit 提供，和前面的转场环境对象<code>&lt;UIViewControllerContextTransitioning&gt;</code>作用类似，它提供了交互转场的状态信息。</p>
<pre><code>override func viewWillAppear(animated: Bool) {
    super.viewWillDisappear(animated)
    self.doSomeSideEffectsAssumingViewDidAppearIsGoingToBeCalled()
    //只在处于交互转场过程中才可能取消效果。
    if let coordinator = self.transitionCoordinator() where coordinator.initiallyInteractive() == true{
        coordinator.notifyWhenInteractionEndsUsingBlock({
            interactionContext in
            if interactionContext.isCancelled(){
                self.undoSideEffects()
            }
        })
    }
}
</code></pre><p>不过交互状态结束时并非转场过程的终点(此后动画控制器提供的转场动画根据交互结束时的状态继续或是返回到初始状态)，而是由动画控制器来结束这一切：</p>
<pre><code>optional func animationEnded(_ transitionCompleted: Bool)
</code></pre><p>如果实现了该方法，将在转场动画结束后调用。</p>
<p>UIViewController 可以通过<code>transitionCoordinator()</code>获取转场协调器，该方法的文档中说只有在 Modal 转场过程中，该方法才返回一个与当前转场相关的有效对象。实际上，NavigationController 的转场中 fromVC 和 toVC 也能返回一个有效对象，TabBarController 有点特殊，fromVC 和 toVC 在转场中返回的是 nil，但是作为容器的 TabBarController 可以使用该方法返回一个有效对象。</p>
<p>转场协调器除了上面的两种关键作用外，也在 iOS 8 中的适应性布局中担任重要角色，可以查看<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIContentContainer_Ref/index.html#//apple_ref/doc/uid/TP40014526" target="_blank" rel="external"><code>&lt;UIContentContainer&gt;</code></a>协议中的方法，其中响应尺寸和屏幕旋转事件的方法都包含一个转场协调器对象，视图的这种变化也被系统视为广义上的 transition，参数中的转场协调器也由 UIKit 提供。这个话题有点超出本文的范围，就不深入了，有需要的话可以查看文档和相关 session。</p>
<h3 id="Chapter3.3">封装交互控制器</h3>

<p><code>UIPercentDrivenInteractiveTransition</code>类是一个系统提供的交互控制器，在转场代理的相关方法里提供一个该类实例就够了，还有其他需求的话可以实现其子类来完成，那这里的封装是指什么？系统把交互控制器打包好了，但是交互控制器工作还需要其他的配置。程序员向来很懒，能够自动完成的事绝不肯写一行代码，写一行代码就能搞定的事绝不写第二行，所谓少写一行是一行。能不能顺便把交互控制器的配置也打包好省得写代码啊？当然可以。</p>
<p>热门转场动画库 <a href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller" target="_blank" rel="external">VCTransitionsLibrary</a> 封装好了多种动画效果，并且自动支持 pop, dismissal 和 tab change 等操作的手势交互，其手法是在转场代理里为 toVC 添加手势并绑定相应的处理方法。</p>
<p>为何没有支持 push 和 presentation 这两种转场？因为 push 和 presentation 这两种转场需要提供 toVC，而库并没有 toVC 的信息，这需要作为使用者的开发者来提供；对于逆操作的 pop 和 dismiss，toVC 的信息已经存在了，所以能够实现自动支持。而 TabBarController 则是个例外，它是在已知的子 VC 之间切换，不存在这个问题。需要注意的是，库这样封装了交互控制器后，那么你将无法再让同一种手势支持 push 或 presentation，要么只支持单向的转场，要么你自己实现双向的转场。当然，如果知道 toVC 是什么类的话，你可以改写这个库让 push 和 present 得到支持。不过，对于在初始化时需要配置额外信息的类，这种简单的封装可能不起作用。<a href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller" target="_blank" rel="external">VCTransitionsLibrary</a> 库还支持添加自定义的简化版的动画控制器和交互控制器，在封装和灵活之间的平衡控制得很好，代码非常值得学习。</p>
<p>只要愿意，我们还可以变得更懒，不，是效率更高。<a href="https://github.com/forkingdog/FDFullscreenPopGesture.git" target="_blank" rel="external">FDFullscreenPopGesture</a> 通过 category 的方法让所有的 UINavigationController 都支持右滑返回，而且，一行代码都不用写，这是配套的博客：<a href="http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/" target="_blank" rel="external">一个丝滑的全屏滑动返回手势</a>。那么也可以实现一个类似的 FullScreenTabScrollGesture 让所有的 UITabBarController 都支持滑动切换，不过，UITabBar 上的 icon 渐变动画有点麻烦，因为其中的 UITabBarItem 并非 UIView 子类，无法进行动画。<a href="https://github.com/leichunfeng/WXTabBarController.git" target="_blank" rel="external">WXTabBarController</a> 这个项目完整地实现了微信界面的滑动交互以及 TabBar 的渐变动画。不过，它的滑动交互并不是使用转场的方式完成的，而是使用 UIScrollView，好处是兼容性更好。兼容性这方面国内的环境比较差，iOS 9 都出来了，可能还需要兼容 iOS 6，而自定义转场需要至少 iOS 7 的系统。该项目实现的 TabBar 渐变动画是基于 TabBar 的内部结构实时更新相关视图的 alpha 值来实现的(不是UIView 动画），这点非常难得，而且使用 UIScrollView 还可以实现自动控制 TabBar 渐变动画，相比之下，使用转场的方式来实现这个效果会麻烦一点。</p>
<p>一个较好的转场方式需要顾及更多方面的细节，NavigationController 的 NavigationBar 和 TabBarController 的 TabBar 这两者在先天上有着诸多不足需要花费更多的精力去完善，本文就不在这方面深入了，上面提及的几个开源项目都做得比较好，推荐学习。</p>
<h3 id="Chapter3.4">交互转场的限制</h3>

<p>如果希望转场中的动画能完美地被交互控制，必须满足2个隐性条件：</p>
<ol>
<li>使用 UIView 动画的 API。你当然也可以使用 Core Animation 来实现动画，甚至，这种动画可以被交互控制，但是当交互中止时，会出现一些意外情况：如果你正确地用 Core Animation 的方式复现了 UIView 动画的效果(不仅仅是动画，还包括动画结束后的处理)，那么手势结束后，动画将直接跳转到最终状态；而更多的一种状况是，你并没有正确地复现 UIView 动画的效果，手势结束后动画会停留在手势中止时的状态，界面失去响应。所以，如果你需要完美的交互转场动画，必须使用 UIView 动画。</li>
<li>在动画控制器的<code>animateTransition:</code>中提交动画。问题和第1点类似，在<code>viewWillDisappear:</code>这样的方法中提交的动画也能被交互控制，但交互停止时，立即跳转到最终状态。</li>
</ol>
<p>如果你希望制作多阶段动画，在某个动画结束后再执行另外一段动画，可以通过 UIView Block Animation 的 completion 闭包来实现动画链，或者是通过设定动画执行的延迟时间使得不同动画错分开来，但是交互转场不支持这两种形式。UIView 的 keyFrame Animation API 可以帮助你，通过在动画过程的不同时间节点添加关键帧动画就可以实现多阶段动画。我实现过一个这样的多阶段转场动画，Demo 在此：<a href="https://github.com/seedante/SDECollectionViewAlbumTransition.git" target="_blank" rel="external">CollectionViewAlbumTransition</a>。</p>
<h2 id="Chapter4">插曲：UICollectionViewController 布局转场</h2>

<p>前面一直没有提到这种转场方式，与三大主流转场不同，布局转场只针对 CollectionViewController 搭配 NavigationController 的组合，且是作用于布局，而非视图。采用这种布局转场时，NavigationController 将会用布局变化的动画来替代 push 和 pop 的默认动画。苹果自家的照片应用中的「照片」Tab 页面使用了这个技术：在「年度-精选-时刻」几个时间模式间切换时，CollectionViewController 在 push 或 pop 时尽力维持在同一个元素的位置同时进行布局转换。</p>
<p>布局转场的实现比三大主流转场要简单得多，只需要满足四个条件：NavigationController + CollectionViewController, 且要求后者都拥有相同数据源， 并且开启<code>useLayoutToLayoutNavigationTransitions</code>属性为真。</p>
<pre><code>let cvc0 = UICollectionViewController(collectionViewLayout: layout0)
//作为 root VC 的 cvc0 的该属性必须为 false，该属性默认为 false。
cvc0.useLayoutToLayoutNavigationTransitions = false
let nav = UINavigationController(rootViewController: cvc0)
//cvc0, cvc1, cvc2 必须具有相同的数据，如果在某个时刻修改了其中的一个数据源，其他的数据源必须同步，不然会出错。
let cvc1 = UICollectionViewController(collectionViewLayout: layout1)
cvc1.useLayoutToLayoutNavigationTransitions = true
nav.pushViewController(cvc1, animated: true)

let cvc2 = UICollectionViewController(collectionViewLayout: layout2)
cvc2.useLayoutToLayoutNavigationTransitions = true
nav.pushViewController(cvc2, animated: true)

nav.popViewControllerAnimated(true)
nav.popViewControllerAnimated(true)
</code></pre><p>Push 进入控制器栈后，不能更改<code>useLayoutToLayoutNavigationTransitions</code>的值，否则应用会崩溃。当 CollectionView 的数据源(section 和 cell 的数量)不完全一致时，push 和 pop 时依然会有布局转场动画，但是当 pop 回到 rootVC 时，应用会崩溃。可否共享数据源保持同步来克服这个缺点？测试表明，这样做可能会造成画面上的残缺，以及不稳定，建议不要这么做。</p>
<p>此外，iOS 7 支持 UICollectionView 布局的交互转换(Layout Interactive Transition)，过程与控制器的交互转场(ViewController Interactive Transition)类似，这个功能和布局转场(CollectionViewController Layout Transition)容易混淆，前者是在自身布局转换的基础上实现了交互控制，后者是 CollectionViewController 与 NavigationController 结合后在转场的同时进行布局转换。感兴趣的话可以看<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/index.html#//apple_ref/occ/instm/UICollectionView/startInteractiveTransitionToCollectionViewLayout:completion:" target="_blank" rel="external">这个功能的文档</a>。</p>
<p>布局转场不支持交互控制。Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CollectionViewControllerLayoutTransition" target="_blank" rel="external">CollectionViewControllerLayoutTransition</a>。</p>
<h2 id="Chapter5">进阶</h2>

<p>是否觉得本文中实现的例子的动画效果太过简单？的确很简单，与 <a href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller" target="_blank" rel="external">VCTransitionsLibrary</a> 这样的转场动画库提供的十种动画效果相比是很简单的，不过就动画而言，与本文示例的本质是一样的，它们都是针对 fromView 和 toView 的整体进行的动画，但在效果上更加复杂。我在本文中多次强调转场动画的本质是是对即将消失的当前视图和即将出现的下一屏幕的内容进行动画，「在动画控制器里，参与转场的视图只有 fromView 和 toView 之分，与转场方式无关。转场动画的最终效果只限制于你的想象力」，当然，还有你的实现能力。</p>
<p>本文前面的目的是帮助你熟悉转场的整个过程，你也看到了，转场动画里转场部分的实现其实很简单，大部分复杂的转场动画与本文范例里简单的转场动画相比，复杂的部分在动画部分，转场的部分都是一样的。因此，学习了前面的内容后并不能帮助你立马就能够实现 Github 上那些热门的转场动画，它们成为热门的原因在于动画本身，与转场本身关系不大，但它们与转场结合后就有了神奇的力量。那学习了作为进阶的本章能立马实现那些热门的转场效果吗？有可能，有些效果其实很简单，一点就透，还有一些效果涉及的技术属于本文主题之外的内容，我会给出相关的提示就不深入了。</p>
<p>本章的进阶分为两个部分：</p>
<ol>
<li>案例分析：动画的方式非常多，有些并不常见，有些只是简单到令人惊讶的组合，只是你不曾了解过所以不知道如何实现，一旦了解了就不再是难事。尽管这些动画本身并不属于转场技术这个主题，但与转场动画组合后往往有着惊艳的视觉效果，这部分将提供一些实现此类转场动画的思路，技巧和工具来扩展视野。有很多动画类型我也没有尝试过，可能的话我会继续更新一些有意思的案例。</li>
<li>自定义容器转场：官方支持四种方式的转场，而且这些也足以应付绝大多数需求了，但依然有些地方无法顾及。本文一直通过探索转场的边界的方式来总结使用方法以及陷阱，在本文的压轴部分，我们将挣脱系统的束缚来实现自定义容器控制器的转场效果。</li>
</ol>
<h3 id="Chapter5.1">案例分析</h3>

<p>动画的持续时间一般不超过0.5秒，稍纵即逝，有时候看到一个复杂的转场动画也不容易知道实现的方式，我一般是通过逐帧解析的手法来分析实现的手段：开源的就运行一下，使用系统自带的 QuickPlayer 对 iOS 设备进行录屏，再使用 QuickPlayer 打开视频，按下 cmd+T 打开剪辑功能，这时候就能查看每一帧了；Gif 等格式的原型动画的动图就直接使用系统自带的 Preview 打开看中间帧。</p>
<p><strong>子元素动画</strong></p>
<p>当转场动画涉及视图中的子视图时，往往无法依赖第三方的动画库来实现，你必须为这种效果单独定制，神奇移动就是一个典型的例子。神奇移动是 Keynote 中的一个动画效果，如果某个元素在连续的两页 Keynote 同时存在，在页面切换时，该元素从上一页的位置移动到下一页的位置，非常神奇。在转场中怎么实现这个效果呢？最简单的方法是截图配合移动动画：伪造那个元素的视图添加到 containerView 中，从 fromView 中的位置移动到 toView 中的位置，这期间 fromView 和 toView 中的该元素视图隐藏，等到移动结束恢复 toView 中该元素的显示，并将伪造的元素视图从 containerView 中移除。</p>
<p>UIView 有几个<code>convert</code>方法用于在不同的视图之间转换坐标：</p>
<pre><code>func convertPoint(_ point: CGPoint, toView view: UIView?) -&gt; CGPoint
func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint
func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint
func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint
</code></pre><p>对截图这个需求，iOS 7 提供了趁手的工具，UIView Snapshot API：</p>
<pre><code>func snapshotViewAfterScreenUpdates(_ afterUpdates: Bool) -&gt; UIView
//获取视图的部分内容
func resizableSnapshotViewFromRect(_ rect: CGRect, afterScreenUpdates afterUpdates: Bool, withCapInsets capInsets: UIEdgeInsets) -&gt; UIView
</code></pre><p>当<code>afterScreenUpdates</code>参数值为<code>true</code>时，这两个方法能够强制视图立刻更新内容，同时返回更新后的视图内容。在 push 或 presentation 中，如果 toVC 是 CollectionViewController 并且需要对 visibleCells 进行动画，此时动画控制器里是无法获取到的，因为此时 collectionView 还未向数据源询问内容，执行此方法后能够达成目的。UIView 的<code>layoutIfNeeded()</code>也能要求立即刷新布局达到同样的效果。</p>
<p><strong>Mask 动画</strong></p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/MaskAnimtion.gif?raw=true" alt="MaskAnimtion"></p>
<p>左边的动画教程：<a href="http://www.raywenderlich.com/86521/how-to-make-a-view-controller-transition-animation-like-in-the-ping-app" target="_blank" rel="external">How To Make A View Controller Transition Animation Like in the Ping App</a>；右边动画的开源地址：<a href="https://github.com/andreamazz/BubbleTransition.git" target="_blank" rel="external">BubbleTransition</a>。</p>
<p>Mask 动画往往在视觉上令人印象深刻，这种动画通过使用一种特定形状的图形作为 mask 截取当前视图内容，使得当前视图只表现出 mask 图形部分的内容，在 PS 界俗称「遮罩」。UIView 有个属性<code>maskView</code>可以用来遮挡部分内容，但这里的效果并不是对<code>maskView</code>的利用；CALayer 有个对应的属性<code>mask</code>，而 CAShapeLayer 这个子类搭配 UIBezierPath 类可以实现各种不规则图形。这种动画一般就是 mask + CAShapeLayer + UIBezierPath 的组合拳搞定的，实际上实现这种圆形的形变是很简单的，只要发挥你的想象力，可以实现任何形状的形变动画。</p>
<p>这类转场动画在转场过程中对 toView 使用 mask 动画，不过，右边的这个动画实际上并不是上面的组合来完成的，它的真相是这样：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/Truth%20behind%20BubbleTransition.gif?raw=true" alt="Truth behind BubbleTransition"></p>
<p>这个开发者实在是太天才了，这个手法本身就是对 mask 概念的应用，效果卓越，但方法却简单到难以置信。关于使用 mask + CAShapeLayer + UIBezierPath 这种方法实现 mask 动画的方法请看我的<a href="http://www.jianshu.com/p/3c925a1609f8" target="_blank" rel="external">这篇文章</a>。</p>
<p><strong>高性能动画框架</strong></p>
<p>有些动画使用 UIView 的动画 API 难以实现，或者难以达到较好的性能，又或者两者皆有，幸好我们还有其他选择。<a href="https://yalantis.com/blog/uidynamics-uikit-or-opengl-3-types-of-ios-animations-for-the-star-wars/" target="_blank" rel="external">StartWar</a> 使用更底层的 OpenGL 框架来解决性能问题以及 Objc.io 在探讨转场这个话题时<a href="http://objccn.io/issue-5-3/" target="_blank" rel="external">使用 GPUImage 定制动画</a>都是这类的典范。在交互控制器章节中提到过，官方只能对 UIView 动画 API 实现的转场动画实施完美的交互控制，这也不是绝对的，接下来我们就来挑战这个难题。</p>
<h3 id="Chapter5.2">自定义容器控制器转场</h3>

<p>压轴环节我们将实现这样一个效果：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/CustomContainerVCButtonTransition.gif?raw=true" alt="ButtonTransition"><br><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/ContainerVCTransition.mov.gif?raw=true" alt="ContainerVC Interacitve Transition"></p>
<p>Demo 地址：<a href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CustomContainerVCTransition" target="_blank" rel="external">CustomContainerVCTransition</a>。</p>
<p>分析一下思路，这个控制器和 UITabBarController 在行为上比较相似，只是 TabBar 由下面跑到了上面。我们可以使用 UITabBarController 子类，然后打造一个伪 TabBar 放在顶部，原来的 TabBar 则隐藏，行为上完全一致，使用 UITabBarController 子类的好处是可以减轻实现转场的负担，不过，有时候这样的子类不是你想要的，UIViewController 子类能够提供更多的自由度，好吧，一个完全模仿 UITabBarController 行为的 UIViewController 子类，实际上我没有想到非得这样做的原因，但我想肯定有需要定制自己的容器控制器的场景，这正是本节要探讨的。Objc.io 也讨论过<a href="http://objccn.io/issue-12-3/" target="_blank" rel="external">这个话题</a>，文章的末尾把实现交互控制当做作业留了下来。珠玉在前，我就站在大牛的肩上继续这个话题吧。Objc.io 的这篇文章写得较早使用了 Objective-C 语言，如果要读者先去读这篇文章再继续读本节的内容，难免割裂，所以本节还是从头讨论这个话题吧，最终效果如上面所示，在自定义的容器控制器中实现交互控制切换子视图，也可以通过填充了 UIButton 的 ButtonTabBar 来实现 TabBar 一样行为的 Tab 切换，在通过手势切换页面时 ButtonTabBar 会实现渐变色动画。ButtonTabBar 有很大扩展性，改造或是替换为其他视图还是有很多应用场景的。</p>
<h4 id="Chapter5.2.1">实现分析</h4>

<p>既然这个自定义容器控制器和 UITabBarController 行为类似，我便实现了一套类似的 API：<code>viewControllers</code>数组是容器 VC 维护的子 VC 数组，初始化时提供要显示的子 VC，更改<code>selectedIndex</code>的值便可跳转到对应的子视图。利用 Swift 的属性观察器实现修改<code>selectedIndex</code>时自动执行子控制器转场。下面是实现子 VC 转场的核心代码，转场结束后遵循系统的惯例将 fromView 移除：</p>
<pre><code>class SDEContainerViewController: UIViewController{
    ...
    //发生转场的容器视图，是 root view 的子视图。
    private let privateContainerView = UIView()
    var selectedIndex: Int = NSNotFound{
        willSet{
            transitionViewControllerFromIndex(selectedIndex, toIndex: newValue)
        }
    }
    //实现 selectedVC 转场：
    private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int){
        //添加 toVC 和 toView
        let newSelectedVC = viewControllers![toIndex]
        self.addChildViewController(newSelectedVC)
        self.privateContainerView.addSubview(newSelectedVC.view)
        newSelectedVC.didMoveToParentViewController(self)

        UIView.animateWithDuration(transitionDuration, animations: {
            /*转场动画*/
            }, completion: { finished in
                //移除 fromVC 和 fromView。
                let priorSelectedVC = viewControllers![fromIndex]
                priorSelectedVC.willMoveToParentViewController(nil)
                priorSelectedVC.view.removeFromSuperview()
                priorSelectedVC.removeFromParentViewController()
        })
    }
}
</code></pre><p>实现转场就是这么十几行代码而已，其他容器 VC 转场过程做了类似的事情。回忆下我们在动画控制器里做的事情，实际上只是上面代码中的一部分。转场协议这套 API 将这个过程分割为五个组件，这套复杂的结构带来了可高度自定义的动画效果和交互控制。我们温习下转场协议，来看看如何在既有的转场协议框架下实现自定义容器控制器的转场动画以及交互控制：</p>
<ol>
<li>转场代理：既有的转场代理协议并没有直接支持我们这种转场方式，没关系，我们自定义一套代理协议来提供动画控制器和交互控制器；</li>
<li>动画控制器：动画控制器是可复用的，这里采用动画控制器章节封装的 Slide 动画控制器，可以拿来直接使用而不用修改；</li>
<li>交互控制器：官方封装了一个现成的交互控制器类，但这个类是与 UIKit 提供的转场环境对象配合使用的，而这里的转场显然需要我们来提供转场环境对象，因此<code>UIPercentDrivenInteractiveTransition</code>无法在这里使用，需要我们来实现这个协议；</li>
<li>转场环境：在官方支持的转场方式中，转场环境是由 UIKit 主动提供给我们的，既然现在的转场方式不是官方支持的，显然需要我们自己提供这个对象以供动画控制器和交互控制器使用；</li>
<li>转场协调器：在前面的章节中我提到过，转场协调器(Transition Coordinator)的使用场景有限而关键，也是由系统提供，我们也可以重写相关方法来提供。这个部分我留给读者当作是本文的一道作业吧。</li>
</ol>
<p>下面我们来将上面的十几行代码(不包括实际的动画代码)使用协议封装成本文前半部分里熟悉的样子。</p>
<h4 id="Chapter5.2.2">协议补完</h4>

<p>模仿 UITabBarControllerDelegate 协议的 ContainerViewControllerDelegate 协议：</p>
<pre><code>//在 Swift 协议中声明可选方法必须在协议声明前添加 @objc 修饰符。
@objc protocol ContainerViewControllerDelegate{
    func containerController(containerController: SDEContainerViewController, animationControllerForTransitionFromViewController 
                                          fromVC: UIViewController, 
                           toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?
    optional func containerController(containerController: SDEContainerViewController, interactionControllerForAnimation 
                                      animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning?
}
</code></pre><p>在容器控制器<code>SDEContainerViewController</code>类中，添加转场代理属性：</p>
<pre><code>weak var containerTransitionDelegate: ContainerViewControllerDelegate?
</code></pre><p>代理的定位就是提供动画控制器和交互控制器，系统打包的<code>UIPercentDrivenInteractiveTransition</code>类只是调用了转场环境对象的对应方法而已，执行<code>navigationController.pushViewController(toVC, animated: true)</code>这类语句触发转场后 UIKit 就接管了剩下的事情，再综合文档的描述，可知转场环境便是实现这一切的核心。</p>
<p>在文章前面的部分里转场环境对象的作用只是提供涉及转场过程的信息和状态，现在需要我们实现该协议，并且实现隐藏的那部分职责。<br><code>&lt;UIViewControllerContextTransitioning&gt;</code>协议里的绝大部分方法都是必须实现的，不过现在我们先实现非交互转场的部分，实现这个是很简单的，主要是调用动画控制器执行转场动画。在「实现分析」一节里我们看到实现转场的代码只有十几行而已，动画控制器需要做的只是处理视图和动画的部分，转场环境对象则要负责管理子 VC，通过<code>SDEContainerViewController</code>提供 containerView 以及 fromVC 和 toVC，实现并不是难事。显然由我们实现的自定义容器 VC 来提供转场环境对象是最合适的，并且转场环境对象应该是私有的，其初始化方法极其启动转场的方法如下：</p>
<pre><code>class ContainerTransitionContext: NSObject, UIViewControllerContextTransitioning{
    init(containerViewController: SDEContainerViewController, 
                   containerView: UIView, 
       fromViewController fromVC: UIViewController, 
           toViewController toVC: UIViewController){...}

    //非协议方法，是启动非交互式转场的便捷方法。
    func startNonInteractiveTransitionWith(delegate: ContainerViewControllerDelegate){
        //转场开始前添加 toVC，转场动画结束后会调用 completeTransition: 方法，在该方法里完成后续的操作。
        self.privateContainerViewController.addChildViewController(privateToViewController)
        //通过 ContainerViewControllerDelegate 协议定义的方法生成动画控制器，方法名太长了略去。
        self.privateAnimationController = delegate.XXXmethod
        //启动转场并执行动画。
        self.privateAnimationController.animateTransition(self)
    }
    //协议方法，动画控制器在动画结束后调用该方法，完成管理子 VC 的后续操作，并且考虑交互式转场可能取消的情况撤销添加的子 VC。
    func completeTransition(didComplete: Bool) {
        if didComplete{
            //转场完成，完成添加 toVC 的工作，并且移除 fromVC 和 fromView。
            self.privateToViewController.didMoveToParentViewController(privateContainerViewController)
            self.privateFromViewController.willMoveToParentViewController(nil)
            self.privateFromViewController.view.removeFromSuperview()
            self.privateFromViewController.removeFromParentViewController()
        }else{
            //转场取消，移除 toVC 和 toView。
            self.privateToViewController.didMoveToParentViewController(privateContainerViewController)
            self.privateToViewController.willMoveToParentViewController(nil)
            self.privateToViewController.view.removeFromSuperview()
            self.privateToViewController.removeFromParentViewController()
        }
        //非协议方法，处理收尾工作：如果动画控制器实现了 animationEnded: 方法则执行；如果转场取消了则恢复数据。
        self.transitionEnd()
    }
}
</code></pre><p>在<code>SDEContainerViewController</code>类中，添加转场环境属性：</p>
<pre><code>private var containerTransitionContext: ContainerTransitionContext?
</code></pre><p>并修改<code>transitionViewControllerFromIndex:toIndex</code>方法实现自定义容器 VC 转场动画：</p>
<pre><code>private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int){
    if self.containerTransitionDelegate != nil{
        let fromVC = viewControllers![fromIndex]
        let toVC = viewControllers![toIndex]
        self.containerTransitionContext = ...//利用 fromVC 和 toVC 初始化。
        self.containerTransitionContext?.startNonInteractiveTransitionWith(containerTransitionDelegate!)
    }else{/*没有提供转场代理的话，则使用最初没有动画的转场代码，或者提供默认的转场动画*/}
}
</code></pre><p>这样我们就利用协议实现了自定义容器控制器的转场动画，可以使用第三方的动画控制器来实现不同的效果。</p>
<p>不过要注意这几个对象之间错综复杂的引用关系避免引用循环，关系图如下：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/Reference%20in%20Transition.png?raw=true" alt="Reference in Transition"></p>
<h4 id="Chapter5.2.3">交互控制</h4>

<p>交互控制器的协议<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>仅仅要求实现一个必须的方法:</p>
<pre><code>func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning)
</code></pre><p>根据文档的描述，该方法用于配置以及启动交互转场。我们前面使用的<code>UIPercentDrivenInteractiveTransition</code>类提供的更新进度的方法只是调用了转场环境对象的相关方法。所以，是转场环境对象替交互控制器把脏活累活干了，我们的实现还是维持这种关系好了。正如前面说的，「交互手段只是表现形式，本质是驱动转场进程」，让我们回到转场环境对象里实现对动画进度的控制吧。</p>
<p>怎么控制动画的进度？这个问题的本质是怎么实现对 UIView 的 <code>animateWithDuration:animations:completion:</code>这类方法生成的动画的控制。能够控制吗？能。</p>
<h5 id="Chapter5.2.3.1">动画控制和 CAMediaTiming 协议</h5>

<p>这个协议定义了一套时间系统，是控制动画进度的关键。UIView Animation 是使用 Core Animation 框架实现的，也就是使用 UIView 的 CALayer 对象实现的动画，而 CALayer 对象遵守该协议。</p>
<p>在交互控制器的小节里我打了一个比方，交互控制器就像一个视频播放器一样控制着转场动画这个视频的进度。依靠 CAMediaTiming 这套协议，我们可以在 CALayer 对象上对添加的动画实现控制。官方的实现很有可能也是采用了同样的手法。CAMediaTiming 协议中有以下几个属性：</p>
<pre><code>//speed 作用类似于播放器上控制加速/减速播放，默认为1，以正常速度播放动画，为0时，动画将暂停。
var speed: Float 
//修改 timeOffset 类似于拖动进度条，对一个2秒的动画，该属性为1的话，动画将跳到中间的部分。
//但当动画从中间播放到预定的末尾时，会续上0秒到1秒的动画部分。
var timeOffset: CFTimeInterval
//动画相对于父 layer 延迟开始的时间，这是一个实际作用比字面意义复杂的属性。 
var beginTime: CFTimeInterval  
</code></pre><p>Core Animation 的文档中提供了如何暂停和恢复动画的示例：<a href="https://developer.apple.com/library/ios/qa/qa1673/_index.html" target="_blank" rel="external">How to pause the animation of a layer tree</a>。我们将之利用实现对进度的控制，这种方法对其中的子视图上添加的动画也能够实现控制，这正是我们需要的。假设在 containerView 中的 toView 上执行一个简单的沿着 X 轴方向移动 100 单位的位移动画，由<code>executeAnimation()</code>方法执行。下面是使用手势控制该动画进度的核心代码：</p>
<pre><code>func handlePan(gesture: UIPanGestureRecognizer){
    switch gesture.state{
    case .Began:
        //开始动画前将 speed 设为0，然后执行动画，动画将停留在开始的时候。
        containerView.layer.speed = 0
        //在transitionContext里，这里替换为 animator.animateTransition(transitionContext)。
        executeAnimation() 
    case .Changed:
        let percent = ...
        //此时 speed 依然为0，调整 timeOffset 可以直接调整动画的整体进度，这里的进度控制以时间计算，而不是比例。
        containerView.layer.timeOffset = percent * duration
    case .Ended, .Cancelled:
        if progress &gt; 0.5{
            //恢复动画的运行不能简单地仅仅将 speed 恢复为1，这是一套比较复杂的机制。
            let pausedTime = view.layer.timeOffset
            containerView.layer.speed = 1.0 
            containerView.layer.timeOffset = 0.0
            containerView.layer.beginTime = 0.0
            let timeSincePause = view.layer.convertTime(CACurrentMediaTime(), fromLayer: nil) - pausedTime
            containerView.layer.beginTime = timeSincePause
        }else{/*逆转动画*/}
        default:break
    }
}
</code></pre><h5 id="Chapter5.2.3.2">取消转场</h5>

<p>交互控制动画时有可能被取消，这往往带来两个问题：恢复数据和逆转动画。</p>
<p>这里需要恢复的数据是<code>selectedIndex</code>，我们在交互转场开始前备份当前的<code>selectedIndex</code>，如果转场取消了就使用这个备份数据恢复。逆转动画反而看起来比较难以解决。</p>
<p>在上面的 pan 手势处理方法中，我们如何逆转动画的运行呢？既然<code>speed</code>为0时动画静止不动，调整为负数是否可以实现逆播放呢？不能，效果是视图消失不见。不过我们还可以调整<code>timeOffset</code>属性，从当前值一直恢复到0。问题是如何产生动画的效果？动画的本质是视图属性在某段时间内的连续变化，当然这个连续变化并不是绝对的连续，只要时间间隔够短，变化的效果就会流畅得看上去是连续变化，在这里让这个变化频率和屏幕的刷新同步即可，<code>CADisplayLink</code>可以帮助我们实现这点，它可以在屏幕刷新时的每一帧执行绑定的方法：</p>
<pre><code>//在上面的/*逆转动画*/处添加以下两行代码：
let displayLink = CADisplayLink(target: self, selector: &quot;reverseAnimation:&quot;)
displayLink.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode)

func reverseAnimation(displayLink: CADisplayLink){
    //displayLink.duration表示每一帧的持续时间，屏幕的刷新频率为60，duration = 1/60。
    //这行代码计算的是，屏幕刷新一帧后，timeOffset 应该回退一帧的时间。
    let timeOffset = view.layer.timeOffset - displayLink.duration
    if timeOffset &gt; 0{
        containerView.layer.timeOffset = timeOffset
    }else{
        //让 displayLink 失效，停止对当前方法的调用。
        displayLink.invalidate()
        //回到最初的状态。
        containerView.layer.timeOffset = 0
        //speed 恢复为1后，视图立刻跳转到动画的最终状态。
        containerView.layer.speed = 1
    }
}
</code></pre><p>最后一句代码会令人疑惑，为何让视图恢复为最终状态，与我们的初衷相悖。<code>speed</code>必须恢复为1，不然后续发起的转场动画无法顺利执行，视图也无法响应触摸事件，直接原因未知。但<code>speed</code>恢复为1后会出现一个问题：由于在原来的动画里 fromView 最终会被移出屏幕，尽管 Slide 动画控制器 UIView 动画里的 completion handle 里会恢复 fromView 和 toView 的状态，这种状态的突变会造成闪屏现象。怎么解决？添加一个假的 fromView 到 containerView替代已经被移出屏幕外的真正的 fromView，然后在很短的时间间隔后将之移除，因为此时 fromView 已经归位。在恢复<code>speed</code>后添加以下代码：</p>
<pre><code>let fakeFromView = privateFromViewController.view.snapshotViewAfterScreenUpdates(false)
containerView.addSubview(fakeFromView)
performSelector(&quot;removeFakeFromView:&quot;, withObject: fakeFromView, afterDelay: 1/60)
//在 Swift 中动态调用私有方法会出现无法识别的选择器错误，解决办法是将私有方法设置为与 objc 兼容，需要添加 @objc 修饰符。
@objc private func removeFakeFromView(fakeView: UIView){
    fakeView.removeFromSuperview()
}
</code></pre><p>经过试验，上面用来控制和取消 UIView 动画的方法也适用于用 Core Animation 实现的动画，毕竟 UIView 动画是用 Core Animation 实现的。不过，我们在前面提到过，官方对 Core Animation 实现的交互转场动画的支持有缺陷，估计官方鼓励使用更高级的接口吧，因为转场动画结束后需要调用<code>transitionContext.completeTransition(!isCancelled)</code>，而使用 Core Animation 完成这一步需要进行恰当的配置，实现的途径有两种且实现并不简单，相比之下 UIView 动画使用 completion block 对此进行了封装，使用非常方便。转场协议的结构已经比较复杂了，选择 UIView 动画能够显著降低实现成本。</p>
<p>上面的实现忽略了一个细节：时间曲线。逆转动画时每一帧都回退相同的时间，也就是说，逆转动画的时间曲线是线性的。交互控制器的协议<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>还有两个可选方法：</p>
<pre><code>optional func completionCurve() -&gt; UIViewAnimationCurve
optional func completionSpeed() -&gt; CGFloat
</code></pre><p>这两个方法记录了动画采用的动画曲线和速度，在逆转动画时如果能够根据这两者计算出当前帧应该回退的时间，那么就能实现完美的逆转，显然这是一个数学问题。恩，我们跳过这个细节吧，因为我数学不好，讨论这个问题很吃力。推荐阅读 Objc.io 的<a href="http://objccn.io/issue-12-6/" target="_blank" rel="external">交互式动画</a>一文，该文探讨了如何打造自然真实的交互式动画。</p>
<h5 id="Chapter5.2.3.3">最后的封装</h5>

<p>接下来要做的事情就是将上述代码封装在转场环境协议要求实现的三个方法里：</p>
<pre><code>func updateInteractiveTransition(percentComplete: CGFloat)
func finishInteractiveTransition()
func cancelInteractiveTransition()
</code></pre><p>正如系统打包的<code>UIPercentDrivenInteractiveTransition</code>类只是调用了 UIKit 提供的转场环境对象里的同名方法，我实现的<code>SDEPercentDrivenInteractiveTransition</code>类也采用了同样的方式调用我们实现的<code>ContainerTransitionContext</code>类的同名方法。</p>
<p>引入交互控制器后的转场引用关系图：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/Reference%20in%20Transition%20with%20Interactor.png?raw=true" alt="Reference in Transition with Interactor"></p>
<p>回到<code>SDEContainerViewController</code>类里修改转场过程的入口处：</p>
<pre><code>private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int){
    ...
    if containerTransitionDelegate != nil{
        let fromVC = viewControllers![fromIndex]
        let toVC = viewControllers![toIndex]
        self.containerTransitionContext = ...//利用 fromVC 和 toVC 初始化。
        //interactive 属性标记是否进入交互状态，由手势来更新该属性的状态。
        if interactive{
            priorSelectedIndex = fromIndex //备份数据，以备取消转场时使用。
            self.containerTransitionContext?.startInteractiveTranstionWith(containerTransitionDelegate!)
        }else{
            self.containerTransitionContext?.startNonInteractiveTransitionWith(containerTransitionDelegate!)
        }
    }else{/*没有提供转场代理的话，则使用最初没有动画的转场代码，或者提供默认的转场动画*/}
} 
</code></pre><p>实现手势控制的部分就如前面的交互控制器章节里的那样，完整的代码请看 Demo。</p>
<p>顺便说下 ButtonTabButton 在交互切换页面时的渐变色动画，这里我只是随着转场的进度更改了 Button 的字体颜色而已。那么当交互结束时如何继续剩下的动画或者取消渐变色动画呢，就像交互转场动画的那样。答案是<code>CADidplayLink</code>，前面我使用它在交互取消时逆转动画，这里使用了同样的手法。</p>
<p>关于转场协调器，文档表明在转场发生时<code>transitionCoordinator()</code>返回一个有效对象，但系统并不支持当前的转场方式，测试表明在当前的转场过程中这个方法返回的是 nil，需要重写该方法来提供。该对象只需要实现前面提到三个方法，其中在交互中止时执行绑定的闭包的方法可以通过通知机制来实现，有点困难的是两个与动画控制器同步执行动画的方法，其需要精准地与动画控制器中的动画保持同步，这两个方法都要接受一个遵守<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerTransitionCoordinatorContext_Protocol/index.html#//apple_ref/doc/uid/TP40013294" target="_blank" rel="external"><code>&lt;UIViewControllerTransitionCoordinatorContext&gt;</code></a>协议的参数，该协议与转场环境协议非常相似，这个对象可以由我们实现的转场环境对象来提供。不过既然现在由我们实现了转场环境对象，也就知道了执行动画的时机，提交并行的动画似乎并不是难事。这部分就留给读者来挑战了。</p>
<h2 id="Chapter6">尾声：转场动画的设计</h2>

<p>虽然我不是设计师，但还是想在结束之前聊一聊我对转场动画设计的看法。动画的使用无疑能够提升应用的体验，但仅限于使用了合适的动画。</p>
<p>除了一些加载动画可以炫酷华丽极尽炫技之能事，绝大部分的日常操作并不适合使用过于炫酷或复杂的动画，比如 <a href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller" target="_blank" rel="external">VCTransitionsLibrary</a> 这个库里的大部分效果。该库提供了多达10种转场效果，从技术上讲，大部分效果都是针对 transform 进行动画，如果你对这些感兴趣或是恰好有这方面的使用需求，可以学习这些效果的实现，从代码角度看，封装技巧也很值得学习，这个库是学习转场动画的极佳范例；不过从使用效果上看，这个库提供的效果像 PPT 里提供的动画效果一样，绝大部分都应该避免在日常操作中使用。不过作为开发者，我们应该知道技术实现的手段，即使这些效果并不适合在绝大部分场景中使用。</p>
<p>场景转换的目的是过渡到下一个场景，在操作频繁的日常场景中使用复杂的过场动画容易造成视觉疲劳，这种情景下使用简单的动画即可，实现起来非常简单，更多的工作往往是怎么把它们与其他特性更好地结合起来，正如 <a href="https://github.com/forkingdog/FDFullscreenPopGesture.git" target="_blank" rel="external">FDFullscreenPopGesture</a> 做的那样。除了日常操作，也会遇到一些特殊的场景需要定制复杂的转场动画，这种复杂除了动画效果本身的复杂，这需要掌握相应的动画手段，也可能涉及转场过程的配合，这需要对转场机制比较熟悉。比如 <a href="https://github.com/Yalantis/StarWars.iOS" target="_blank" rel="external">StarWars</a>，这个转场动画在视觉上极其惊艳，一出场便获得上千星星的青睐，它有贴合星战内涵的创意设计和惊艳的视觉表现，以及优秀的性能优化，如果要评选年度转场动画甚至是史上最佳，我会投票给它；而我在本文里实现的范例，从动画效果来讲，都是很简单的，可以预见本文无法吸引大众的转发，压轴环节里的自定义容器控制器转场也是如此，但是后者需要熟知转场机制才能实现。从这点来看，转场动画在实际使用中走向两个极端：日常场景中的转场动画十分简单，实现难度很低；特定场景的转场动画可能非常复杂，不过实现难度并不能一概而论，正如我在案例分析一节里指出的几个案例那样。</p>
<p>希望本文能帮助你。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：<a href="http://weibo.com/u/1815689155" target="_blank" rel="external">seedante</a>，神秘人士，他的 <a href="https://github.com/s]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="投稿" scheme="http://blog.devtang.com/tags/%E6%8A%95%E7%A8%BF/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（四） - map 和 flatMap]]></title>
    <link href="http://blog.devtang.com/2016/03/05/swift-gym-4-map-and-flatmap/"/>
    <id>http://blog.devtang.com/2016/03/05/swift-gym-4-map-and-flatmap/</id>
    <published>2016-03-05T12:15:34.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/swift-brain-gym-map-and-flatmap" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第四节，练习前请做好准备运动，保持头脑清醒。</p>
<p>我之前一直以为我是懂 <code>map</code> 和 <code>flatMap</code> 的。但是直到我看到别人说：「一个实现了 <code>flatMap</code> 方法的类型其实就是 monad。」我又发现这个熟悉的东西变得陌生起来，本节烧脑体操打算更细致一些介绍 <code>map</code> 和 <code>flatMap</code>，为了下一节介绍 monad 做铺垫。</p>
<h2 id="u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6"><a href="#u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="准备运动：基础知识"></a>准备运动：基础知识</h2><p><img src="http://ww4.sinaimg.cn/mw690/65dc76a3gw1f0sz177142j20dk07bjsd.jpg" alt=""></p>
<h3 id="u6570_u7EC4_u4E2D_u7684_map__u548C_flatMap"><a href="#u6570_u7EC4_u4E2D_u7684_map__u548C_flatMap" class="headerlink" title="数组中的 map 和 flatMap"></a>数组中的 <code>map</code> 和 <code>flatMap</code></h3><p>数组中的 <code>map</code> 对数组元素进行某种规则的转换，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.map &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// brr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]</span><br></pre></td></tr></table></figure>
<p>而 <code>flatMap</code> 和 <code>map</code> 的差别在哪里呢？我们可以对比一下它们的定义。为了方便阅读，我在删掉了定义中的 <code>@noescape</code> 、<code>throws</code> 和 <code>rethrows</code> 关键字，如果你对这些关键字有疑问，可以查阅上一期的烧脑文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension SequenceType &#123;&#10;    public func map&#60;T&#62;(transform: (Self.Generator.Element) -&#62; T) &#10;         -&#62; [T]&#10;&#125;&#10;&#10;extension SequenceType &#123;&#10;    public func flatMap&#60;S : SequenceType&#62;(transform: (Self.Generator.Element) -&#62; S) &#10;         -&#62; [S.Generator.Element]&#10;&#125;&#10;&#10;extension SequenceType &#123;&#10;    public func flatMap&#60;T&#62;(transform: (Self.Generator.Element) -&#62; T?) &#10;         -&#62; [T]&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们从中可以发现，<code>map</code> 的定义只有一个，而 <code>flatMap</code> 的定义有两个重载的函数，这两个重载的函数都是接受一个闭包作为参数，返回一个数组。但是差别在于，闭包的定义不一样。</p>
<p>第一个函数闭包的定义是：<code>(Self.Generator.Element) -&gt; S</code>，并且这里 S 被定义成：<code>S : SequenceType</code>。所以它是接受数组元素，然后输出一个 <code>SequenceType</code> 类型的元素的闭包。有趣的是， <code>flatMap</code> 最终执行的结果并不是 <code>SequenceType</code> 的数组，而是 <code>SequenceType</code> 内部元素另外组成的数组，即：<code>[S.Generator.Element]</code>。</p>
<p>是不是有点晕？看看示例代码就比较清楚了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [[1, 2, 3], [6, 5, 4]]&#10;let brr = arr.flatMap &#123;&#10;    $0&#10;&#125;&#10;// brr = [1, 2, 3, 6, 5, 4]</span><br></pre></td></tr></table></figure>
<p>你看出来了吗？在这个例子中，数组 arr 调用 <code>flatMap</code> 时，元素<code>[1, 2, 3]</code> 和 <code>[6, 5, 4]</code> 分别被传入闭包中，又直接被作为结果返回。但是，最终的结果中，却是由这两个数组中的元素共同组成的新数组：<code>[1, 2, 3, 6, 5, 4]</code> 。</p>
<p>需要注意的是，其实整个 <code>flatMap</code> 方法可以拆解成两步：</p>
<ul>
<li>第一步像 <code>map</code> 方法那样，对元素进行某种规则的转换。</li>
<li>第二步，执行 <code>flatten</code> 方法，将数组中的元素一一取出来，组成一个新数组。</li>
</ul>
<p>所以，刚刚的代码其实等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [[1, 2, 3], [6, 5, 4]]&#10;let crr = Array(arr.map&#123; $0 &#125;.flatten())&#10;// crr = [1, 2, 3, 6, 5, 4]</span><br></pre></td></tr></table></figure>
<p>讲完了 <code>flatMap</code> 的第一种重载的函数，我们再来看第二种重载。</p>
<p>在第二种重载中，闭包的定义变成了：<code>(Self.Generator.Element) -&gt; T?</code>，返回值 T 不再像第一种重载中那样要求是数组了，而变成了一个 Optional 的任意类型。而 <code>flatMap</code> 最终输出的数组结果，其实不是这个 <code>T?</code> 类型，而是这个 <code>T?</code> 类型解包之后，不为 <code>.None</code> 的元数数组：<code>[T]</code>。</p>
<p>我们还是直接看代码吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr: [Int?] = [1, 2, nil, 4, nil, 5]&#10;let brr = arr.flatMap &#123; $0 &#125;&#10;// brr = [1, 2, 4, 5]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>flatMap</code> 将数组中的 nil 都丢弃掉了，只保留了非空的值。</p>
<p>在实际业务中，这样的例子还挺常见，比如你想构造一组图片，于是你使用 UIImage 的构造函数，但是这个函数可能会失败（比如图像的名字不存在时），所以返回的是一个 Optional 的 UIImage 对象。使用 <code>flatMap</code> 方法可以方便地将这些对象中为 .None 的都去除掉。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let images = (1...6).flatMap &#123;&#10;    UIImage(named: &#34;imageName-\($0)&#34;) &#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Optional__u4E2D_u7684_map__u548C_flatMap"><a href="#Optional__u4E2D_u7684_map__u548C_flatMap" class="headerlink" title="Optional 中的 map 和 flatMap"></a>Optional 中的 <code>map</code> 和 <code>flatMap</code></h3><p>其实 <code>map</code> 和 <code>flatMap</code> 不止存在于数组中，在 Optional 中也存在。我们先看看定义吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Optional&#60;Wrapped&#62; : _Reflectable, NilLiteralConvertible &#123;&#10;    case None&#10;    case Some(Wrapped)&#10;&#10;    public func map&#60;U&#62;( f: (Wrapped) throws -&#62; U) &#10;        rethrows -&#62; U?&#10;&#10;    public func flatMap&#60;U&#62;( f: (Wrapped) throws -&#62; U?) &#10;        rethrows -&#62; U?&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>所以，对于一个 Optional 的变量来说，<code>map</code> 方法允许它再次修改自己的值，并且不必关心自己是否为 <code>.None</code>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a1: Int? = 3&#10;let b1 = a1.map&#123; $0 * 2 &#125;&#10;// b1 = 6&#10;&#10;let a2: Int? = nil&#10;let b2 = a2.map&#123; $0 * 2 &#125;&#10;// b2 = nil</span><br></pre></td></tr></table></figure>
<p>再举一个例子，比如我们想把一个字符串转成 NSDate 实例，如果不用 <code>map</code> 方法，我们只能这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let date: NSDate? = NSDate()&#10;let formatter = NSDateFormatter()&#10;formatter.dateFormat = &#34;YYYY-MM-dd&#34;&#10;var formatted: String? = nil&#10;if let date = date &#123;&#10;    formatted = formatter.stringFromDate(date)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>而使用 <code>map</code> 函数后，代码变得更短，更易读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let date: NSDate? = NSDate()&#10;let formatter = NSDateFormatter()&#10;formatter.dateFormat = &#34;YYYY-MM-dd&#34;&#10;let formatted = date.map(formatter.stringFromDate)</span><br></pre></td></tr></table></figure>
<p>看出来特点了吗？当我们的输入是一个 Optional，同时我们需要在逻辑中处理这个 Optional 是否为 nil，那么就适合用 <code>map</code> 来替代原来的写法，使得代码更加简短。</p>
<p>那什么时候使用 Optional 的 <code>flatMap</code> 方法呢？答案是：当我们的闭包参数有可能返回 nil 的时候。</p>
<p>比如，我们希望将一个字符串转换成 Int，但是转换可能失败，这个时候我们就可以用 <code>flatMap</code> 方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s: String? = &#34;abc&#34;&#10;let v = s.flatMap &#123; (a: String) -&#62; Int? in&#10;    return Int(a)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我在这里还发现了更多的使用 <code>map</code> 和 <code>flatMap</code> 的例子，分享给大家：<a href="http://blog.xebia.com/the-power-of-map-and-flatmap-of-swift-optionals/" target="_blank" rel="external">http://blog.xebia.com/the-power-of-map-and-flatmap-of-swift-optionals/</a>。</p>
<h2 id="map__u548C_flatMap__u7684_u6E90_u7801"><a href="#map__u548C_flatMap__u7684_u6E90_u7801" class="headerlink" title="map 和 flatMap 的源码"></a><code>map</code> 和 <code>flatMap</code> 的源码</h2><p><img src="https://quotesaga.s3.amazonaws.com/quote/QS_be152af2851e4e4e8d5049b0d5cbaed9.jpg" alt=""></p>
<blockquote>
<p>Talk is cheap. Show me the code.</p>
<p>– Linus Torvalds</p>
</blockquote>
<p>为了更好地理解，我们去翻翻苹果开源的 Swift 代码，看看 <code>map</code> 和 <code>flatMap</code> 的实现吧。</p>
<h3 id="u6570_u7EC4_u7684_map__u7684_u6E90_u7801"><a href="#u6570_u7EC4_u7684_map__u7684_u6E90_u7801" class="headerlink" title="数组的 map 的源码"></a>数组的 <code>map</code> 的源码</h3><p>源码地址是：<a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift</a>，摘录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func map&#60;T&#62;(@noescape transform: (Generator.Element) throws -&#62; T)&#10;        rethrows -&#62; [T] &#123;&#10;    let count: Int = numericCast(self.count)&#10;    if count == 0 &#123;&#10;        return []&#10;    &#125;&#10;    &#10;    var result = ContiguousArray&#60;T&#62;()&#10;    result.reserveCapacity(count)&#10;    &#10;    var i = self.startIndex&#10;    &#10;    for _ in 0..&#60;count &#123;&#10;        result.append(try transform(self[i]))&#10;        i = i.successor()&#10;    &#125;&#10;    &#10;    _expectEnd(i, self)&#10;    return Array(result)&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6570_u7EC4_u7684_flatMap__u7684_u6E90_u7801_uFF08_u91CD_u8F7D_u51FD_u6570_u4E00_uFF09"><a href="#u6570_u7EC4_u7684_flatMap__u7684_u6E90_u7801_uFF08_u91CD_u8F7D_u51FD_u6570_u4E00_uFF09" class="headerlink" title="数组的 flatMap 的源码（重载函数一）"></a>数组的 <code>flatMap</code> 的源码（重载函数一）</h3><p>刚刚也说到，数组的 <code>flatMap</code> 有两个重载的函数。我们先看第一个的函数实现。源码地址是：<a href="https://github.com/apple/swift/blob/master/stdlib/public/core/SequenceAlgorithms.swift.gyb" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/SequenceAlgorithms.swift.gyb</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;public func flatMap&#60;S : SequenceType&#62;(&#10;        transform: ($&#123;GElement&#125;) throws -&#62; S&#10;    ) rethrows -&#62; [S.$&#123;GElement&#125;] &#123;&#10;        var result: [S.$&#123;GElement&#125;] = []&#10;        for element in self &#123;&#10;            result.appendContentsOf(try transform(element))&#10;        &#125;&#10;        return result&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>对于这个代码，我们可以看出，它做了以下几件事情：</p>
<ol>
<li>构造一个名为 <code>result</code> 的新数组，用于存放结果。</li>
<li>遍历自己的元素，对于每个元素，调用闭包的转换函数 <code>transform</code>，进行转换。</li>
<li>将转换的结果，使用 <code>appendContentsOf</code> 方法，将结果放入 <code>result</code> 数组中。</li>
</ol>
<p>而这个 <code>appendContentsOf</code> 方法，即是把数组中的元素取出来，放入新数组。以下是一个简单示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr = [1, 3, 2]&#10;arr.appendContentsOf([4, 5])&#10;// arr = [1, 3, 2, 4, 5]</span><br></pre></td></tr></table></figure>
<p>所以这种 <code>flatMap</code> 必须要求 <code>transform</code> 函数返回的是一个 <code>SequenceType</code> 类型，因为 <code>appendContentsOf</code> 方法需要的是一个 <code>SequenceType</code> 类型的参数。</p>
<h3 id="u6570_u7EC4_u7684_flatMap__u7684_u6E90_u7801_uFF08_u91CD_u8F7D_u51FD_u6570_u4E8C_uFF09"><a href="#u6570_u7EC4_u7684_flatMap__u7684_u6E90_u7801_uFF08_u91CD_u8F7D_u51FD_u6570_u4E8C_uFF09" class="headerlink" title="数组的 flatMap 的源码（重载函数二）"></a>数组的 <code>flatMap</code> 的源码（重载函数二）</h3><p>当我们的闭包参数返回的类型不是 <code>SequenceType</code> 时，就会匹配上第二个重载的 <code>flatMap</code> 函数。以下是函数的源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func flatMap&#60;T&#62;(&#10;    @noescape transform: ($&#123;GElement&#125;) throws -&#62; T?&#10;    ) rethrows -&#62; [T] &#123;&#10;        var result: [T] = []&#10;        for element in self &#123;&#10;            if let newElement = try transform(element) &#123;&#10;                result.append(newElement)&#10;            &#125;&#10;        &#125;&#10;        return result&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们也用同样的方式，把该函数的逻辑理一下：</p>
<ol>
<li>构造一个名为 <code>result</code> 的新数组，用于存放结果。(和另一个重载函数完全一样)</li>
<li>遍历自己的元素，对于每个元素，调用闭包的转换函数 <code>transform</code>，进行转换。(和另一个重载函数完全一样)</li>
<li>将转换的结果，判断结果是否是 nil，如果不是，使用使用 <code>append</code> 方法，将结果放入 <code>result</code> 数组中。（唯一差别的地方）</li>
</ol>
<p>所以，该 <code>flatMap</code> 函数可以过滤闭包执行结果为 nil 的情况，仅收集那些转换后非空的结果。</p>
<p>对于这种重载的 <code>flatMap</code> 函数，它和 <code>map</code> 函数的逻辑非常相似，仅仅多做了一个判断是否为 nil 的逻辑。</p>
<p>所以，面试题来了：「什么情况下数组的 <code>map</code> 可以和 <code>flatMap</code> 等价替换？」</p>
<p>答案是：当 <code>map</code> 的闭包函数返回的结果不是 <code>SequenceType</code> 的时候。因为这样的话，<code>flatMap</code> 就会调到我们当前讨论的这种重载形式。而这种重载形式和 <code>map</code> 的差异就仅仅在于要不要判断结果为 nil。</p>
<p>下面是一个示例代码，可以看出：<code>brr</code> 和 <code>crr</code> 虽然分别使用 <code>map</code> 和 <code>flatMap</code> 生成，但是结果完全一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.map &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// brr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]&#10;&#10;let crr = arr.flatMap &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// crr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]</span><br></pre></td></tr></table></figure>
<h3 id="Optional__u7684_map__u548C_flatMap__u6E90_u7801"><a href="#Optional__u7684_map__u548C_flatMap__u6E90_u7801" class="headerlink" title="Optional 的 map 和 flatMap 源码"></a>Optional 的 <code>map</code> 和 <code>flatMap</code> 源码</h3><p>看完数组的实现，我们再来看看 Optional 中的相关实现。源码地址是：<a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift</a>，摘录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// If `self == nil`, returns `nil`.  &#10;/// Otherwise, returns `f(self!)`.&#10;public func map&#60;U&#62;(@noescape f: (Wrapped) throws -&#62; U) &#10;        rethrows -&#62; U? &#123;&#10;    switch self &#123;&#10;    case .Some(let y):&#10;        return .Some(try f(y))&#10;    case .None:&#10;        return .None&#10;    &#125;&#10;&#125;&#10;&#10;/// Returns `nil` if `self` is `nil`, &#10;/// `f(self!)` otherwise.&#10;@warn_unused_result&#10;public func flatMap&#60;U&#62;(@noescape f: (Wrapped) throws -&#62; U?) &#10;        rethrows -&#62; U? &#123;&#10;    switch self &#123;&#10;    case .Some(let y):&#10;        return try f(y)&#10;    case .None:&#10;        return .None&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Optional 的这两函数真的是惊人的相似，如果你只看两段函数的注释的话，甚至看不出这两个函数的差别。</p>
<p>这两函数实现的差别仅仅只有两处：</p>
<ol>
<li><code>f</code> 函数一个返回 <code>U</code>，另一个返回 <code>U?</code> 。</li>
<li>一个调用的结果直接返回，另一个会把结果放到 .Some 里面返回。</li>
</ol>
<p>两个函数最终都保证了返回结果是 Optional 的。只是将结果转换成 Optional 的位置不一样。</p>
<p>这就像我老婆给我说：「我喜欢这个东西，你送给我吗？不送的话我就直接刷你卡买了！」。。。买东西的结果本质上是一样的，谁付钱本质上也是一样的，差别只是谁动手而已。</p>
<p>既然 Optional 的 <code>map</code> 和 <code>flatMap</code> 本质上是一样的，为什么要搞两种形式呢？这其实是为了调用者更方便而设计的。调用者提供的闭包函数，既可以返回 Optional 的结果，也可以返回非 Optional 的结果。对于后者，使用 <code>map</code> 方法，即可以将结果继续转换成 Optional 的。结果是 Optional 的意味着我们可以继续链式调用，也更方便我们处理错误。</p>
<p>我们来看一段略烧脑的代码，它使用了 Optional 的 <code>flatMap</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 4]&#10;let res = arr.first.flatMap &#123;&#10;    arr.reduce($0, combine: max)&#10;&#125;&#10;`</span><br></pre></td></tr></table></figure>
<p>这段代码的功能是：计算出数组中的元素最大值，按理说，求最大值直接使用 <code>reduce</code> 方法就可以了。不过有一种特殊情况需要考虑：即数组中的元素个数为 0 的情况，在这种情况下，没有最大值。</p>
<p>我们使用 Optional 的 <code>flatMap</code> 方法来处理了这种情况。arr 的 <code>first</code> 方法返回的结果是 Optional 的，当数组为空的时候，<code>first</code> 方法返回 .None，所以，这段代码可以处理数组元素个数为 0 的情况了。</p>
<h2 id="u70E7_u8111_u7684_map__u548C_flatMap"><a href="#u70E7_u8111_u7684_map__u548C_flatMap" class="headerlink" title="烧脑的 map 和 flatMap"></a>烧脑的 <code>map</code> 和 <code>flatMap</code></h2><h3 id="u5173_u4E8E_u53D6_u540D"><a href="#u5173_u4E8E_u53D6_u540D" class="headerlink" title="关于取名"></a>关于取名</h3><p><img src="http://ww1.sinaimg.cn/large/65dc76a3gw1f0sygrb8chj20c606egmg.jpg" alt=""></p>
<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.</p>
<p>– Phil Karlton</p>
</blockquote>
<p>有一位大师说，计算机世界真正称得上难题的就只有两个：第一个是缓存过期问题，第二个就是取名字。作为文章最后的烧脑环节，我们来聊聊取名字这个事吧。</p>
<p>我来提几个看起来「无厘头」的问题：</p>
<ul>
<li>数组的 <code>map</code> 函数和 Optinal 的 <code>map</code> 函数的实现差别巨大？但是为什么都叫 <code>map</code> 这个名字？</li>
<li>数组的 <code>flatMap</code> 函数和 Optinal 的 <code>flatMap</code> 函数的实现差别巨大？但是为什么都叫 <code>flatMap</code> 这个名字？</li>
<li>数组的 <code>flatMap</code> 有两个重载的函数，两个重载的函数差别巨大，但是为什么都叫 <code>flatMap</code> 这个名字？</li>
</ul>
<p>在我看来，这样的取名其实都是有背后的原因的，我试着分享一下我的理解。我们先说结论，然后再解释。这段结论来自：<a href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" target="_blank" rel="external">http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/</a>。</p>
<ul>
<li>数组和 Optional 的 <code>map</code> 函数都叫一样的名字，是因为它们都是 <a href="https://en.wikipedia.org/wiki/Functor" target="_blank" rel="external">Functor</a>。</li>
<li>数组和 Optinal 的 <code>flatMap</code> 函数都叫一样的名字，是因为它们都是 <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="external">Monad</a>)。</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/large/65dc76a3gw1f0scj26hf9j205805k3yk.jpg" alt=""></p>
<p>好吧，我猜你心里开始骂娘了：「为了解释一个问题，引入了两个新问题：谁知道什么是 Functor 和 Monad ！」</p>
<p>不要着急，我们先说严谨的结论有助于更好地总结和归纳，我下面试着解释一下 Functor 和 Monad 。</p>
<h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><p>Functor 在 <a href="https://en.wikipedia.org/wiki/Functor" target="_blank" rel="external">Wikipedia</a> 上的定义非常学术。我想了一个相对比较容易理解的定义：所谓的 Functor，就是可以把一个函数应用于一个「封装过的值」上，得到一个新的「封装过的值」。通常情况下，我们会把这个函数叫做 <code>map</code>。</p>
<p>什么叫做「封装过的值」呢？数组就是对值的一种封装，Optional 也是对值的一种封装。如果你愿意，你也可以自己封装一些值，比如把网络请求的结果和网络异常封装在一起，做成一个 enum（如下所示）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Result&#60;T&#62; &#123;&#10;    case Success(T)&#10;    case Failure(ErrorType)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>一个值能否成为「封装过的值」，取决于这个值的类型所表示的集合，通过 <code>map</code> 函数，能否映射到一个新集合中。这个新集合，也要求能够继续使用 <code>map</code> 函数，再映射到另外一个集合。</p>
<p>我们拿数组和 Optional 类型来检查这个规则，就会发现是符合的：</p>
<ul>
<li>数组可以通过 <code>map</code> 函数，生成一个新的数组，新的数组可以继续使用 <code>map</code> 函数。</li>
<li>Optional 可以通过 <code>map</code> 函数，生成一个新的 Optional 变量，新的 Optional 变量可以继续使用 <code>map</code> 函数。</li>
</ul>
<p>所以，数组 和 Optional 都是 Functor。</p>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p>如果你能理解 <a href="https://en.wikipedia.org/wiki/Functor" target="_blank" rel="external">Functor</a>，那么 <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="external">Monad</a>) 就相对容易一些了。所谓的 Monad，和 Functor 一样，也是把一个函数应用于一个「封装过的值」上，得到一个新的「封装过的值」。不过差别在于:</p>
<ul>
<li>Functor 的函数定义是从「未封装的值」到「未封装的值」的</li>
<li>Monad   的函数定义是从「未封装的值」到「封装后的值」的。</li>
</ul>
<p>下面我举例解释一下：</p>
<p>刚刚我们说，数组 和 Optional 都是 Functor，因为它们支持用 <code>map</code> 函数做「封装过的值」所在集合的变换。那么，你注意到了吗？map 函数的定义中，输入的参数和返回的结果，都不是「封装过的值」，而是「未封装的值」。什么是「未封装的值」？</p>
<ul>
<li>对于数组来说，「未封装的值」是数组里面一个一个的元素，map 函数的闭包接受的是一个一个的元素，返回的也是一个一个的元素。</li>
<li>对于 Optional 来说，「未封装的值」是 Optional 解包出来的值，map 函数的闭包接受的是解包出来的值，返回的也是解包出来的值。</li>
</ul>
<p>下面是数组的示例代码，我故意加上了闭包的参数，我们再观察一下。我们可以发现，<code>map</code> 的闭包接受的是 Int 类型，返回的是 String 类型，都是一个一个的元素类型，而不是数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// map &#30340;&#38381;&#21253;&#25509;&#21463;&#30340;&#26159; Int &#31867;&#22411;&#65292;&#36820;&#22238;&#30340;&#26159; String &#31867;&#22411;&#65292;&#37117;&#26159;&#19968;&#20010;&#19968;&#20010;&#30340;&#20803;&#32032;&#31867;&#22411;&#65292;&#32780;&#19981;&#26159;&#25968;&#32452;&#12290;&#10;let arr = [1, 2, 4]&#10;let brr = arr.map &#123;&#10;    (element: Int) -&#62; String in&#10;    &#34;No.&#34; + String(element)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 Optional 的示例代码，我也故意加上了闭包的参数。我们可以发现，<code>map</code> 的闭包接受的是 Int 类型，返回的是 Int 类型，都是非 Optional 的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// map &#30340;&#38381;&#21253;&#25509;&#21463;&#30340;&#26159; Int &#31867;&#22411;&#65292;&#36820;&#22238;&#30340;&#26159; Int &#31867;&#22411;&#65292;&#37117;&#26159;&#38750; Optional &#30340;&#12290;&#10;let tq: Int? = 1&#10;tq.map &#123; (a: Int) -&#62; Int in&#10;    a * 2&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们刚刚说，对于 Monad 来说，它和 Functor 的差异实在太小，小到就只有闭包的参数类型不一样。数组实现了 <code>flatMap</code> ，它就是一种 Monad，下面我们就看看 <code>flatMap</code> 在数组中的函数定义，我们可以看出，闭包接受的是数组的元素，返回的是一个数组（封装后的值）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#38381;&#21253;&#25509;&#21463;&#30340;&#26159;&#25968;&#32452;&#30340;&#20803;&#32032;&#65292;&#36820;&#22238;&#30340;&#26159;&#19968;&#20010;&#25968;&#32452;&#65288;&#23553;&#35013;&#21518;&#30340;&#20540;&#65289;&#10;let arr = [1, 2, 3]&#10;let brr = arr.flatMap &#123;&#10;    (element:Int) -&#62; [Int] in&#10;    return [element * 2]&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 <code>flatMap</code> 在 Optional 中的定义，我们可以看出，闭包接受的是 Int 类型，返回的是一个 Optional（封装后的值）。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// &#38381;&#21253;&#25509;&#21463;&#30340;&#26159; Int &#31867;&#22411;&#65292;&#36820;&#22238;&#30340;&#26159;&#19968;&#20010; Optional&#65288;&#23553;&#35013;&#21518;&#30340;&#20540;&#65289;&#10;let tq: Int? = 1&#10;tq.flatMap &#123; (a: Int) -&#62; Int? in&#10;    if a % 2 == 0 &#123;&#10;        return a&#10;    &#125; else &#123;&#10;        return nil&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>所以本质上，<code>map</code> 和 <code>flatMap</code> 代表着一类行为，我们把这类行为叫做 Functor 和 Monad。它们的差异仅仅在于闭包函数的参数返回类型不一样。所以，我们才会把数组和 Optional 这两个差别很大的类型，都加上两个实现差别很大的函数，但是都取名叫 <code>map</code> 和 <code>flatMap</code>。</p>
<h3 id="u591A_u91CD_Optional"><a href="#u591A_u91CD_Optional" class="headerlink" title="多重 Optional"></a>多重 Optional</h3><p>我们在第一节烧脑文章中提到过多重 Optional，在使用 <code>map</code> 的时候不仔细，就会触发多重 Optional 的问题。比如下面这个代码，变量 <code>b</code> 因为是一个两层嵌套的 nil，所以 <code>if let</code> 失效了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tq: Int? = 1&#10;let b = tq.map &#123; (a: Int) -&#62; Int? in&#10;    if a % 2 == 0 &#123;&#10;        return a&#10;    &#125; else &#123;&#10;        return nil&#10;    &#125;&#10;&#125;&#10;if let _ = b &#123;&#10;    print(&#34;not nil&#34;)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法是把 <code>map</code> 换成 <code>flatMap</code> 即可。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>讨论完了，我们总结一下：</p>
<ul>
<li>数组和 Optional 都能支持 <code>map</code> 和 <code>flatMap</code> 函数。</li>
<li>数组的 <code>flatMap</code> 有两个重载的实现，一个实现等价于先 <code>map</code> 再 <code>flatten</code>，另一个实现用于去掉结果中的 nil。</li>
<li>通过阅读源码，我们更加深入理解了 <code>map</code> 和 <code>flatMap</code> 函数内部的机制。</li>
<li>我们讨论了 <code>map</code> 和 <code>flatMap</code> 的取名问题，最后得出：一个类型如果支持 <code>map</code>，则表示它是一个 <a href="https://en.wikipedia.org/wiki/Functor" target="_blank" rel="external">Functor</a>；一个类型如果支持 <code>flatMap</code>，则表示它是一个 <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="external">Monad</a>。</li>
<li>我们讨论了 <code>map</code> 中使用不当造成的多重 Optional 问题。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（三） - 高阶函数]]></title>
    <link href="http://blog.devtang.com/2016/02/27/swift-gym-3-higher-order-function/"/>
    <id>http://blog.devtang.com/2016/02/27/swift-gym-3-higher-order-function/</id>
    <published>2016-02-27T01:25:51.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/swift-brain-gym-high-order-function" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第三节，练习前请做好准备运动，保持头脑清醒。</p>
<h2 id="u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6"><a href="#u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="准备运动：基础知识"></a>准备运动：基础知识</h2><p><img src="http://ww1.sinaimg.cn/mw690/65dc76a3gw1f0sz14hv65j20er08t0tz.jpg" alt=""></p>
<p>在上一节里面，我们其实已经涉及到了高阶函数了。在 <a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">Wikipedia</a> 中，是这么定义高阶函数（higher-order function）的，如果一个函数：</p>
<ul>
<li>接受一个或多个函数当作参数</li>
<li>把一个函数当作返回值</li>
</ul>
<p>那么这个函数就被称作高阶函数。下面是一个简单的排序的例子，在这个例子中，传进去的参数就是一个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numbers = [1, 4, 2, 3]&#10;let res = numbers.sort &#123;&#10;    $0 &#60; $1&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trailing_Closure_Syntax"><a href="#Trailing_Closure_Syntax" class="headerlink" title="Trailing Closure Syntax"></a>Trailing Closure Syntax</h3><p>上面的代码看着不像是函数作为参数存在，这是因为 Swift 的 Trailing Closure 特性。Swift 允许当函数的最后一个参数是闭包的时候，以紧跟 <code>{ }</code> 的形式，将最后一个闭包的内容附加在函数后面。</p>
<p>所以，以下两行代码是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#27491;&#24120;&#20889;&#27861;&#65292;&#20989;&#25968;&#26159;&#20316;&#20026; sort &#30340;&#21442;&#25968;&#10;arr.sort(&#123; $0 &#60; $1 &#125;)&#10;&#10;// Trailing Closure &#20889;&#27861;&#65292;&#26356;&#31616;&#27905;&#26126;&#20102;&#10;arr.sort &#123; $0 &#60; $1 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5E38_u89C1_u7528_u6CD5_u793A_u4F8B"><a href="#u5E38_u89C1_u7528_u6CD5_u793A_u4F8B" class="headerlink" title="常见用法示例"></a>常见用法示例</h2><p>高阶函数在 Swift 语言中有大量的使用场景，我们先来看一看常见的用法：</p>
<h3 id="u904D_u5386"><a href="#u904D_u5386" class="headerlink" title="遍历"></a>遍历</h3><p>我们可以用 <code>map</code> 方法来对数组元素进行某种规则的转换，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.map &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// brr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]</span><br></pre></td></tr></table></figure>
<h3 id="u6C42_u548C"><a href="#u6C42_u548C" class="headerlink" title="求和"></a>求和</h3><p>我们可以用 <code>reduce</code> 方法，来对数组元素进行某种规则的求和（不一定是加和）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.reduce(0) &#123;&#10;    (prevSum: Int, element: Int) in&#10;    return prevSum + element&#10;&#125;&#10;// brr = 7&#10;let crr = arr.reduce(&#34;&#34;) &#123;&#10;    if $0 == &#34;&#34; &#123;&#10;        return String($1)&#10;    &#125; else &#123;&#10;        return $0 + &#34; &#34; + String($1)&#10;    &#125;&#10;&#125;&#10;// crr = &#34;1 2 4&#34;</span><br></pre></td></tr></table></figure>
<h3 id="u7B5B_u9009"><a href="#u7B5B_u9009" class="headerlink" title="筛选"></a>筛选</h3><p>我们可以利用 <code>filter</code> 方法，来对数组元素进行某种规则的过滤，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.filter &#123;&#10;    $0 % 2 == 0&#10;&#125;&#10;// brr = [2, 4]</span><br></pre></td></tr></table></figure>
<h3 id="u904D_u5386-1"><a href="#u904D_u5386-1" class="headerlink" title="遍历"></a>遍历</h3><p>即使是以前最简单的遍历，我们也可以用高阶函数的写法，将遍历需要的操作，以函数参数的形式传入 <code>forEach</code> 方法中，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;arr.forEach &#123;&#10;    print($0)&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u70E7_u8111_u4F53_u64CD"><a href="#u70E7_u8111_u4F53_u64CD" class="headerlink" title="烧脑体操"></a>烧脑体操</h2><p>下面我们来看看高阶函数一些比较烧脑的细节。</p>
<h3 id="u7528_u9AD8_u9636_u51FD_u6570_u6765_u9690_u85CF_u79C1_u6709_u53D8_u91CF"><a href="#u7528_u9AD8_u9636_u51FD_u6570_u6765_u9690_u85CF_u79C1_u6709_u53D8_u91CF" class="headerlink" title="用高阶函数来隐藏私有变量"></a>用高阶函数来隐藏私有变量</h3><p>高阶函数使得代码逻辑可以用函数为主体来进行封装，下面我将详细解释一下这句话。</p>
<p>在面向对象的世界里，逻辑存在的基本单元是对象，每个对象代表着一个最小可复用模块。在对象的内部，由高内聚的成员变量和成员函数构成。这些函数相互调用，并且操作对象的内部成员变量，最终对外产生可预期的行为。</p>
<p>但是利用高阶函数，我们可以同样做到与对象类似的，高内聚的成员变量和成员函数，下面我就举一个具体的例子。</p>
<p>下面的代码中，我们用类的方式，实现了一个 <code>Clock</code> 类， <code>Clock</code> 类实现了一个 <code>getCount</code> 方法，每次调用的时候返回的值 <code>+1</code>。为了测试代码，我们定义了两个实例 c1 和 c2，它们都可以正常输出预期的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Clock &#123;&#10;    var count: Int = 0&#10;    func getCount() -&#62; Int &#123;&#10;        return ++count;&#10;    &#125;&#10;&#125;&#10;&#10;let c1 = Clock()&#10;c1.getCount() // &#24471;&#21040; 1&#10;c1.getCount() // &#24471;&#21040; 2&#10;let c2 = Clock()&#10;c2.getCount() // &#24471;&#21040; 1</span><br></pre></td></tr></table></figure>
<p>那么接下来，我们用高阶函数的方式，来做一下同样的事情。我们先看代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func getClock() -&#62; () -&#62; Int &#123;&#10;    var count: Int = 0&#10;    let getCount = &#123; () -&#62; Int in&#10;        ++count;&#10;    &#125;&#10;    return getCount&#10;&#125;&#10;&#10;let c1 = getClock()&#10;c1()  // &#24471;&#21040; 1&#10;c1()  // &#24471;&#21040; 2&#10;let c2 = getClock()&#10;c2()  // &#24471;&#21040; 1</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们这里定义了一个 <code>getClock</code> 函数，这个函数可以返回一个 <code>getCount</code> 函数。然后，不太一样的地方是，这个 <code>getCount</code> 函数持有了一个外部的变量 <code>count</code>。于是，这个函数也变得有了状态（或者你也可以说它有了 Side Effect）。每次调用这个函数的时候，返回的值都会变化。</p>
<p>另一方面，因为<code>count</code>变量是 <code>getClock</code> 这个高阶函数的内部变量，所以它并没有像全局变量一样使得封装性被打破。<code>getClock</code>函数仍然可以看作一个高内部的可复用模块，并且对外隐藏了实现细节。</p>
<p>所以，Swift 语言的高阶函数以及闭包可以 capture 外部变量的特性，使得代码逻辑可以以函数作为主体来进行封装，这将使得我们的代码组织更加灵活。</p>
<p>当然，如果滥用，这也会造成代码组织变得更加混乱。</p>
<h3 id="u9762_u8BD5_u9898"><a href="#u9762_u8BD5_u9898" class="headerlink" title="面试题"></a>面试题</h3><h4 id="u9898_u76EE_u4E00"><a href="#u9898_u76EE_u4E00" class="headerlink" title="题目一"></a>题目一</h4><p>另一个烧脑的故事是来自于一个朋友的面试题。在面试中，面试官要求他用数组的 <code>reduce</code> 方法实现 <code>map</code> 的功能。</p>
<p>这个题目实在是非常蛋疼，不过用来烧脑倒是不错，大家感兴趣的话可以先想想，再翻下面的参考答案。</p>
<h4 id="u9898_u76EE_u4E8C"><a href="#u9898_u76EE_u4E8C" class="headerlink" title="题目二"></a>题目二</h4><p>不过说回来，虽然题目一有些奇怪，但是它确实考查了对于高阶函数灵活使用以及对 <code>reduce</code> 方法的理解。大家还可以试试这些题目：</p>
<ul>
<li>问题一：用 <code>reduce</code> 方法找出数组中的最大值。</li>
<li>问题二：用 <code>reduce</code> 方法一次求出数组中奇数的和、以及偶数乘积。</li>
</ul>
<h4 id="u9898_u76EE_u4E09"><a href="#u9898_u76EE_u4E09" class="headerlink" title="题目三"></a>题目三</h4><p>高阶函数另一个魔力就是可以链式调用，大家可以尝试这么一道题目：求一个数组中偶数的平方和。</p>
<h3 id="u53C2_u8003_u7B54_u6848"><a href="#u53C2_u8003_u7B54_u6848" class="headerlink" title="参考答案"></a>参考答案</h3><h4 id="u9898_u76EE_u4E00-1"><a href="#u9898_u76EE_u4E00-1" class="headerlink" title="题目一"></a>题目一</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 3, 2]&#10;let res = arr.reduce([]) &#123;&#10;    (a: [Int], element: Int) -&#62; [Int] in&#10;    var t = Array(a)&#10;    t.append(element * 2)&#10;    return t&#10;&#125;&#10;// res = [2, 6, 4]</span><br></pre></td></tr></table></figure>
<h4 id="u9898_u76EE_u4E8C-1"><a href="#u9898_u76EE_u4E8C-1" class="headerlink" title="题目二"></a>题目二</h4><p>问题二的参考答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 3, 2, 4]&#10;&#10;let res: (Int, Int) = arr.reduce((0, 1)) &#123;&#10;    (a :(Int, Int), element: Int) -&#62; (Int, Int) in&#10;    if element % 2 == 0 &#123;&#10;        return (a.0, a.1 * element)&#10;    &#125; else &#123;&#10;        return (a.0 + element, a.1)&#10;    &#125;&#10;&#125;&#10;// res = (4, 8)</span><br></pre></td></tr></table></figure>
<h4 id="u9898_u76EE_u4E09-1"><a href="#u9898_u76EE_u4E09-1" class="headerlink" title="题目三"></a>题目三</h4><p>以下是参考答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 3, 2, 4]&#10;let res = arr.filter &#123;&#10;        $0 % 2 == 0&#10;    &#125;.map &#123;&#10;        $0 * $0&#10;    &#125;.reduce(0) &#123;&#10;        $0 + $1&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结一下本次烧脑锻炼到的脑细胞：</p>
<ul>
<li>学习了 Swift 语言中的一些使用高阶函数的示例，包括 <code>map</code>, <code>reduce</code>, <code>filter</code> 等。</li>
<li>学习了利用高阶函数来构造以函数为主体的功能模块。</li>
<li>练习了一些奇怪的面试题。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 烧脑体操（二） - 函数的参数]]></title>
    <link href="http://blog.devtang.com/2016/02/27/swift-gym-2-function-argument/"/>
    <id>http://blog.devtang.com/2016/02/27/swift-gym-2-function-argument/</id>
    <published>2016-02-27T01:23:29.000Z</published>
    <updated>2016-06-19T03:14:33.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/swift-brain-gym-arguments" target="_blank" rel="external">文章链接</a>。如需转载，请与 InfoQ 中文站联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第二节，练习前请做好准备运动，保持头脑清醒。</p>
<h2 id="u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6"><a href="#u51C6_u5907_u8FD0_u52A8_uFF1A_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="准备运动：基础知识"></a>准备运动：基础知识</h2><p><img src="http://ww3.sinaimg.cn/mw690/65dc76a3gw1f0sz14p1u4j206w0a33zb.jpg" alt=""></p>
<h3 id="u9762_u5411_u5BF9_u8C61_u8BED_u8A00_u7684_u4E16_u754C_u89C2"><a href="#u9762_u5411_u5BF9_u8C61_u8BED_u8A00_u7684_u4E16_u754C_u89C2" class="headerlink" title="面向对象语言的世界观"></a>面向对象语言的世界观</h3><p>对于很多面向对象的编程语言来说，在思考问题时，总是把「对象」作为考虑问题的基本出发点。</p>
<p>面向对象的程序设计通过以下三大规则，构建出程序设计的基础，它们是：</p>
<ol>
<li>封装（Encapsulation），将一个相对独立的逻辑涉及的变量和函数放到一个类中，然后对外暴露少量接口，使其高内聚，低耦合。</li>
<li>继承（Inheritance），子类可以继承父类的变量和函数，并且可以修改或扩展父类的行为。</li>
<li>多态（Polymorphism），父类的指针可以指向子类的实例，在运行时程序语言支持找到子类对应的函数实现。</li>
</ol>
<p>在以上三大准则的基础上，再引入一些设计原则，比如：</p>
<ol>
<li>单一职责原则（Single Responsibility），每个类只应该做一件事情。</li>
<li>不要重复原则（Don’t Repeat Yourself），相同（或相似）的代码不应该重复两次。</li>
<li>好的组合优于继承（Better Composition over Inheritance），尽量使用组合而不是继承来设计。</li>
</ol>
<p>于是，程序世界就基于这些规则和原则，产生出了设计模式，进而能更加精准地指导我们的编程行为。这就像我们学习几何，先学习几条公理，然后以后的大量定理都通过公理证明而来。</p>
<p>举个例子，单例模式（Singleton Pattern）其实就是封装和单一职责原则的产物。代理模式（Delegate Pattern) 也是单一职责和封装中的面向接口设计的思想的产物。</p>
<p>但是，在面向对象语言的世界观里面，函数都是作为一个附属物存在的。函数通常附属于一个具体类的某个方法中。或许有一个函数它根本都不需要任何对象作为容器，为了这个世界的统一，我们还是会构造一个类，把这个函数放进去。比如，在小猿搜题中，我们就有一个叫 ImageUtils 的类，里面放了操作图像的各种各样的静态方法，有一些图象操作函数其实也不太通用，但是总得找一个类放不是。</p>
<p>在一些面向对象语言的世界中，如果把对象称作 OOP 的一等公民的话，那么函数就是二等公民。</p>
<h3 id="u51FD_u6570_u5F0F_u7F16_u7A0B"><a href="#u51FD_u6570_u5F0F_u7F16_u7A0B" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>在 Swift 的世界中，函数并不是二等公民。是的，Swift 引入了大量函数式编程的特性，使得我们能够把函数当作一等公民来对待。</p>
<p>一等公民有什么权利呢？那就是函数可以像对象一样，被赋值、被当作参数传递、参与计算或者当作结果被返回。</p>
<p>我们先来看一段函数被赋值的例子，在下例中，我们将一个函数赋值给一个名为 <code>myFunc</code> 的变量，然后调用它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myFunc = &#123; &#10;    () -&#62; String in&#10;    return &#34;Tang Qiao&#34;&#10;&#125;&#10;&#10;let value = myFunc()&#10;// value &#30340;&#20540;&#20026; &#34;Tang Qiao&#34;</span><br></pre></td></tr></table></figure>
<p>我们再来看一个函数被当作运算结果返回的例子。在这个例子中，我们希望构造一个「加法器」工厂，这个工厂能够接受一个参数 addValue，返回一个加法器函数，这个加法器函数能够将传递的参数加 addValue 之后返回。以下是实现的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func addFactory(addValue: Int) -&#62; (Int -&#62; Int) &#123;&#10;    func adder(value: Int) -&#62; Int &#123;&#10;        return addValue + value&#10;    &#125;&#10;    return adder&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>有了上面这个函数，我们就可以构造一个 <code>+2</code> 的函数，然后使用它，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add2 = addFactory(2) // &#26500;&#36896;&#19968;&#20010; +2 &#30340;&#20989;&#25968;&#10;let result = add2(3) // &#36816;&#31639;&#65292;&#20256;&#20837; 3&#65292;&#24471;&#21040; 5</span><br></pre></td></tr></table></figure>
<h2 id="u51FD_u6570_u7684_u53C2_u6570"><a href="#u51FD_u6570_u7684_u53C2_u6570" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>但是在本次「烧脑体操」中，全面介绍函数式编程明显不太现实，所以我们仅从函数的参数来深入学习一下，看看在 Swift 语言中，函数的参数能够有多复杂。</p>
<!--
这里多说一句题外话，有部分同学看了「烧脑体操」第一节后，留言说：本来简单的 Swift 语言，被你这么一说，弄得都不敢学了，你是不是在吓大家？还有一些人留言：你搞这么绕还不是为了装逼？

对此，我想回答说：我研究这些仅仅是为了避免在语言细节的地方掉坑里，如果你对此不感兴趣，有一个动作叫做「取消关注」，我写文章并没有收费，如果你不喜欢，取关即可，犯不着在后台留言恶心我吧？
-->
<h3 id="u53C2_u6570_u7684_u7701_u7565"><a href="#u53C2_u6570_u7684_u7701_u7565" class="headerlink" title="参数的省略"></a>参数的省略</h3><p>我们先来简单看看函数参数的省略吧，因为有类型推导，函数的参数在 Swift 中常常可以被省略掉，特别以匿名函数（闭包）的形式存在的时候。</p>
<p>我们来看一个数组排序的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    (a: Int, b: Int) -&#62; Bool in&#10;    return a &#60; b&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个函数返回类型可以通过推导出来，则返回类型可以省略。所以以上代码中的 <code>-&gt; Bool</code> 可以删掉，变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    (a: Int, b: Int) in&#10;    return a &#60; b&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个函数的参数类型可以推导出来，则参数的类型可以省略。所以以上代码中的 <code>: Int</code> 可以删掉，变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    (a, b) in&#10;    return a &#60; b&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数参数的个数可以推导出来，也可以不写参数。那怎么使用这些参数呢？可以用 <code>$0</code>, <code>$1</code> 这样的方式来引用参数。所以以上代码中的 <code>(a, b)</code> 可以删掉，因为这样的话，参数和返回值都省略了，所以<code>in</code>也可以省略了，变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    return $0 &#60; $1&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 还有一个规则，如果函数的 body 只有一行，则可以把 <code>return</code> 关键字省略了，所以以上代码可以进一步简化成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort &#123;&#10;    $0 &#60; $1&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个简化规则更加暴力，因为 <code>&lt;</code> 符号也是一个函数，它接受的参数个数，类型和返回值与 sort 函数需要的一样，所以可以直接简化成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]&#10;let res = array.sort( &#60; )</span><br></pre></td></tr></table></figure>
<p>拿这个的方法，同样可以把我们刚刚写的 <code>addFactory</code> 做简化，最后简化成如下的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#31616;&#21270;&#21069;&#10;func addFactory(addValue: Int) -&#62; (Int -&#62; Int) &#123;&#10;    func adder(value: Int) -&#62; Int &#123;&#10;        return addValue + value&#10;    &#125;&#10;    return adder&#10;&#125;&#10;// &#31616;&#21270;&#21518;&#10;func addFactory(addValue: Int) -&#62; (Int -&#62; Int) &#123;&#10;    return &#123; addValue + $0 &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u51FD_u6570_u53C2_u6570_u4E2D_u7684_u5176_u5B83_u5173_u952E_u5B57"><a href="#u51FD_u6570_u53C2_u6570_u4E2D_u7684_u5176_u5B83_u5173_u952E_u5B57" class="headerlink" title="函数参数中的其它关键字"></a>函数参数中的其它关键字</h3><p>有些时候，我们的函数接受的参数就是另外一个函数，例如 sort，map，所以我们在看代码的时候，需要具备熟悉这种写法的能力。</p>
<p>我们来看看数组的 map 函数的定义吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func map&#60;T&#62;(@noescape transform: (Self.Generator.Element) throws -&#62; T) rethrows -&#62; [T]</span><br></pre></td></tr></table></figure>
<p>这个函数定义中出现了几个我们刚刚没提到的关键词，我们先学习一下。</p>
<h4 id="@noescape"><a href="#@noescape" class="headerlink" title="@noescape"></a><code>@noescape</code></h4><p><code>@noescape</code>，这是一个从 Swift 1.2 引入的关键字，它是专门用于修饰函数闭包这种参数类型的，当出现这个参数时，它表示该闭包不会跳出这个函数调用的生命期：即函数调用完之后，这个闭包的生命期也结束了。以下是苹果的文档原文：</p>
<blockquote>
<p>A new @noescape attribute may be used on closure parameters to functions. This indicates that the parameter is only ever called (or passed as an @noescape parameter in a call), which means that it cannot outlive the lifetime of the call. This enables some minor performance optimizations, but more importantly disables the self. requirement in closure arguments.</p>
</blockquote>
<p>什么情况下一个闭包参数会跳出函数的生命期呢？很简单，我们在函数实现内，将一个闭包用 <code>dispatch_async</code> 嵌套，这样这个闭包就会在另外一个线程中存在，从而跳出了当前函数的生命期。这样做主要是可以帮助编译器做性能的优化。</p>
<p>如果你对此感兴趣，这里有一些更详细的介绍供你学习：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/28427436/noescape-attribute-in-swift-1-2/28428521#28428521" target="_blank" rel="external">https://stackoverflow.com/questions/28427436/noescape-attribute-in-swift-1-2/28428521#28428521</a></li>
<li><a href="http://nshint.io/blog/2015/10/23/noescape-attribute/" target="_blank" rel="external">http://nshint.io/blog/2015/10/23/noescape-attribute/</a></li>
</ul>
<h4 id="throws__u548C_rethrows"><a href="#throws__u548C_rethrows" class="headerlink" title="throws 和 rethrows"></a><code>throws</code> 和 <code>rethrows</code></h4><p><code>throws</code> 关键字表示：这个函数（闭包）可能抛出异常。而 <code>rethrows</code> 关键字表示：这个函数如果抛出异常，仅可能是因为传递给它的闭包的调用导致了异常。</p>
<p><code>throws</code> 关键字的存在大家都应该能理解，因为总有一些异常可能在设计的时候希望暴露给上层，<code>throws</code> 关键字的存在使得这种设计成为可能。</p>
<p>那么为什么会有 <code>rethrows</code> 关键字呢？在我看来，这是为了简化很多代码的书写。因为一旦一个函数会抛出异常，按 Swift 类型安全的写法，我们就需要使用 try 语法。但是如果很多地方都需要写 try 的话，会造成代码非常啰嗦。 <code>rethrows</code> 关键字使得一些情况下，如果你传进去的闭包不会抛出异常，那么你的调用代码就不需要写 try。</p>
<p>如果你对此感兴趣，这里有一些更详细的介绍供你学习：</p>
<ul>
<li><a href="http://robnapier.net/re-throws" target="_blank" rel="external">http://robnapier.net/re-throws</a></li>
</ul>
<h3 id="u51FD_u6570_u4F5C_u4E3A_u51FD_u6570_u7684_u53C2_u6570"><a href="#u51FD_u6570_u4F5C_u4E3A_u51FD_u6570_u7684_u53C2_u6570" class="headerlink" title="函数作为函数的参数"></a>函数作为函数的参数</h3><p>刚刚说到，函数作为一等公民，意味着函数可以像对象一样，被当作参数传递或者被当作值返回。对此，我们专门有一个名称来称呼它，叫做<a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">高阶函数（higher-order function）</a>。</p>
<p>在刚刚那个数组的 map 函数中，我们就看到了它接着另外一个函数作为参数，这个函数接受数组元素类型作为参数，返回一个新类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func map&#60;T&#62;(@noescape transform: (Self.Generator.Element) throws -&#62; T) rethrows -&#62; [T]</span><br></pre></td></tr></table></figure>
<p>有了 map 函数，我们就可以轻松做数组元素的变换了。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 4]&#10;// arr = [1, 2, 4]&#10;&#10;let brr = arr.map &#123;&#10;    &#34;No.&#34; + String($0)&#10;&#125;&#10;// brr = [&#34;No.1&#34;, &#34;No.2&#34;, &#34;No.4&#34;]</span><br></pre></td></tr></table></figure>
<h2 id="u70E7_u8111_u7684_u53C2_u6570"><a href="#u70E7_u8111_u7684_u53C2_u6570" class="headerlink" title="烧脑的参数"></a>烧脑的参数</h2><p>好了，现在进入参数烧脑游戏的正式环节。</p>
<p>我们需要构造一个工厂函数，这个函数接受两个函数作为参数，返回一个新的函数。新函数是两个函数参数的叠加作用效果。</p>
<p>举一个具体的例子，假如我们有一个 <code>+2</code> 的函数，有一个 <code>+3</code> 的函数，那用这个工厂函数，我们可以得到一个 <code>+5</code> 的函数。</p>
<p>又比如我们有一个 <code>*2</code> 的函数，有一个 <code>*5</code> 的函数，用这个工厂函数，我们就可以得到一个 <code>*10</code> 的函数。</p>
<p>那这个函数如何写呢？我们先看答案吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func funcBuild(f: Int -&#62; Int, _ g: Int -&#62; Int) &#10;    -&#62; Int -&#62; Int &#123;&#10;    return &#123;&#10;        f(g($0))&#10;    &#125;&#10;&#125;&#10;&#10;let f1 = funcBuild(&#123;$0 + 2&#125;, &#123;$0 + 3&#125;)&#10;f1(0) // &#24471;&#21040; 5&#10;let f2 = funcBuild(&#123;$0 * 2&#125;, &#123;$0 * 5&#125;)&#10;f2(1) // &#24471;&#21040; 10</span><br></pre></td></tr></table></figure>
<p>这个函数充分反映了函数作为一等公民的地位。但是，我们同时也看出来，函数作为参数存在时，对于程序的可读性带来了挑战。好在我们有 <code>typealias</code>，通过 <code>typealias</code>，我们可以将函数的类型写得更加易读，比如上面的代码，就可以修改成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typealias IntFunction = Int -&#62; Int&#10;&#10;func funcBuild(f: IntFunction, _ g: IntFunction)&#10;    -&#62; IntFunction &#123;&#10;    return &#123;&#10;        f(g($0))&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>现在看看代码，是不是清晰了很多？</p>
<h2 id="u53C2_u6570_u4E2D_u7684_u8303_u578B"><a href="#u53C2_u6570_u4E2D_u7684_u8303_u578B" class="headerlink" title="参数中的范型"></a>参数中的范型</h2><p>当函数中的参数再引入范型之后，函数的功能更加强大，但是可读性进一步下降。比如刚刚的例子，限制函数只能是 <code>Int -&gt; Int</code> 其实是没有必要的，我们将两个函数拼成一个函数，只需要保证一个函数的输出类型，与另一个函数的输入类型匹配即可。所以，刚刚的例子，可以进一步用范型改造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func funcBuild&#60;T, U, V&#62;(f: T -&#62; U, _ g: V -&#62; T)&#10;    -&#62; V -&#62; U &#123;&#10;        return &#123;&#10;            f(g($0))&#10;        &#125;&#10;&#125;&#10;let f3 = funcBuild(&#123; &#34;No.&#34; + String($0) &#125;, &#123;$0 * 2&#125;)&#10;f3(23) // &#32467;&#26524;&#26159; &#34;No.46&#34;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，我们保证函数 g 的输出类型是 T，函数 f 的输入类型是 T。这样，在例子中，我们将一个 <code>*2</code> 的函数与一个数字转字符串的函数拼接起来，构造出一个先乘 2，再转字符串的函数。</p>
<p>相应的例子还有很多，比如 WWDC 中就介绍过一个给函数增加缓存机制的代码，在该代码中，任意一个不带缓存功能的函数，经过改造，都可以变成一个带缓存功能的函数。代码如下，大家可以自行学习一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func memoize&#60;T: Hashable, U&#62;( body: (T)-&#62;U ) -&#62; (T-&#62;U) &#123;&#10;    var memo = Dictionary&#60;T, U&#62;()&#10;    return &#123; x in&#10;        if let q = memo[x] &#123; return q &#125;&#10;        let r = body(x)&#10;        memo[x] = r&#10;        return r&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结一下本次烧脑锻炼到的脑细胞：</p>
<ul>
<li>Swift 是一个结合面向对象编程和函数式编程特性的语言。</li>
<li>函数在 Swift 中是一等公民，可以被赋值、被当作参数传递、参与计算、当作结果被返回或被动态创建。</li>
<li>因为有类型推导，函数的参数有各种省略规则。</li>
<li>函数作为参数时，有 @noescape，throw 和 rethrow 关键字需要了解。</li>
<li>函数作为参数时，不易阅读。合理使用 typealias 可以使源码结构更清晰。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg" alt=""></p>
<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_]]>
    </summary>
    
      <category term="Swift" scheme="http://blog.devtang.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
</feed>
