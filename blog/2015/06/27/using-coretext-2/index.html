
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>基于 CoreText 的排版引擎：进阶 - 唐巧的技术博客</title>
  <meta name="author" content="唐巧">

  
  <meta name="description" content="版权说明 原创文章，转载请保留以下信息： 本文节选自我的图书：《iOS 开发进阶 》。
本文涉及的 Demo 工程在这里：https://github.com/tangqiaoboy/iOS-Pro。
扫码关注我的「iOS 开发」微信公众帐号： 本章前言 在上一篇《基于 CoreText &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.devtang.com/blog/2015/06/27/using-coretext-2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="唐巧的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- googleapis is fucked by gfw -->
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28029597-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">唐巧的技术博客</a></h1>
  
    <h2>记录下自己学习的点滴</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.devtang.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
  <li><a href="/blog/categories/ios/">iOS开发专题</a></li>
  <li><a href="http://weibo.com/tangqiaoboy" target="_blank">我的微博</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">基于 CoreText 的排版引擎：进阶</h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-06-27T08:59:55+08:00" pubdate data-updated="true">Jun 27<span>th</span>, 2015</time>
        
      </p>
    
  </header>


<div class="entry-content"><h2>版权说明</h2>

<p>原创文章，转载请保留以下信息：</p>

<ul>
<li>本文节选自我的图书：《<a href="http://item.jd.com/11598468.html" target="_blank">iOS 开发进阶 </a>》。</li>
<li>本文涉及的 Demo 工程在这里：<a href="https://github.com/tangqiaoboy/iOS-Pro">https://github.com/tangqiaoboy/iOS-Pro</a>。</li>
<li>扫码关注我的「iOS 开发」微信公众帐号：</li>
</ul>


<p> <img src="http://blog.devtang.com/images/weixin-qr.jpg" alt="二维码" /></p>

<h2>本章前言</h2>

<p>在上一篇《基于 CoreText 的排版引擎：基础》中，我们学会了排版的基础知识，现在我们来增加复杂性，让我们的排版引擎支持图片和链接的点击。</p>

<h2>支持图文混排的排版引擎</h2>

<h3>改造模版文件</h3>

<p>下面我们来进一步改造，让排版引擎支持对于图片的排版。在上一小节中，我们在设置模版文件的时候，就专门在模板文件里面留了一个名为<code>type</code>的字段，用于表示内容的类型。之前的<code>type</code>的值都是<code>txt</code>，这次，我们增加一个值为<code>img</code>的值，用于表示图片。</p>

<p>我们将上一节的<code>content.json</code>文件修改为如下内容，增加了 2 个<code>type</code>值为<code>img</code>的配置项。由于是图片的配置项，所以我们不需要设置颜色，字号这些图片不具有的属性，但是，我们另外增加了 3 个图片的配置属性：</p>

<ol>
<li>一个名为<code>width</code>的属性，用于设置图片显示的宽度。</li>
<li>一个名为<code>height</code>的属性，用于设置图片显示的高度。</li>
<li>一个名为<code>name</code>的属性，用于设置图片的资源名。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[ {
</span><span class='line'>    "type" : "img",
</span><span class='line'>    "width" : 200,
</span><span class='line'>    "height" : 108,
</span><span class='line'>    "name" : "coretext-image-1.jpg"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "blue",
</span><span class='line'>    "content" : " 更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的 ",
</span><span class='line'>    "size" : 16,
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "red",
</span><span class='line'>    "content" : " 内容、颜色、字体 ",
</span><span class='line'>    "size" : 22,
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "black",
</span><span class='line'>    "content" : " 大小等信息。\n",
</span><span class='line'>    "size" : 16,
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  },
</span><span class='line'>  {
</span><span class='line'>    "type" : "img",
</span><span class='line'>    "width" : 200,
</span><span class='line'>    "height" : 130,
</span><span class='line'>    "name" : "coretext-image-2.jpg"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "default",
</span><span class='line'>    "content" : " 我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。",
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  }
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<p>按理说，图片本身的内容信息中，是包含宽度和高度信息的，为什么我们要在这里指定图片的宽高呢？这主要是因为，在真实的开发中，应用的模版和图片通常是通过服务器获取的，模版是纯文本的内容，获取速度比图片快很多，而图片不但获取速度慢，而且为了省流量，通常的做法是直到需要显示图片的时候，再加载图片内容。</p>

<p>如果我们不将图片的宽度和高度信息设置在模板里面，那么 CoreText 在排版的时候就无法知道绘制所需要的高度，我们就无法设置<code>CoreTextData</code>类中的<code>height</code>信息，没有高度信息，就会对 UITableView 一类的控件排版造成影响。所以，除非你的应用图片能够保证在绘制前都能全部在本地，否则就应该另外提前提供图片宽度和高度信息。</p>

<p>在完成模板文件修改后，我们选取两张测试用的图片，分别将其命名为<code>coretext-image-1.jpg</code>和<code>coretext-image-2.jpg</code>（和模板中的值一致），将其拖动增加到工程中。向 Xcode 工程增加图片资源是基础知识，在此就不详细介绍过程了。</p>

<h3>CTLine 与 CTRun</h3>

<p>接下来我们需要改造的是<code>CTFrameParser</code>类，让解析模板文件的方法支持<code>type</code>为<code>img</code>的配置。</p>

<p>在改造前，我们先来了解一下<code>CTFrame</code>内部的组成。通过之前的例子，我们可以看到，我们首先通过<code>NSAttributeString</code>和配置信息创建 <code>CTFrameSetter</code>，
然后，再通过<code>CTFrameSetter</code>来创建<code>CTFrame</code>。</p>

<p>在<code>CTFrame</code>内部，是由多个<code>CTLine</code>来组成的，每个<code>CTLine</code>代表一行，每个<code>CTLine</code>又是由多个<code>CTRun</code>来组成，每个<code>CTRun</code>代表一组显示风格一致的文本。我们不用手工管理<code>CTLine</code>和<code>CTRun</code>的创建过程。</p>

<p>下图是一个<code>CTLine</code>和<code>CTRun</code>的示意图，可以看到，第三行的<code>CTLine</code>是由 2 个<code>CTRun</code>构成的，第一个<code>CTRun</code>为红色大字号的左边部分，第二个<code>CTRun</code>为右边字体较小的部分。</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-ctline.jpg" alt="" /></p>

<p>虽然我们不用管理<code>CTRun</code>的创建过程，但是我们可以设置某一个具体的<code>CTRun</code>的<code>CTRunDelegate</code>来指定该文本在绘制时的高度、宽度、排列对齐方式等信息。</p>

<p>对于图片的排版，其实 CoreText 本质上不是直接支持的，但是，我们可以在要显示文本的地方，用一个特殊的空白字符代替，同时设置该字体的<code>CTRunDelegate</code>信息为要显示的图片的宽度和高度信息，这样最后生成的<code>CTFrame</code>实例，就会在绘制时将图片的位置预留出来。</p>

<p>因为我们的<code>CTDisplayView</code>的绘制代码是在<code>drawRect</code>里面的，所以我们可以方便地把需要绘制的图片，用<code>CGContextDrawImage</code>方法直接绘制出来就可以了。</p>

<h3>改造模版解析类</h3>

<p>在了解了以上原理后，我们就可以开始进行改造了。</p>

<p>我们需要做的工作包括：</p>

<ol>
<li>改造<code>CTFrameParser</code>的<code>parseTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config;</code>方法，使其支持对<code>type</code>为<code>img</code>的节点解析。并且对<code>type</code>为<code>img</code>的节点，设置其<code>CTRunDelegate</code>信息，使其在绘制时，为图片预留相应的空白位置。</li>
<li>改造<code>CoreTextData</code>类，增加图片相关的信息，并且增加计算图片绘制区域的逻辑。</li>
<li>改造<code>CTDisplayView</code>类，增加绘制图片相关的逻辑。</li>
</ol>


<p>首先介绍对于<code>CTFrameParser</code>的改造：</p>

<p>我们修改了<code>parseTemplateFile</code>方法，增加了一个名为<code>imageArray</code>的参数来保存解析时的图片信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (CoreTextData *)parseTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config {
</span><span class='line'>    NSMutableArray *imageArray = [NSMutableArray array];
</span><span class='line'>    NSAttributedString *content = [self loadTemplateFile:path config:config imageArray:imageArray];
</span><span class='line'>    CoreTextData *data = [self parseAttributedContent:content config:config];
</span><span class='line'>    data.imageArray = imageArray;
</span><span class='line'>    return data;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接着我们修改<code>loadTemplateFile</code>方法，增加了对于<code>type</code>是<code>img</code>的节点处理逻辑，该逻辑主要做 2 件事情：</p>

<ol>
<li>保存当前图片节点信息到<code>imageArray</code>变量中</li>
<li>新建一个空白的占位符。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSAttributedString *)loadTemplateFile:(NSString *)path
</span><span class='line'>                                  config:(CTFrameParserConfig*)config
</span><span class='line'>                              imageArray:(NSMutableArray *)imageArray {
</span><span class='line'>    NSData *data = [NSData dataWithContentsOfFile:path];
</span><span class='line'>    NSMutableAttributedString *result = [[NSMutableAttributedString alloc] init];
</span><span class='line'>    if (data) {
</span><span class='line'>        NSArray *array = [NSJSONSerialization JSONObjectWithData:data
</span><span class='line'>                             options:NSJSONReadingAllowFragments
</span><span class='line'>                               error:nil];
</span><span class='line'>        if ([array isKindOfClass:[NSArray class]]) {
</span><span class='line'>            for (NSDictionary *dict in array) {
</span><span class='line'>                NSString *type = dict[@"type"];
</span><span class='line'>                if ([type isEqualToString:@"txt"]) {
</span><span class='line'>                    NSAttributedString *as =
</span><span class='line'>                        [self parseAttributedContentFromNSDictionary:dict
</span><span class='line'>                                                              config:config];
</span><span class='line'>                    [result appendAttributedString:as];
</span><span class='line'>                } else if ([type isEqualToString:@"img"]) {
</span><span class='line'>                    // 创建 CoreTextImageData
</span><span class='line'>                    CoreTextImageData *imageData = [[CoreTextImageData alloc] init];
</span><span class='line'>                    imageData.name = dict[@"name"];
</span><span class='line'>                    imageData.position = [result length];
</span><span class='line'>                    [imageArray addObject:imageData];
</span><span class='line'>                    // 创建空白占位符，并且设置它的 CTRunDelegate 信息
</span><span class='line'>                    NSAttributedString *as = [self parseImageDataFromNSDictionary:dict config:config];
</span><span class='line'>                    [result appendAttributedString:as];
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return result;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后我们新建一个最关键的方法：<code>parseImageDataFromNSDictionary</code>，生成图片空白的占位符，并且设置其<code>CTRunDelegate</code>信息。其代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>static CGFloat ascentCallback(void *ref){
</span><span class='line'>    return [(NSNumber*)[(__bridge NSDictionary*)ref objectForKey:@"height"] floatValue];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static CGFloat descentCallback(void *ref){
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static CGFloat widthCallback(void* ref){
</span><span class='line'>    return [(NSNumber*)[(__bridge NSDictionary*)ref objectForKey:@"width"] floatValue];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (NSAttributedString *)parseImageDataFromNSDictionary:(NSDictionary *)dict
</span><span class='line'>                                                config:(CTFrameParserConfig*)config {
</span><span class='line'>    CTRunDelegateCallbacks callbacks;
</span><span class='line'>    memset(&callbacks, 0, sizeof(CTRunDelegateCallbacks));
</span><span class='line'>    callbacks.version = kCTRunDelegateVersion1;
</span><span class='line'>    callbacks.getAscent = ascentCallback;
</span><span class='line'>    callbacks.getDescent = descentCallback;
</span><span class='line'>    callbacks.getWidth = widthCallback;
</span><span class='line'>    CTRunDelegateRef delegate = CTRunDelegateCreate(&callbacks, (__bridge void *)(dict));
</span><span class='line'>
</span><span class='line'>    // 使用 0xFFFC 作为空白的占位符
</span><span class='line'>    unichar objectReplacementChar = 0xFFFC;
</span><span class='line'>    NSString * content = [NSString stringWithCharacters:&objectReplacementChar length:1];
</span><span class='line'>    NSDictionary * attributes = [self attributesWithConfig:config];
</span><span class='line'>    NSMutableAttributedString * space =
</span><span class='line'>       [[NSMutableAttributedString alloc] initWithString:content
</span><span class='line'>                                              attributes:attributes];
</span><span class='line'>    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)space,
</span><span class='line'>              CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);
</span><span class='line'>    CFRelease(delegate);
</span><span class='line'>    return space;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>接着我们对<code>CoreTextData</code>进行改造，增加了<code>imageArray</code>成员变量，用于保存图片绘制时所需的信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt;
</span><span class='line'>#import "CoreTextImageData.h"
</span><span class='line'>
</span><span class='line'>@interface CoreTextData : NSObject
</span><span class='line'>
</span><span class='line'>@property (assign, nonatomic) CTFrameRef ctFrame;
</span><span class='line'>@property (assign, nonatomic) CGFloat height;
</span><span class='line'>// 新增加的成员
</span><span class='line'>@property (strong, nonatomic) NSArray * imageArray;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>在设置<code>imageArray</code>成员时，我们还会调一个新创建的<code>fillImagePosition</code>方法，用于找到每张图片在绘制时的位置。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (void)setImageArray:(NSArray *)imageArray {
</span><span class='line'>    _imageArray = imageArray;
</span><span class='line'>    [self fillImagePosition];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)fillImagePosition {
</span><span class='line'>    if (self.imageArray.count == 0) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    NSArray *lines = (NSArray *)CTFrameGetLines(self.ctFrame);
</span><span class='line'>    int lineCount = [lines count];
</span><span class='line'>    CGPoint lineOrigins[lineCount];
</span><span class='line'>    CTFrameGetLineOrigins(self.ctFrame, CFRangeMake(0, 0), lineOrigins);
</span><span class='line'>
</span><span class='line'>    int imgIndex = 0;
</span><span class='line'>    CoreTextImageData * imageData = self.imageArray[0];
</span><span class='line'>
</span><span class='line'>    for (int i = 0; i &lt; lineCount; ++i) {
</span><span class='line'>        if (imageData == nil) {
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>        CTLineRef line = (__bridge CTLineRef)lines[i];
</span><span class='line'>        NSArray * runObjArray = (NSArray *)CTLineGetGlyphRuns(line);
</span><span class='line'>        for (id runObj in runObjArray) {
</span><span class='line'>            CTRunRef run = (__bridge CTRunRef)runObj;
</span><span class='line'>            NSDictionary *runAttributes = (NSDictionary *)CTRunGetAttributes(run);
</span><span class='line'>            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[runAttributes valueForKey:(id)kCTRunDelegateAttributeName];
</span><span class='line'>            if (delegate == nil) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            NSDictionary * metaDic = CTRunDelegateGetRefCon(delegate);
</span><span class='line'>            if (![metaDic isKindOfClass:[NSDictionary class]]) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            CGRect runBounds;
</span><span class='line'>            CGFloat ascent;
</span><span class='line'>            CGFloat descent;
</span><span class='line'>            runBounds.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &ascent, &descent, NULL);
</span><span class='line'>            runBounds.size.height = ascent + descent;
</span><span class='line'>
</span><span class='line'>            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);
</span><span class='line'>            runBounds.origin.x = lineOrigins[i].x + xOffset;
</span><span class='line'>            runBounds.origin.y = lineOrigins[i].y;
</span><span class='line'>            runBounds.origin.y -= descent;
</span><span class='line'>
</span><span class='line'>            CGPathRef pathRef = CTFrameGetPath(self.ctFrame);
</span><span class='line'>            CGRect colRect = CGPathGetBoundingBox(pathRef);
</span><span class='line'>
</span><span class='line'>            CGRect delegateBounds = CGRectOffset(runBounds, colRect.origin.x, colRect.origin.y);
</span><span class='line'>
</span><span class='line'>            imageData.imagePosition = delegateBounds;
</span><span class='line'>            imgIndex++;
</span><span class='line'>            if (imgIndex == self.imageArray.count) {
</span><span class='line'>                imageData = nil;
</span><span class='line'>                break;
</span><span class='line'>            } else {
</span><span class='line'>                imageData = self.imageArray[imgIndex];
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>添加对图片的点击支持</h2>

<h3>实现方式</h3>

<p>为了实现对图片的点击支持，我们需要给<code>CTDisplayView</code>类增加用户点击操作的检测函数，在检测函数中，判断当前用户点击的区域是否在图片上，如果在图片上，则触发点击图片的逻辑。苹果提供的<code>UITapGestureRecognizer</code>可以很好的满足我们的要求，所以我们这里用它来检测用户的点击操作。</p>

<p>我们这里实现的是点击图片后，先用<code>NSLog</code>打印出一行日志。实际应用中，读者可以根据业务需求自行调整点击后的效果。</p>

<p>我们先为<code>CTDisplayView</code>类增加<code>UITapGestureRecognizer</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)initWithCoder:(NSCoder *)aDecoder {
</span><span class='line'>    self = [super initWithCoder:aDecoder];
</span><span class='line'>    if (self) {
</span><span class='line'>        [self setupEvents];
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setupEvents {
</span><span class='line'>    UIGestureRecognizer * tapRecognizer =
</span><span class='line'>          [[UITapGestureRecognizer alloc] initWithTarget:self
</span><span class='line'>                    action:@selector(userTapGestureDetected:)];
</span><span class='line'>    tapRecognizer.delegate = self;
</span><span class='line'>    [self addGestureRecognizer:tapRecognizer];
</span><span class='line'>    self.userInteractionEnabled = YES;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>然后增加<code>UITapGestureRecognizer</code>的回调函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)userTapGestureDetected:(UIGestureRecognizer *)recognizer {
</span><span class='line'>    CGPoint point = [recognizer locationInView:self];
</span><span class='line'>    for (CoreTextImageData * imageData in self.data.imageArray) {
</span><span class='line'>        // 翻转坐标系，因为 imageData 中的坐标是 CoreText 的坐标系
</span><span class='line'>        CGRect imageRect = imageData.imagePosition;
</span><span class='line'>        CGPoint imagePosition = imageRect.origin;
</span><span class='line'>        imagePosition.y = self.bounds.size.height - imageRect.origin.y
</span><span class='line'>                          - imageRect.size.height;
</span><span class='line'>        CGRect rect = CGRectMake(imagePosition.x, imagePosition.y, imageRect.size.width, imageRect.size.height);
</span><span class='line'>        // 检测点击位置 Point 是否在 rect 之内
</span><span class='line'>        if (CGRectContainsPoint(rect, point)) {
</span><span class='line'>            // 在这里处理点击后的逻辑
</span><span class='line'>            NSLog(@"bingo");
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>事件处理</h3>

<p>在界面上，<code>CTDisplayView</code>通常在<code>UIView</code>的树形层级结构中，一个 UIView 可能是最外层 View Controller 的 View 的孩子的孩子的孩子（如下图所示）。在这种多级层次结构中，很难通过<code>delegate</code>模式将图片点击的事件一层一层往外层传递，所以最好使用<code>NSNotification</code>，来处理图片点击事件。</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-uiview-tree.png" alt="" /></p>

<p>在 Demo 中，我们在最外层的 View Controller 中监听图片点击的通知，当收到通知后，进入到一个新的界面来显示图片点击内容。</p>

<p>注：读者可以将 demo 工程切换到<code>image_click</code>分支，查看示例代码。</p>

<h3>添加对链接的点击支持</h3>

<h4>修改模板文件</h4>

<p>我们修改模版文件，增加一个名为 link 的类型，用于表示链接内容。如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[
</span><span class='line'>  { "color" : "default",
</span><span class='line'>    "content" : " 这在这里尝试放一个参考链接：",
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "blue",
</span><span class='line'>    "content" : " 链接文字 ",
</span><span class='line'>    "url" : "http://blog.devtang.com",
</span><span class='line'>    "type" : "link"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "default",
</span><span class='line'>    "content" : " 大家可以尝试点击一下 ",
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  }
</span><span class='line'>]
</span></code></pre></td></tr></table></div></figure>


<h4>解析模版中的链接信息</h4>

<p>我们首先增加一个<code>CoreTextLinkData</code>类，用于记录解析 JSON 文件时的链接信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface CoreTextLinkData : NSObject
</span><span class='line'>
</span><span class='line'>@property (strong, nonatomic) NSString * title;
</span><span class='line'>@property (strong, nonatomic) NSString * url;
</span><span class='line'>@property (assign, nonatomic) NSRange range;
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>然后我们修改 CTFrameParser 类，增加解析链接的逻辑：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSAttributedString *)loadTemplateFile:(NSString *)path
</span><span class='line'>                                  config:(CTFrameParserConfig*)config
</span><span class='line'>                              imageArray:(NSMutableArray *)imageArray
</span><span class='line'>                               linkArray:(NSMutableArray *)linkArray {
</span><span class='line'>    NSData *data = [NSData dataWithContentsOfFile:path];
</span><span class='line'>    NSMutableAttributedString *result = [[NSMutableAttributedString alloc] init];
</span><span class='line'>    if (data) {
</span><span class='line'>        NSArray *array = [NSJSONSerialization JSONObjectWithData:data
</span><span class='line'>                                        options:NSJSONReadingAllowFragments
</span><span class='line'>                                          error:nil];
</span><span class='line'>        if ([array isKindOfClass:[NSArray class]]) {
</span><span class='line'>            for (NSDictionary *dict in array) {
</span><span class='line'>                NSString *type = dict[@"type"];
</span><span class='line'>                if ([type isEqualToString:@"txt"]) {
</span><span class='line'>                    // 省略
</span><span class='line'>                } else if ([type isEqualToString:@"img"]) {
</span><span class='line'>                    // 省略
</span><span class='line'>                } else if ([type isEqualToString:@"link"]) {
</span><span class='line'>                    NSUInteger startPos = result.length;
</span><span class='line'>                    NSAttributedString *as =
</span><span class='line'>                       [self parseAttributedContentFromNSDictionary:dict
</span><span class='line'>                                                             config:config];
</span><span class='line'>                    [result appendAttributedString:as];
</span><span class='line'>                    // 创建 CoreTextLinkData
</span><span class='line'>                    NSUInteger length = result.length - startPos;
</span><span class='line'>                    NSRange linkRange = NSMakeRange(startPos, length);
</span><span class='line'>                    CoreTextLinkData *linkData = [[CoreTextLinkData alloc] init];
</span><span class='line'>                    linkData.title = dict[@"content"];
</span><span class='line'>                    linkData.url = dict[@"url"];
</span><span class='line'>                    linkData.range = linkRange;
</span><span class='line'>                    [linkArray addObject:linkData];
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return result;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>然后，我们增加一个 Utils 类来专门处理检测用户点击是否在链接上。主要的方法是使用 CTLineGetStringIndexForPosition 函数来获得用户点击的位置与 NSAttributedString 字符串上的位置的对应关系。这样就知道是点击的哪个字符了。然后判断该字符串是否在链接上即可。该 Util 在实现逻辑如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 检测点击位置是否在链接上
</span><span class='line'>+ (CoreTextLinkData *)touchLinkInView:(UIView *)view atPoint:(CGPoint)point data:(CoreTextData *)data {
</span><span class='line'>    CTFrameRef textFrame = data.ctFrame;
</span><span class='line'>    CFArrayRef lines = CTFrameGetLines(textFrame);
</span><span class='line'>    if (!lines) return nil;
</span><span class='line'>    CFIndex count = CFArrayGetCount(lines);
</span><span class='line'>    CoreTextLinkData *foundLink = nil;
</span><span class='line'>
</span><span class='line'>    // 获得每一行的 origin 坐标
</span><span class='line'>    CGPoint origins[count];
</span><span class='line'>    CTFrameGetLineOrigins(textFrame, CFRangeMake(0,0), origins);
</span><span class='line'>
</span><span class='line'>    // 翻转坐标系
</span><span class='line'>    CGAffineTransform transform =  CGAffineTransformMakeTranslation(0, view.bounds.size.height);
</span><span class='line'>    transform = CGAffineTransformScale(transform, 1.f, -1.f);
</span><span class='line'>
</span><span class='line'>    for (int i = 0; i &lt; count; i++) {
</span><span class='line'>        CGPoint linePoint = origins[i];
</span><span class='line'>        CTLineRef line = CFArrayGetValueAtIndex(lines, i);
</span><span class='line'>        // 获得每一行的 CGRect 信息
</span><span class='line'>        CGRect flippedRect = [self getLineBounds:line point:linePoint];
</span><span class='line'>        CGRect rect = CGRectApplyAffineTransform(flippedRect, transform);
</span><span class='line'>
</span><span class='line'>        if (CGRectContainsPoint(rect, point)) {
</span><span class='line'>            // 将点击的坐标转换成相对于当前行的坐标
</span><span class='line'>            CGPoint relativePoint = CGPointMake(point.x-CGRectGetMinX(rect),
</span><span class='line'>                                                point.y-CGRectGetMinY(rect));
</span><span class='line'>            // 获得当前点击坐标对应的字符串偏移
</span><span class='line'>            CFIndex idx = CTLineGetStringIndexForPosition(line, relativePoint);
</span><span class='line'>            // 判断这个偏移是否在我们的链接列表中
</span><span class='line'>            foundLink = [self linkAtIndex:idx linkArray:data.linkArray];
</span><span class='line'>            return foundLink;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (CGRect)getLineBounds:(CTLineRef)line point:(CGPoint)point {
</span><span class='line'>    CGFloat ascent = 0.0f;
</span><span class='line'>    CGFloat descent = 0.0f;
</span><span class='line'>    CGFloat leading = 0.0f;
</span><span class='line'>    CGFloat width = (CGFloat)CTLineGetTypographicBounds(line, &ascent, &descent, &leading);
</span><span class='line'>    CGFloat height = ascent + descent;
</span><span class='line'>    return CGRectMake(point.x, point.y - descent, width, height);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (CoreTextLinkData *)linkAtIndex:(CFIndex)i linkArray:(NSArray *)linkArray {
</span><span class='line'>    CoreTextLinkData *link = nil;
</span><span class='line'>    for (CoreTextLinkData *data in linkArray) {
</span><span class='line'>        if (NSLocationInRange(i, data.range)) {
</span><span class='line'>            link = data;
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return link;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>最后改造一下<code>CTDisplayView</code>，使其在检测到用户点击后，调用上面的 Util 方法即可。我们这里实现的是点击链接后，先用<code>NSLog</code>打印出一行日志。实际应用中，读者可以根据业务需求自行调整点击后的效果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)userTapGestureDetected:(UIGestureRecognizer *)recognizer {
</span><span class='line'>    CGPoint point = [recognizer locationInView:self];
</span><span class='line'>    // 此处省略上一节中介绍的，对图片点击检测的逻辑
</span><span class='line'>
</span><span class='line'>    CoreTextLinkData *linkData = [CoreTextUtils touchLinkInView:self atPoint:point data:self.data];
</span><span class='line'>    if (linkData) {
</span><span class='line'>        NSLog(@"hint link!");
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注：在 Demo 中工程中，我们实现了点击链接跳转到一个新的界面，然后用 UIWebView 来显示链接内容的逻辑。读者可以将 demo 工程切换到<code>link_click</code>分支，查看示例代码。</p>

<p>Demo 工程的 Gif 效果图如下，读者可以将示例工程用<code>git checkout image_support</code>切换到当前章节状态，查看相关代码逻辑。</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-demo.gif" alt="" /></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">唐巧</span></span>

      








  


<time datetime="2015-06-27T08:59:55+08:00" pubdate data-updated="true">Jun 27<span>th</span>, 2015</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/ios/'>iOS</a>
  
</span>


    </p>
    <p class="meta">
      关注我的「iOS开发」微信公众号，每天获得精选的 iOS 开发文章和创业心得：<br>
<img src="/images/weixin-qr.jpg" />

<br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" id="">Creative Commons BY-NC-ND 3.0</a>

    </p>
    
      <div class="sharing">
  
  
  
  
    <style>
    .flash-video{display:none;}
</style>
<!-- JiaThis Button BEGIN -->
<div id="ckepop">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_tsina">新浪微博</a>
<a class="jiathis_button_t163">网易微博</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_renren">人人网</a>
<a class="jiathis_button_douban">豆瓣</a>

<a href="http://www.jiathis.com/share?uid=1574434" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
    data_track_clickback:true,
    sm:"t163,tsina,tqq,renren,douban",
    summary:"",
    hideMore:false
}
</script>
<script type="text/javascript" src="http://v2.jiathis.com/code_mini/jia.js?uid=1574434" charset="utf-8"></script>
<!-- JiaThis Button END -->

<br />
<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" id="UYScript" src="http://v1.uyan.cc/js/iframe.js?UYUserId=89581" async=""></script>
<!-- UY END -->

  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/06/27/using-coretext-1/" title="Previous Post: 基于 CoreText 的排版引擎：基础">&laquo; 基于 CoreText 的排版引擎：基础</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/06/28/apple-watch-usage-exp/" title="Next Post: Apple Watch 使用体验">Apple Watch 使用体验 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>赞助商</h1>
  <p>
     <a href="http://zc.pgyer.com" target="_blank"><img width="260px" src="/images/ad_pgyer.png" /></a>
  </p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/17/how-to-read-a-book-summary/">教你阅读图书的「方法论」- 评《如何阅读一本书》</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/12/saul-introdution/">MagicalRecord 作者 Saul Mora 的故事</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/10/atswift-conference-summary/">首届Swift开发者大会见闻</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/03/reactive-cocoa-discussion/">ReactiveCocoa 讨论会</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/02/2015-summary/">2015 年个人总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/24/resume-cheat-story/">培训机构出来的 iOS 学员怎么了？</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/18/from-dev-to-manager/">涅槃重生:我的技术转管理之路</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/26/yykit-auther-interview/">专访 YYKit 作者 Ibireme: 开源大牛是怎样炼成的</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/21/apps-damaged-bug/">Mac 应用出现「已损坏」问题，苹果到底犯了什么傻逼错误？</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/14/charles-introduction/">Charles 从入门到精通(中国5折特惠)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/02/mvc-and-mvvm/">被误解的 MVC 和被神化的 MVVM</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/25/one-on-one-summary/">浅析一对一沟通</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>About Me</h1>
  <p>InfoQ编辑, 《<a href="http://item.jd.com/11598468.html" target="_blank">iOS开发进阶</a>》作者, 在猿题库创业。<br/>
      <br/>Java开发工程师，曾开发网易邮箱、微博。
      <br/>iOS开发工程师，曾开发有道云笔记、猿题库、小猿搜题。
  </p>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  &copy; 2016 - 唐巧 -
  <span class="credit">基于 <a href="http://octopress.org" target="_blank">Octopress</a></span>
  <span class="credit">, 感谢 <a href="http://gitcafe.com/signup?invited_by=tangqiaoboy" target="_blank">GitCafe</a> 为本站提供存储空间</span>
</p>

</footer>
  









<script src=" http://tjs.sjs.sinajs.cn/open/api/js/wb.js?appkey=2351546126" type="text/javascript" charset="utf-8"></script>
<script>
WB2.anyWhere(function(W){
W.widget.followButton({
    uid: 1708947107,
    id: "wb_follow_btn"
    });
});
</script>


</body>
</html>
