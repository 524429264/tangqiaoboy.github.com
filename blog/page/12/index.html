
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>唐巧的技术博客</title>
  <meta name="author" content="唐巧">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="唐巧的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- googleapis is fucked by gfw -->
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28029597-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">唐巧的技术博客</a></h1>
  
    <h2>记录下自己学习的点滴</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.devtang.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
  <li><a href="/blog/categories/ios/">iOS开发专题</a></li>
  <li><a href="http://weibo.com/tangqiaoboy" target="_blank">我的微博</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/27/using-coretext-2/">基于 CoreText 的排版引擎：进阶</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-06-27T08:59:55+08:00" pubdate data-updated="true">Jun 27<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>版权说明</h2>

<p>原创文章，转载请保留以下信息：</p>

<ul>
<li>本文节选自我的图书：《<a href="http://item.jd.com/11598468.html" target="_blank">iOS 开发进阶 </a>》。</li>
<li>本文涉及的 Demo 工程在这里：<a href="https://github.com/tangqiaoboy/iOS-Pro">https://github.com/tangqiaoboy/iOS-Pro</a>。</li>
<li>扫码关注我的「iOS 开发」微信公众帐号：</li>
</ul>


<p> <img src="http://blog.devtang.com/images/weixin-qr.jpg" alt="二维码" /></p>

<h2>本章前言</h2>

<p>在上一篇《基于 CoreText 的排版引擎：基础》中，我们学会了排版的基础知识，现在我们来增加复杂性，让我们的排版引擎支持图片和链接的点击。</p>

<h2>支持图文混排的排版引擎</h2>

<h3>改造模版文件</h3>

<p>下面我们来进一步改造，让排版引擎支持对于图片的排版。在上一小节中，我们在设置模版文件的时候，就专门在模板文件里面留了一个名为<code>type</code>的字段，用于表示内容的类型。之前的<code>type</code>的值都是<code>txt</code>，这次，我们增加一个值为<code>img</code>的值，用于表示图片。</p>

<p>我们将上一节的<code>content.json</code>文件修改为如下内容，增加了 2 个<code>type</code>值为<code>img</code>的配置项。由于是图片的配置项，所以我们不需要设置颜色，字号这些图片不具有的属性，但是，我们另外增加了 3 个图片的配置属性：</p>

<ol>
<li>一个名为<code>width</code>的属性，用于设置图片显示的宽度。</li>
<li>一个名为<code>height</code>的属性，用于设置图片显示的高度。</li>
<li>一个名为<code>name</code>的属性，用于设置图片的资源名。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[ {
</span><span class='line'>    "type" : "img",
</span><span class='line'>    "width" : 200,
</span><span class='line'>    "height" : 108,
</span><span class='line'>    "name" : "coretext-image-1.jpg"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "blue",
</span><span class='line'>    "content" : " 更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的 ",
</span><span class='line'>    "size" : 16,
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "red",
</span><span class='line'>    "content" : " 内容、颜色、字体 ",
</span><span class='line'>    "size" : 22,
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "black",
</span><span class='line'>    "content" : " 大小等信息。\n",
</span><span class='line'>    "size" : 16,
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  },
</span><span class='line'>  {
</span><span class='line'>    "type" : "img",
</span><span class='line'>    "width" : 200,
</span><span class='line'>    "height" : 130,
</span><span class='line'>    "name" : "coretext-image-2.jpg"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "default",
</span><span class='line'>    "content" : " 我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。",
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  }
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<p>按理说，图片本身的内容信息中，是包含宽度和高度信息的，为什么我们要在这里指定图片的宽高呢？这主要是因为，在真实的开发中，应用的模版和图片通常是通过服务器获取的，模版是纯文本的内容，获取速度比图片快很多，而图片不但获取速度慢，而且为了省流量，通常的做法是直到需要显示图片的时候，再加载图片内容。</p>

<p>如果我们不将图片的宽度和高度信息设置在模板里面，那么 CoreText 在排版的时候就无法知道绘制所需要的高度，我们就无法设置<code>CoreTextData</code>类中的<code>height</code>信息，没有高度信息，就会对 UITableView 一类的控件排版造成影响。所以，除非你的应用图片能够保证在绘制前都能全部在本地，否则就应该另外提前提供图片宽度和高度信息。</p>

<p>在完成模板文件修改后，我们选取两张测试用的图片，分别将其命名为<code>coretext-image-1.jpg</code>和<code>coretext-image-2.jpg</code>（和模板中的值一致），将其拖动增加到工程中。向 Xcode 工程增加图片资源是基础知识，在此就不详细介绍过程了。</p>

<h3>CTLine 与 CTRun</h3>

<p>接下来我们需要改造的是<code>CTFrameParser</code>类，让解析模板文件的方法支持<code>type</code>为<code>img</code>的配置。</p>

<p>在改造前，我们先来了解一下<code>CTFrame</code>内部的组成。通过之前的例子，我们可以看到，我们首先通过<code>NSAttributeString</code>和配置信息创建 <code>CTFrameSetter</code>，
然后，再通过<code>CTFrameSetter</code>来创建<code>CTFrame</code>。</p>

<p>在<code>CTFrame</code>内部，是由多个<code>CTLine</code>来组成的，每个<code>CTLine</code>代表一行，每个<code>CTLine</code>又是由多个<code>CTRun</code>来组成，每个<code>CTRun</code>代表一组显示风格一致的文本。我们不用手工管理<code>CTLine</code>和<code>CTRun</code>的创建过程。</p>

<p>下图是一个<code>CTLine</code>和<code>CTRun</code>的示意图，可以看到，第三行的<code>CTLine</code>是由 2 个<code>CTRun</code>构成的，第一个<code>CTRun</code>为红色大字号的左边部分，第二个<code>CTRun</code>为右边字体较小的部分。</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-ctline.jpg" alt="" /></p>

<p>虽然我们不用管理<code>CTRun</code>的创建过程，但是我们可以设置某一个具体的<code>CTRun</code>的<code>CTRunDelegate</code>来指定该文本在绘制时的高度、宽度、排列对齐方式等信息。</p>

<p>对于图片的排版，其实 CoreText 本质上不是直接支持的，但是，我们可以在要显示文本的地方，用一个特殊的空白字符代替，同时设置该字体的<code>CTRunDelegate</code>信息为要显示的图片的宽度和高度信息，这样最后生成的<code>CTFrame</code>实例，就会在绘制时将图片的位置预留出来。</p>

<p>因为我们的<code>CTDisplayView</code>的绘制代码是在<code>drawRect</code>里面的，所以我们可以方便地把需要绘制的图片，用<code>CGContextDrawImage</code>方法直接绘制出来就可以了。</p>

<h3>改造模版解析类</h3>

<p>在了解了以上原理后，我们就可以开始进行改造了。</p>

<p>我们需要做的工作包括：</p>

<ol>
<li>改造<code>CTFrameParser</code>的<code>parseTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config;</code>方法，使其支持对<code>type</code>为<code>img</code>的节点解析。并且对<code>type</code>为<code>img</code>的节点，设置其<code>CTRunDelegate</code>信息，使其在绘制时，为图片预留相应的空白位置。</li>
<li>改造<code>CoreTextData</code>类，增加图片相关的信息，并且增加计算图片绘制区域的逻辑。</li>
<li>改造<code>CTDisplayView</code>类，增加绘制图片相关的逻辑。</li>
</ol>


<p>首先介绍对于<code>CTFrameParser</code>的改造：</p>

<p>我们修改了<code>parseTemplateFile</code>方法，增加了一个名为<code>imageArray</code>的参数来保存解析时的图片信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (CoreTextData *)parseTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config {
</span><span class='line'>    NSMutableArray *imageArray = [NSMutableArray array];
</span><span class='line'>    NSAttributedString *content = [self loadTemplateFile:path config:config imageArray:imageArray];
</span><span class='line'>    CoreTextData *data = [self parseAttributedContent:content config:config];
</span><span class='line'>    data.imageArray = imageArray;
</span><span class='line'>    return data;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接着我们修改<code>loadTemplateFile</code>方法，增加了对于<code>type</code>是<code>img</code>的节点处理逻辑，该逻辑主要做 2 件事情：</p>

<ol>
<li>保存当前图片节点信息到<code>imageArray</code>变量中</li>
<li>新建一个空白的占位符。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSAttributedString *)loadTemplateFile:(NSString *)path
</span><span class='line'>                                  config:(CTFrameParserConfig*)config
</span><span class='line'>                              imageArray:(NSMutableArray *)imageArray {
</span><span class='line'>    NSData *data = [NSData dataWithContentsOfFile:path];
</span><span class='line'>    NSMutableAttributedString *result = [[NSMutableAttributedString alloc] init];
</span><span class='line'>    if (data) {
</span><span class='line'>        NSArray *array = [NSJSONSerialization JSONObjectWithData:data
</span><span class='line'>                             options:NSJSONReadingAllowFragments
</span><span class='line'>                               error:nil];
</span><span class='line'>        if ([array isKindOfClass:[NSArray class]]) {
</span><span class='line'>            for (NSDictionary *dict in array) {
</span><span class='line'>                NSString *type = dict[@"type"];
</span><span class='line'>                if ([type isEqualToString:@"txt"]) {
</span><span class='line'>                    NSAttributedString *as =
</span><span class='line'>                        [self parseAttributedContentFromNSDictionary:dict
</span><span class='line'>                                                              config:config];
</span><span class='line'>                    [result appendAttributedString:as];
</span><span class='line'>                } else if ([type isEqualToString:@"img"]) {
</span><span class='line'>                    // 创建 CoreTextImageData
</span><span class='line'>                    CoreTextImageData *imageData = [[CoreTextImageData alloc] init];
</span><span class='line'>                    imageData.name = dict[@"name"];
</span><span class='line'>                    imageData.position = [result length];
</span><span class='line'>                    [imageArray addObject:imageData];
</span><span class='line'>                    // 创建空白占位符，并且设置它的 CTRunDelegate 信息
</span><span class='line'>                    NSAttributedString *as = [self parseImageDataFromNSDictionary:dict config:config];
</span><span class='line'>                    [result appendAttributedString:as];
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return result;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后我们新建一个最关键的方法：<code>parseImageDataFromNSDictionary</code>，生成图片空白的占位符，并且设置其<code>CTRunDelegate</code>信息。其代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>static CGFloat ascentCallback(void *ref){
</span><span class='line'>    return [(NSNumber*)[(__bridge NSDictionary*)ref objectForKey:@"height"] floatValue];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static CGFloat descentCallback(void *ref){
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static CGFloat widthCallback(void* ref){
</span><span class='line'>    return [(NSNumber*)[(__bridge NSDictionary*)ref objectForKey:@"width"] floatValue];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (NSAttributedString *)parseImageDataFromNSDictionary:(NSDictionary *)dict
</span><span class='line'>                                                config:(CTFrameParserConfig*)config {
</span><span class='line'>    CTRunDelegateCallbacks callbacks;
</span><span class='line'>    memset(&callbacks, 0, sizeof(CTRunDelegateCallbacks));
</span><span class='line'>    callbacks.version = kCTRunDelegateVersion1;
</span><span class='line'>    callbacks.getAscent = ascentCallback;
</span><span class='line'>    callbacks.getDescent = descentCallback;
</span><span class='line'>    callbacks.getWidth = widthCallback;
</span><span class='line'>    CTRunDelegateRef delegate = CTRunDelegateCreate(&callbacks, (__bridge void *)(dict));
</span><span class='line'>
</span><span class='line'>    // 使用 0xFFFC 作为空白的占位符
</span><span class='line'>    unichar objectReplacementChar = 0xFFFC;
</span><span class='line'>    NSString * content = [NSString stringWithCharacters:&objectReplacementChar length:1];
</span><span class='line'>    NSDictionary * attributes = [self attributesWithConfig:config];
</span><span class='line'>    NSMutableAttributedString * space =
</span><span class='line'>       [[NSMutableAttributedString alloc] initWithString:content
</span><span class='line'>                                              attributes:attributes];
</span><span class='line'>    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)space,
</span><span class='line'>              CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);
</span><span class='line'>    CFRelease(delegate);
</span><span class='line'>    return space;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>接着我们对<code>CoreTextData</code>进行改造，增加了<code>imageArray</code>成员变量，用于保存图片绘制时所需的信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt;
</span><span class='line'>#import "CoreTextImageData.h"
</span><span class='line'>
</span><span class='line'>@interface CoreTextData : NSObject
</span><span class='line'>
</span><span class='line'>@property (assign, nonatomic) CTFrameRef ctFrame;
</span><span class='line'>@property (assign, nonatomic) CGFloat height;
</span><span class='line'>// 新增加的成员
</span><span class='line'>@property (strong, nonatomic) NSArray * imageArray;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>在设置<code>imageArray</code>成员时，我们还会调一个新创建的<code>fillImagePosition</code>方法，用于找到每张图片在绘制时的位置。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (void)setImageArray:(NSArray *)imageArray {
</span><span class='line'>    _imageArray = imageArray;
</span><span class='line'>    [self fillImagePosition];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)fillImagePosition {
</span><span class='line'>    if (self.imageArray.count == 0) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    NSArray *lines = (NSArray *)CTFrameGetLines(self.ctFrame);
</span><span class='line'>    int lineCount = [lines count];
</span><span class='line'>    CGPoint lineOrigins[lineCount];
</span><span class='line'>    CTFrameGetLineOrigins(self.ctFrame, CFRangeMake(0, 0), lineOrigins);
</span><span class='line'>
</span><span class='line'>    int imgIndex = 0;
</span><span class='line'>    CoreTextImageData * imageData = self.imageArray[0];
</span><span class='line'>
</span><span class='line'>    for (int i = 0; i &lt; lineCount; ++i) {
</span><span class='line'>        if (imageData == nil) {
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>        CTLineRef line = (__bridge CTLineRef)lines[i];
</span><span class='line'>        NSArray * runObjArray = (NSArray *)CTLineGetGlyphRuns(line);
</span><span class='line'>        for (id runObj in runObjArray) {
</span><span class='line'>            CTRunRef run = (__bridge CTRunRef)runObj;
</span><span class='line'>            NSDictionary *runAttributes = (NSDictionary *)CTRunGetAttributes(run);
</span><span class='line'>            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[runAttributes valueForKey:(id)kCTRunDelegateAttributeName];
</span><span class='line'>            if (delegate == nil) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            NSDictionary * metaDic = CTRunDelegateGetRefCon(delegate);
</span><span class='line'>            if (![metaDic isKindOfClass:[NSDictionary class]]) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            CGRect runBounds;
</span><span class='line'>            CGFloat ascent;
</span><span class='line'>            CGFloat descent;
</span><span class='line'>            runBounds.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &ascent, &descent, NULL);
</span><span class='line'>            runBounds.size.height = ascent + descent;
</span><span class='line'>
</span><span class='line'>            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);
</span><span class='line'>            runBounds.origin.x = lineOrigins[i].x + xOffset;
</span><span class='line'>            runBounds.origin.y = lineOrigins[i].y;
</span><span class='line'>            runBounds.origin.y -= descent;
</span><span class='line'>
</span><span class='line'>            CGPathRef pathRef = CTFrameGetPath(self.ctFrame);
</span><span class='line'>            CGRect colRect = CGPathGetBoundingBox(pathRef);
</span><span class='line'>
</span><span class='line'>            CGRect delegateBounds = CGRectOffset(runBounds, colRect.origin.x, colRect.origin.y);
</span><span class='line'>
</span><span class='line'>            imageData.imagePosition = delegateBounds;
</span><span class='line'>            imgIndex++;
</span><span class='line'>            if (imgIndex == self.imageArray.count) {
</span><span class='line'>                imageData = nil;
</span><span class='line'>                break;
</span><span class='line'>            } else {
</span><span class='line'>                imageData = self.imageArray[imgIndex];
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>添加对图片的点击支持</h2>

<h3>实现方式</h3>

<p>为了实现对图片的点击支持，我们需要给<code>CTDisplayView</code>类增加用户点击操作的检测函数，在检测函数中，判断当前用户点击的区域是否在图片上，如果在图片上，则触发点击图片的逻辑。苹果提供的<code>UITapGestureRecognizer</code>可以很好的满足我们的要求，所以我们这里用它来检测用户的点击操作。</p>

<p>我们这里实现的是点击图片后，先用<code>NSLog</code>打印出一行日志。实际应用中，读者可以根据业务需求自行调整点击后的效果。</p>

<p>我们先为<code>CTDisplayView</code>类增加<code>UITapGestureRecognizer</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)initWithCoder:(NSCoder *)aDecoder {
</span><span class='line'>    self = [super initWithCoder:aDecoder];
</span><span class='line'>    if (self) {
</span><span class='line'>        [self setupEvents];
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setupEvents {
</span><span class='line'>    UIGestureRecognizer * tapRecognizer =
</span><span class='line'>          [[UITapGestureRecognizer alloc] initWithTarget:self
</span><span class='line'>                    action:@selector(userTapGestureDetected:)];
</span><span class='line'>    tapRecognizer.delegate = self;
</span><span class='line'>    [self addGestureRecognizer:tapRecognizer];
</span><span class='line'>    self.userInteractionEnabled = YES;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>然后增加<code>UITapGestureRecognizer</code>的回调函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)userTapGestureDetected:(UIGestureRecognizer *)recognizer {
</span><span class='line'>    CGPoint point = [recognizer locationInView:self];
</span><span class='line'>    for (CoreTextImageData * imageData in self.data.imageArray) {
</span><span class='line'>        // 翻转坐标系，因为 imageData 中的坐标是 CoreText 的坐标系
</span><span class='line'>        CGRect imageRect = imageData.imagePosition;
</span><span class='line'>        CGPoint imagePosition = imageRect.origin;
</span><span class='line'>        imagePosition.y = self.bounds.size.height - imageRect.origin.y
</span><span class='line'>                          - imageRect.size.height;
</span><span class='line'>        CGRect rect = CGRectMake(imagePosition.x, imagePosition.y, imageRect.size.width, imageRect.size.height);
</span><span class='line'>        // 检测点击位置 Point 是否在 rect 之内
</span><span class='line'>        if (CGRectContainsPoint(rect, point)) {
</span><span class='line'>            // 在这里处理点击后的逻辑
</span><span class='line'>            NSLog(@"bingo");
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>事件处理</h3>

<p>在界面上，<code>CTDisplayView</code>通常在<code>UIView</code>的树形层级结构中，一个 UIView 可能是最外层 View Controller 的 View 的孩子的孩子的孩子（如下图所示）。在这种多级层次结构中，很难通过<code>delegate</code>模式将图片点击的事件一层一层往外层传递，所以最好使用<code>NSNotification</code>，来处理图片点击事件。</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-uiview-tree.png" alt="" /></p>

<p>在 Demo 中，我们在最外层的 View Controller 中监听图片点击的通知，当收到通知后，进入到一个新的界面来显示图片点击内容。</p>

<p>注：读者可以将 demo 工程切换到<code>image_click</code>分支，查看示例代码。</p>

<h3>添加对链接的点击支持</h3>

<h4>修改模板文件</h4>

<p>我们修改模版文件，增加一个名为 link 的类型，用于表示链接内容。如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[
</span><span class='line'>  { "color" : "default",
</span><span class='line'>    "content" : " 这在这里尝试放一个参考链接：",
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "blue",
</span><span class='line'>    "content" : " 链接文字 ",
</span><span class='line'>    "url" : "http://blog.devtang.com",
</span><span class='line'>    "type" : "link"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "default",
</span><span class='line'>    "content" : " 大家可以尝试点击一下 ",
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  }
</span><span class='line'>]
</span></code></pre></td></tr></table></div></figure>


<h4>解析模版中的链接信息</h4>

<p>我们首先增加一个<code>CoreTextLinkData</code>类，用于记录解析 JSON 文件时的链接信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface CoreTextLinkData : NSObject
</span><span class='line'>
</span><span class='line'>@property (strong, nonatomic) NSString * title;
</span><span class='line'>@property (strong, nonatomic) NSString * url;
</span><span class='line'>@property (assign, nonatomic) NSRange range;
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>然后我们修改 CTFrameParser 类，增加解析链接的逻辑：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSAttributedString *)loadTemplateFile:(NSString *)path
</span><span class='line'>                                  config:(CTFrameParserConfig*)config
</span><span class='line'>                              imageArray:(NSMutableArray *)imageArray
</span><span class='line'>                               linkArray:(NSMutableArray *)linkArray {
</span><span class='line'>    NSData *data = [NSData dataWithContentsOfFile:path];
</span><span class='line'>    NSMutableAttributedString *result = [[NSMutableAttributedString alloc] init];
</span><span class='line'>    if (data) {
</span><span class='line'>        NSArray *array = [NSJSONSerialization JSONObjectWithData:data
</span><span class='line'>                                        options:NSJSONReadingAllowFragments
</span><span class='line'>                                          error:nil];
</span><span class='line'>        if ([array isKindOfClass:[NSArray class]]) {
</span><span class='line'>            for (NSDictionary *dict in array) {
</span><span class='line'>                NSString *type = dict[@"type"];
</span><span class='line'>                if ([type isEqualToString:@"txt"]) {
</span><span class='line'>                    // 省略
</span><span class='line'>                } else if ([type isEqualToString:@"img"]) {
</span><span class='line'>                    // 省略
</span><span class='line'>                } else if ([type isEqualToString:@"link"]) {
</span><span class='line'>                    NSUInteger startPos = result.length;
</span><span class='line'>                    NSAttributedString *as =
</span><span class='line'>                       [self parseAttributedContentFromNSDictionary:dict
</span><span class='line'>                                                             config:config];
</span><span class='line'>                    [result appendAttributedString:as];
</span><span class='line'>                    // 创建 CoreTextLinkData
</span><span class='line'>                    NSUInteger length = result.length - startPos;
</span><span class='line'>                    NSRange linkRange = NSMakeRange(startPos, length);
</span><span class='line'>                    CoreTextLinkData *linkData = [[CoreTextLinkData alloc] init];
</span><span class='line'>                    linkData.title = dict[@"content"];
</span><span class='line'>                    linkData.url = dict[@"url"];
</span><span class='line'>                    linkData.range = linkRange;
</span><span class='line'>                    [linkArray addObject:linkData];
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return result;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>然后，我们增加一个 Utils 类来专门处理检测用户点击是否在链接上。主要的方法是使用 CTLineGetStringIndexForPosition 函数来获得用户点击的位置与 NSAttributedString 字符串上的位置的对应关系。这样就知道是点击的哪个字符了。然后判断该字符串是否在链接上即可。该 Util 在实现逻辑如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 检测点击位置是否在链接上
</span><span class='line'>+ (CoreTextLinkData *)touchLinkInView:(UIView *)view atPoint:(CGPoint)point data:(CoreTextData *)data {
</span><span class='line'>    CTFrameRef textFrame = data.ctFrame;
</span><span class='line'>    CFArrayRef lines = CTFrameGetLines(textFrame);
</span><span class='line'>    if (!lines) return nil;
</span><span class='line'>    CFIndex count = CFArrayGetCount(lines);
</span><span class='line'>    CoreTextLinkData *foundLink = nil;
</span><span class='line'>
</span><span class='line'>    // 获得每一行的 origin 坐标
</span><span class='line'>    CGPoint origins[count];
</span><span class='line'>    CTFrameGetLineOrigins(textFrame, CFRangeMake(0,0), origins);
</span><span class='line'>
</span><span class='line'>    // 翻转坐标系
</span><span class='line'>    CGAffineTransform transform =  CGAffineTransformMakeTranslation(0, view.bounds.size.height);
</span><span class='line'>    transform = CGAffineTransformScale(transform, 1.f, -1.f);
</span><span class='line'>
</span><span class='line'>    for (int i = 0; i &lt; count; i++) {
</span><span class='line'>        CGPoint linePoint = origins[i];
</span><span class='line'>        CTLineRef line = CFArrayGetValueAtIndex(lines, i);
</span><span class='line'>        // 获得每一行的 CGRect 信息
</span><span class='line'>        CGRect flippedRect = [self getLineBounds:line point:linePoint];
</span><span class='line'>        CGRect rect = CGRectApplyAffineTransform(flippedRect, transform);
</span><span class='line'>
</span><span class='line'>        if (CGRectContainsPoint(rect, point)) {
</span><span class='line'>            // 将点击的坐标转换成相对于当前行的坐标
</span><span class='line'>            CGPoint relativePoint = CGPointMake(point.x-CGRectGetMinX(rect),
</span><span class='line'>                                                point.y-CGRectGetMinY(rect));
</span><span class='line'>            // 获得当前点击坐标对应的字符串偏移
</span><span class='line'>            CFIndex idx = CTLineGetStringIndexForPosition(line, relativePoint);
</span><span class='line'>            // 判断这个偏移是否在我们的链接列表中
</span><span class='line'>            foundLink = [self linkAtIndex:idx linkArray:data.linkArray];
</span><span class='line'>            return foundLink;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (CGRect)getLineBounds:(CTLineRef)line point:(CGPoint)point {
</span><span class='line'>    CGFloat ascent = 0.0f;
</span><span class='line'>    CGFloat descent = 0.0f;
</span><span class='line'>    CGFloat leading = 0.0f;
</span><span class='line'>    CGFloat width = (CGFloat)CTLineGetTypographicBounds(line, &ascent, &descent, &leading);
</span><span class='line'>    CGFloat height = ascent + descent;
</span><span class='line'>    return CGRectMake(point.x, point.y - descent, width, height);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (CoreTextLinkData *)linkAtIndex:(CFIndex)i linkArray:(NSArray *)linkArray {
</span><span class='line'>    CoreTextLinkData *link = nil;
</span><span class='line'>    for (CoreTextLinkData *data in linkArray) {
</span><span class='line'>        if (NSLocationInRange(i, data.range)) {
</span><span class='line'>            link = data;
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return link;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>最后改造一下<code>CTDisplayView</code>，使其在检测到用户点击后，调用上面的 Util 方法即可。我们这里实现的是点击链接后，先用<code>NSLog</code>打印出一行日志。实际应用中，读者可以根据业务需求自行调整点击后的效果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)userTapGestureDetected:(UIGestureRecognizer *)recognizer {
</span><span class='line'>    CGPoint point = [recognizer locationInView:self];
</span><span class='line'>    // 此处省略上一节中介绍的，对图片点击检测的逻辑
</span><span class='line'>
</span><span class='line'>    CoreTextLinkData *linkData = [CoreTextUtils touchLinkInView:self atPoint:point data:self.data];
</span><span class='line'>    if (linkData) {
</span><span class='line'>        NSLog(@"hint link!");
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注：在 Demo 中工程中，我们实现了点击链接跳转到一个新的界面，然后用 UIWebView 来显示链接内容的逻辑。读者可以将 demo 工程切换到<code>link_click</code>分支，查看示例代码。</p>

<p>Demo 工程的 Gif 效果图如下，读者可以将示例工程用<code>git checkout image_support</code>切换到当前章节状态，查看相关代码逻辑。</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-demo.gif" alt="" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/27/using-coretext-1/">基于 CoreText 的排版引擎：基础</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-06-27T08:39:56+08:00" pubdate data-updated="true">Jun 27<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>版权说明</h2>

<p>原创文章，转载请保留以下信息：</p>

<ul>
<li>本文节选自我的图书：《<a href="http://item.jd.com/11598468.html" target="_blank">iOS 开发进阶 </a>》。</li>
<li>本文涉及的 Demo 工程在这里：<a href="https://github.com/tangqiaoboy/iOS-Pro">https://github.com/tangqiaoboy/iOS-Pro</a>。</li>
<li>扫码关注我的「iOS 开发」微信公众帐号：</li>
</ul>


<p> <img src="http://blog.devtang.com/images/weixin-qr.jpg" alt="二维码" /></p>

<h2>本章前言</h2>

<p>使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片，链接的点击效果。CoreText 技术相对于 UIWebView，有着更少的内存占用，以及可以在后台渲染的优点，非常适合用于内容的排版工作。</p>

<p>本章我们将从最基本的开始，一步一步完成一个支持图文混排、支持图片和链接点击的排版引擎。</p>

<h2>CoreText 简介</h2>

<p>CoreText 是用于处理文字和字体的底层技术。它直接和 Core Graphics（又被称为 Quartz）打交道。Quartz 是一个 2D 图形渲染引擎，能够处理 OSX 和 iOS 中的图形显示。</p>

<p>Quartz 能够直接处理字体（font）和字形（glyphs），将文字渲染到界面上，它是基础库中唯一能够处理字形的模块。因此，CoreText 为了排版，需要将显示的文本内容、位置、字体、字形直接传递给 Quartz。相比其它 UI 组件，由于 CoreText 直接和 Quartz 来交互，所以它具有高速的排版效果。</p>

<p>下图是 CoreText 的架构图，可以看到，CoreText 处于非常底层的位置，上层的 UI 控件（包括 UILabel，UITextField 以及 UITextView）和 UIWebView 都是基于 CoreText 来实现的。</p>

<blockquote><p>注意：这个是 iOS7 之后的架构图，在 iOS7 以前，并没有图中的 Text Kit 类，不过 CoreText 仍然是处在最底层直接和 Core Graphics 打交道的模块。</p></blockquote>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext_arch.png" alt="CoreText 的架构图" /></p>

<p>UIWebView 也是处理复杂的文字排版的备选方案。对于排版，基于 CoreText 和基于 UIWebView 相比，前者有以下好处：</p>

<ul>
<li>CoreText 占用的内存更少，渲染速度快，UIWebView 占用的内存更多，渲染速度慢。</li>
<li>CoreText 在渲染界面前就可以精确地获得显示内容的高度（只要有了 CTFrame 即可），而 UIWebView 只有渲染出内容后，才能获得内容的高度（而且还需要用 javascript 代码来获取）</li>
<li>CoreText 的 CTFrame 可以在后台线程渲染，UIWebView 的内容只能在主线程（UI 线程）渲染。</li>
<li>基于 CoreText 可以做更好的原生交互效果，交互效果可以更细腻。而 UIWebView 的交互效果都是用 javascript 来实现的，在交互效果上会有一些卡顿存在。例如，在 UIWebView 下，一个简单的按钮按下效果，都无法做到原生按钮的即时和细腻的按下效果。</li>
</ul>


<p>当然，基于 CoreText 的排版方案也有一些劣势：</p>

<ul>
<li>CoreText 渲染出来的内容不能像 UIWebView 那样方便地支持内容的复制。</li>
<li>基于 CoreText 来排版需要自己处理很多复杂逻辑，例如需要自己处理图片与文字混排相关的逻辑，也需要自己实现链接点击操作的支持。</li>
</ul>


<p>在业界，很多应用都采用了基于 CoreText 技术的排版方案，例如：新浪微博客户端，多看阅读客户端。我所在的创业公司的猿题库，也使用了自己基于 CoreText 技术实现的排版引擎，下图是我们产品的一个图文混排的界面（其中所有公式都是用图片的方式呈现的），可以看到，图片和文字排版效果很好。</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-1.png" alt="猿题库的采用 CoreText 渲染的界面" /></p>

<h2>基于 CoreText 的基础排版引擎</h2>

<h3>不带图片的排版引擎</h3>

<p>下面我们来尝试完成一个基于 CoreText 的排版引擎。我们将从最简单的排版功能开始，然后逐步支持图文混排，链接点击等功能。</p>

<p>首先我们来尝试完成一个不支持图片内容的纯文字排版引擎。</p>

<p>注意 1：由于整个排版引擎的代码太多，为方便读者阅读，文章中只会列出最关键的核心代码，完整的代码请参考本书对应的 github 项目，项目地址是：<a href="https://github.com/tangqiaoboy/iOS-Pro">https://github.com/tangqiaoboy/iOS-Pro</a> 。</p>

<h2>能输出 Hello World 的 CoreText 工程</h2>

<h3>操作步骤</h3>

<p>我们首先新建一个 Xcode 工程，步骤如下：</p>

<ol>
<li>打开 Xcode，选择 &ldquo;File&rdquo;&ndash;>&ldquo;New&rdquo;&ndash;>&ldquo;Project&rdquo;, 在弹出的对话框中，选择 “Single View Application”，然后点击 &ldquo;Next&#8221;。（图 2）</li>
<li>接着填上项目名 CoreTextDemo，然后点击 “Next”。（图 3）</li>
<li>选择保存目录后，我们就成功创建了一个空的工程。</li>
</ol>


<p> 图 2
 <img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-2.png" alt="图 2" /></p>

<p> 图 3
 <img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-3.png" alt="图 3" /></p>

<p>在工程目录 “CoreTextDemo” 上右击，选择 “New File”, 然后填入类名<code>CTDisplayView</code>, 并且让它的父类是 UIView。（如下图）</p>

<p> <img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-create-ctdisplayview.png" alt="" /></p>

<p>接着，我们在<code>CTDisplayView.m</code>文件中，让其 import 头文件<code>CoreText/CoreText.h</code>，接着输入以下代码来实现其<code>drawRect</code>方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "CTDisplayView.h"
</span><span class='line'>#import "CoreText/CoreText.h"
</span><span class='line'>
</span><span class='line'>@implementation CTDisplayView
</span><span class='line'>
</span><span class='line'>- (void)drawRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    [super drawRect:rect];
</span><span class='line'>
</span><span class='line'>    // 步骤 1
</span><span class='line'>    CGContextRef context = UIGraphicsGetCurrentContext();
</span><span class='line'>
</span><span class='line'>    // 步骤 2
</span><span class='line'>    CGContextSetTextMatrix(context, CGAffineTransformIdentity);
</span><span class='line'>    CGContextTranslateCTM(context, 0, self.bounds.size.height);
</span><span class='line'>    CGContextScaleCTM(context, 1.0, -1.0);
</span><span class='line'>
</span><span class='line'>    // 步骤 3
</span><span class='line'>    CGMutablePathRef path = CGPathCreateMutable();
</span><span class='line'>    CGPathAddRect(path, NULL, self.bounds);
</span><span class='line'>
</span><span class='line'>    // 步骤 4
</span><span class='line'>    NSAttributedString *attString = [[NSAttributedString alloc] initWithString:@"Hello World!"];
</span><span class='line'>    CTFramesetterRef framesetter =
</span><span class='line'>    CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attString);
</span><span class='line'>    CTFrameRef frame =
</span><span class='line'>    CTFramesetterCreateFrame(framesetter,
</span><span class='line'>                             CFRangeMake(0, [attString length]), path, NULL);
</span><span class='line'>
</span><span class='line'>    // 步骤 5
</span><span class='line'>    CTFrameDraw(frame, context);
</span><span class='line'>
</span><span class='line'>    // 步骤 6
</span><span class='line'>    CFRelease(frame);
</span><span class='line'>    CFRelease(path);
</span><span class='line'>    CFRelease(framesetter);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>打开程序的 Storyboard 文件：<code>Main_iPhone.storyboard</code>：执行下面 2 步：</p>

<ol>
<li>将一个 UIView 控件拖动到主界面正中间。（如下图步骤 1）</li>
<li>将该 UIView 控件的类名从<code>UIView</code>修改为<code>CTDisplayView</code>。（如下图步骤 2）</li>
</ol>


<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-4.png" alt="图 4" /></p>

<p>之后，我们运行程序，就可以看到，Hello World 出现在程序正中间了。如下图。</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-5.png" alt="图 5" /></p>

<h3>代码解释</h3>

<p>下面解释一下<code>drawRect</code>方法主要的步骤：</p>

<ol>
<li>得到当前绘制画布的上下文，用于后续将内容绘制在画布上。</li>
<li><p>将坐标系上下翻转。对于底层的绘制引擎来说，屏幕的左下角是（0, 0）坐标。而对于上层的 UIKit 来说，左上角是 (0, 0) 坐标。所以我们为了之后的坐标系描述按 UIKit 来做，所以先在这里做一个坐标系的上下翻转操作。翻转之后，底层和上层的 (0, 0) 坐标就是重合的了。</p>

<p>为了加深理解，我们将这部分的代码块注释掉，你会发现，整个<code>Hello World</code>界面将上下翻转，如下图所示。</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-flip.png" alt="图：上下翻转的界面" /></p></li>
<li><p>创建绘制的区域，CoreText 本身支持各种文字排版的区域，我们这里简单地将 UIView 的整个界面作为排版的区域。</p></li>
</ol>


<p>为了加深理解，我们将该步骤的代码替换成如下代码，测试设置不同的绘制区域带来的界面变化。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 步骤 3
</span><span class='line'>CGMutablePathRef path = CGPathCreateMutable();
</span><span class='line'>CGPathAddEllipseInRect(path, NULL, self.bounds);
</span><span class='line'>
</span><span class='line'>// 步骤 4
</span><span class='line'>NSAttributedString *attString = [[NSAttributedString alloc] initWithString:@"Hello World! "
</span><span class='line'>                                 " 创建绘制的区域，CoreText 本身支持各种文字排版的区域，"
</span><span class='line'>                                 " 我们这里简单地将 UIView 的整个界面作为排版的区域。"
</span><span class='line'>                                 " 为了加深理解，建议读者将该步骤的代码替换成如下代码，"
</span><span class='line'>                                 " 测试设置不同的绘制区域带来的界面变化。"];
</span></code></pre></td></tr></table></div></figure>


<p>执行结果如下图所示：</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-shape.png" alt="图：椭圆形的排版区域" /></p>

<h4>代码基本的宏定义和 Category</h4>

<p>为了方便我们的代码编写，我在<code>CoreTextDemo-Prefix.pch</code>文件中增加了以下基本的宏定义，以方便我们使用 NSLog 和 UIColor。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#ifdef DEBUG
</span><span class='line'>#define debugLog(...) NSLog(__VA_ARGS__)
</span><span class='line'>#define debugMethod() NSLog(@"%s", __func__)
</span><span class='line'>#else
</span><span class='line'>#define debugLog(...)
</span><span class='line'>#define debugMethod()
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>#define RGB(A, B, C)    [UIColor colorWithRed:A/255.0 green:B/255.0 blue:C/255.0 alpha:1.0]
</span></code></pre></td></tr></table></div></figure>


<p>我也为 UIView 的 frame 调整增加了一些扩展，可以方便地调整 UIView 的 x, y, width, height 等值。部分关键代码如下（完整的代码请查看示例工程）：</p>

<p>UIView+frameAdjust.h 文件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt;
</span><span class='line'>
</span><span class='line'>@interface UIView (frameAdjust)
</span><span class='line'>
</span><span class='line'>- (CGFloat)x;
</span><span class='line'>- (void)setX:(CGFloat)x;
</span><span class='line'>
</span><span class='line'>- (CGFloat)y;
</span><span class='line'>- (void)setY:(CGFloat)y;
</span><span class='line'>
</span><span class='line'>- (CGFloat)height;
</span><span class='line'>- (void)setHeight:(CGFloat)height;
</span><span class='line'>
</span><span class='line'>- (CGFloat)width;
</span><span class='line'>- (void)setWidth:(CGFloat)width;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>UIView+frameAdjust.m 文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation UIView (frameAdjust)
</span><span class='line'>- (CGFloat)x {
</span><span class='line'>    return self.frame.origin.x;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setX:(CGFloat)x {
</span><span class='line'>    self.frame = CGRectMake(x, self.y, self.width, self.height);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (CGFloat)y {
</span><span class='line'>    return self.frame.origin.y;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setY:(CGFloat)y {
</span><span class='line'>    self.frame = CGRectMake(self.x, y, self.width, self.height);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (CGFloat)height {
</span><span class='line'>    return self.frame.size.height;
</span><span class='line'>}
</span><span class='line'>- (void)setHeight:(CGFloat)height {
</span><span class='line'>    self.frame = CGRectMake(self.x, self.y, self.width, height);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (CGFloat)width {
</span><span class='line'>    return self.frame.size.width;
</span><span class='line'>}
</span><span class='line'>- (void)setWidth:(CGFloat)width {
</span><span class='line'>    self.frame = CGRectMake(self.x, self.y, width, self.height);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>文章中的其余代码默认都#import 了以上提到的宏定义和 UIView Category。</p>

<h2>排版引擎框架</h2>

<p>上面的 Hello World 工程仅仅展示了 Core Text 排版的基本能力。但是要制作一个较完善的排版引擎，我们不能简单的将所有代码都放到 <code>CTDisplayView</code> 的<code>drawRect</code>方法里面。根据设计模式中的 &ldquo; 单一功能原则 &rdquo;(<code>Single responsibility principle</code>)，我们应该把功能拆分，把不同的功能都放到各自不同的类里面。</p>

<p>对于一个复杂的排版引擎来说，可以将其功能拆成以下几个类来完成：</p>

<ol>
<li>一个显示用的类，仅负责显示内容，不负责排版</li>
<li>一个模型类，用于承载显示所需要的所有数据</li>
<li>一个排版类，用于实现文字内容的排版</li>
<li>一个配置类，用于实现一些排版时的可配置项</li>
</ol>


<p>注：&#8221; 单一功能原则 &ldquo;(<code>Single responsibility principle</code>)
参考链接：<a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99">http://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99</a></p>

<p>按照以上原则，我们将<code>CTDisplayView</code>中的部分内容拆开，由 4 个类构成：</p>

<ol>
<li><code>CTFrameParserConfig</code>类，用于配置绘制的参数，例如：文字颜色，大小，行间距等。</li>
<li><code>CTFrameParser</code>类，用于生成最后绘制界面需要的<code>CTFrameRef</code>实例。</li>
<li><code>CoreTextData</code>类，用于保存由<code>CTFrameParser</code>类生成的<code>CTFrameRef</code>实例以及<code>CTFrameRef</code>实际绘制需要的高度。</li>
<li><code>CTDisplayView</code>类，持有<code>CoreTextData</code>类的实例，负责将<code>CTFrameRef</code>绘制到界面上。</li>
</ol>


<p>关于这 4 个类的关键代码如下：</p>

<p><code>CTFrameParserConfig</code>类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt;
</span><span class='line'>@interface CTFrameParserConfig : NSObject
</span><span class='line'>
</span><span class='line'>@property (nonatomic, assign) CGFloat width;
</span><span class='line'>@property (nonatomic, assign) CGFloat fontSize;
</span><span class='line'>@property (nonatomic, assign) CGFloat lineSpace;
</span><span class='line'>@property (nonatomic, strong) UIColor *textColor;
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#import "CTFrameParserConfig.h"
</span><span class='line'>
</span><span class='line'>@implementation CTFrameParserConfig
</span><span class='line'>
</span><span class='line'>- (id)init {
</span><span class='line'>    self = [super init];
</span><span class='line'>    if (self) {
</span><span class='line'>        _width = 200.0f;
</span><span class='line'>        _fontSize = 16.0f;
</span><span class='line'>        _lineSpace = 8.0f;
</span><span class='line'>        _textColor = RGB(108, 108, 108);
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p><code>CTFrameParser</code>类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt;
</span><span class='line'>#import "CoreTextData.h"
</span><span class='line'>#import "CTFrameParserConfig.h"
</span><span class='line'>
</span><span class='line'>@interface CTFrameParser : NSObject
</span><span class='line'>
</span><span class='line'>+ (CoreTextData *)parseContent:(NSString *)content config:(CTFrameParserConfig*)config;
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#import "CTFrameParser.h"
</span><span class='line'>#import "CTFrameParserConfig.h"
</span><span class='line'>
</span><span class='line'>@implementation CTFrameParser
</span><span class='line'>
</span><span class='line'>+ (NSDictionary *)attributesWithConfig:(CTFrameParserConfig *)config {
</span><span class='line'>    CGFloat fontSize = config.fontSize;
</span><span class='line'>    CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@"ArialMT", fontSize, NULL);
</span><span class='line'>    CGFloat lineSpacing = config.lineSpace;
</span><span class='line'>    const CFIndex kNumberOfSettings = 3;
</span><span class='line'>    CTParagraphStyleSetting theSettings[kNumberOfSettings] = {
</span><span class='line'>        { kCTParagraphStyleSpecifierLineSpacingAdjustment, sizeof(CGFloat), &lineSpacing },
</span><span class='line'>        { kCTParagraphStyleSpecifierMaximumLineSpacing, sizeof(CGFloat), &lineSpacing },
</span><span class='line'>        { kCTParagraphStyleSpecifierMinimumLineSpacing, sizeof(CGFloat), &lineSpacing }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, kNumberOfSettings);
</span><span class='line'>
</span><span class='line'>    UIColor * textColor = config.textColor;
</span><span class='line'>
</span><span class='line'>    NSMutableDictionary * dict = [NSMutableDictionary dictionary];
</span><span class='line'>    dict[(id)kCTForegroundColorAttributeName] = (id)textColor.CGColor;
</span><span class='line'>    dict[(id)kCTFontAttributeName] = (__bridge id)fontRef;
</span><span class='line'>    dict[(id)kCTParagraphStyleAttributeName] = (__bridge id)theParagraphRef;
</span><span class='line'>
</span><span class='line'>    CFRelease(theParagraphRef);
</span><span class='line'>    CFRelease(fontRef);
</span><span class='line'>    return dict;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (CoreTextData *)parseContent:(NSString *)content config:(CTFrameParserConfig*)config {
</span><span class='line'>    NSDictionary *attributes = [self attributesWithConfig:config];
</span><span class='line'>    NSAttributedString *contentString =
</span><span class='line'>        [[NSAttributedString alloc] initWithString:content
</span><span class='line'>                                        attributes:attributes];
</span><span class='line'>
</span><span class='line'>    // 创建 CTFramesetterRef 实例
</span><span class='line'>    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)contentString);
</span><span class='line'>
</span><span class='line'>    // 获得要绘制的区域的高度
</span><span class='line'>    CGSize restrictSize = CGSizeMake(config.width, CGFLOAT_MAX);
</span><span class='line'>    CGSize coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0,0), nil, restrictSize, nil);
</span><span class='line'>    CGFloat textHeight = coreTextSize.height;
</span><span class='line'>
</span><span class='line'>    // 生成 CTFrameRef 实例
</span><span class='line'>    CTFrameRef frame = [self createFrameWithFramesetter:framesetter config:config height:textHeight];
</span><span class='line'>
</span><span class='line'>    // 将生成好的 CTFrameRef 实例和计算好的绘制高度保存到 CoreTextData 实例中，最后返回 CoreTextData 实例
</span><span class='line'>    CoreTextData *data = [[CoreTextData alloc] init];
</span><span class='line'>    data.ctFrame = frame;
</span><span class='line'>    data.height = textHeight;
</span><span class='line'>
</span><span class='line'>    // 释放内存
</span><span class='line'>    CFRelease(frame);
</span><span class='line'>    CFRelease(framesetter);
</span><span class='line'>    return data;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter
</span><span class='line'>                                  config:(CTFrameParserConfig *)config
</span><span class='line'>                                  height:(CGFloat)height {
</span><span class='line'>
</span><span class='line'>    CGMutablePathRef path = CGPathCreateMutable();
</span><span class='line'>    CGPathAddRect(path, NULL, CGRectMake(0, 0, config.width, height));
</span><span class='line'>
</span><span class='line'>    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, NULL);
</span><span class='line'>    CFRelease(path);
</span><span class='line'>    return frame;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p><code>CoreTextData</code>类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt;
</span><span class='line'>
</span><span class='line'>@interface CoreTextData : NSObject
</span><span class='line'>
</span><span class='line'>@property (assign, nonatomic) CTFrameRef ctFrame;
</span><span class='line'>@property (assign, nonatomic) CGFloat height;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "CoreTextData.h"
</span><span class='line'>
</span><span class='line'>@implementation CoreTextData
</span><span class='line'>
</span><span class='line'>- (void)setCtFrame:(CTFrameRef)ctFrame {
</span><span class='line'>    if (_ctFrame != ctFrame) {
</span><span class='line'>        if (_ctFrame != nil) {
</span><span class='line'>            CFRelease(_ctFrame);
</span><span class='line'>        }
</span><span class='line'>        CFRetain(ctFrame);
</span><span class='line'>        _ctFrame = ctFrame;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)dealloc {
</span><span class='line'>    if (_ctFrame != nil) {
</span><span class='line'>        CFRelease(_ctFrame);
</span><span class='line'>        _ctFrame = nil;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p><code>CTDisplayView</code>类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt;
</span><span class='line'>#import "CoreTextData.h"
</span><span class='line'>
</span><span class='line'>@interface CTDisplayView : UIView
</span><span class='line'>
</span><span class='line'>@property (strong, nonatomic) CoreTextData * data;
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "CTDisplayView.h"
</span><span class='line'>
</span><span class='line'>@implementation CTDisplayView
</span><span class='line'>
</span><span class='line'>- (void)drawRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    [super drawRect:rect];
</span><span class='line'>    CGContextRef context = UIGraphicsGetCurrentContext();
</span><span class='line'>    CGContextSetTextMatrix(context, CGAffineTransformIdentity);
</span><span class='line'>    CGContextTranslateCTM(context, 0, self.bounds.size.height);
</span><span class='line'>    CGContextScaleCTM(context, 1.0, -1.0);
</span><span class='line'>
</span><span class='line'>    if (self.data) {
</span><span class='line'>        CTFrameDraw(self.data.ctFrame, context);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>以上 4 个类中的逻辑与之前 Hello World 那个项目的逻辑基本一致，只是分拆到了 4 个类中完成。另外，CTFrameParser 增加了方法来获得要绘制的区域的高度，并将高度信息保存到<code>CoreTextData</code>类的实例中。之所以要获得绘制区域的高度，是因为在很多实际使用场景中，我们需要先知道所要显示内容的高度，之后才可以进行绘制。</p>

<p>例如，在 UITableView 在渲染时，UITableView 首先会向 delegate 回调如下方法来获得每个将要渲染的 cell 的高度：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;</span></code></pre></td></tr></table></div></figure>


<p>之后，UITableView 会计算当前滚动的位置具体需要绘制的 UITableViewCell 是哪些，然后对于那些需要绘制的 Cell，UITableView 才会继续向其 data source 回调如下方法来获得 UITableViewCell 实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;</span></code></pre></td></tr></table></div></figure>


<p>对于上面的情况，如果我们使用 CoreText 来作为 TableViewCell 的内容，那么就必须在每个 Cell 绘制之前，就知道其需要的绘制高度，否则 UITableView 将无法正常工作。</p>

<p>完成以上 4 个类之后，我们就可以简单地在<code>ViewController.m</code>文件中，加入如下代码来配置<code>CTDisplayView</code>的显示内容，位置，高度，字体，颜色等信息。代码如下所示。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "ViewController.h"
</span><span class='line'>
</span><span class='line'>@interface ViewController ()
</span><span class='line'>
</span><span class='line'>@property (weak, nonatomic) IBOutlet CTDisplayView *ctView;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>
</span><span class='line'>    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];
</span><span class='line'>    config.textColor = [UIColor redColor];
</span><span class='line'>    config.width = self.ctView.width;
</span><span class='line'>
</span><span class='line'>    CoreTextData *data = [CTFrameParser parseContent:@" 按照以上原则，我们将`CTDisplayView`中的部分内容拆开。" config:config];
</span><span class='line'>    self.ctView.data = data;
</span><span class='line'>    self.ctView.height = data.height;
</span><span class='line'>    self.ctView.backgroundColor = [UIColor yellowColor];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>注意：从 Xcode4.0 开始，默认的界面编辑就开启了对于<code>Use Autolayout</code>的使用，但因为我们在代码中直接修改了变量<code>ctView</code>的 frame 信息，所以需要在<code>Main_iPhone.storyboard</code>中将<code>Use Autolayout</code>这一项取消勾选。如下图所示：</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-un-select-autolayout.png" alt="图：取消勾选 Autolayout" /></p>

<p>以下是本框架的 UML 示意图，从图中我们可以看出，这 4 个 Core Text 类的关系是这样的：</p>

<ol>
<li><code>CTFrameParser</code>通过<code>CTFrameparserConfig</code>实例来生成<code>CoreTextData</code>实例。</li>
<li><code>CTDisplayView</code>通过持有<code>CoreTextData</code>实例来获得绘制所需要的所有信息。</li>
<li><code>ViewController</code>类通过配置<code>CTFrameparserConfig</code>实例，进而获得生成的<code>CoreTextData</code>实例，最后将其赋值给他的<code>CTDisplayView</code>成员，达到将指定内容显示在界面上的效果。</li>
</ol>


<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-uml.png" alt="图：UML 示意图" /></p>

<p>说明 1：整个工程代码在名为<code>basic_arch</code>的分支下，读者可以在示例的源代码工程中使用<code>git checkout basic_arch</code>来切换到当前讲解的工程示例代码。</p>

<p>说明 2：为了方便操作<code>UIView</code>的<code>frame</code>属性，项目中增加了一个名为<code>UIView+frameAdjust.m</code>文件，它通过<code>Category</code>来给<code>UIView</code>增加了直接设置<code>height</code>属性的方法。</p>

<h2>定制排版文件格式</h2>

<p>对于上面的例子，我们给 CTFrameParser 使增加了一个将 NSString 转换为 CoreTextData 的方法。但这样的实现方式有很多局限性，因为整个内容虽然可以定制字体大小，颜色，行高等信息，但是却不能支持定制内容中的某一部分。例如，如果我们只想让内容的前三个字显示成红色，而其它文字显示成黑色，那么就办不到了。</p>

<p>解决的办法很简单，我们让<code>CTFrameParser</code>支持接受 NSAttributeString 作为参数，然后在<code>ViewController</code>类中设置我们想要的 NSAttributeString 信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>
</span><span class='line'>    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];
</span><span class='line'>    config.width = self.ctView.width;
</span><span class='line'>    config.textColor = [UIColor blackColor];
</span><span class='line'>
</span><span class='line'>    NSString *content =
</span><span class='line'>        @" 对于上面的例子，我们给 CTFrameParser 增加了一个将 NSString 转 "
</span><span class='line'>         " 换为 CoreTextData 的方法。"
</span><span class='line'>         " 但这样的实现方式有很多局限性，因为整个内容虽然可以定制字体 "
</span><span class='line'>         " 大小，颜色，行高等信息，但是却不能支持定制内容中的某一部分。"
</span><span class='line'>         " 例如，如果我们只想让内容的前三个字显示成红色，而其它文字显 "
</span><span class='line'>         " 示成黑色，那么就办不到了。"
</span><span class='line'>         "\n\n"
</span><span class='line'>         " 解决的办法很简单，我们让`CTFrameParser`支持接受 "
</span><span class='line'>         "NSAttributeString 作为参数，然后在 NSAttributeString 中设置好 "
</span><span class='line'>         " 我们想要的信息。";
</span><span class='line'>    NSDictionary *attr = [CTFrameParser attributesWithConfig:config];
</span><span class='line'>    NSMutableAttributedString *attributedString =
</span><span class='line'>         [[NSMutableAttributedString alloc] initWithString:content
</span><span class='line'>                                                attributes:attr];
</span><span class='line'>    [attributedString addAttribute:NSForegroundColorAttributeName
</span><span class='line'>                             value:[UIColor redColor]
</span><span class='line'>                             range:NSMakeRange(0, 7)];
</span><span class='line'>
</span><span class='line'>    CoreTextData *data = [CTFrameParser parseAttributedContent:attributedString
</span><span class='line'>                                                        config:config];
</span><span class='line'>    self.ctView.data = data;
</span><span class='line'>    self.ctView.height = data.height;
</span><span class='line'>    self.ctView.backgroundColor = [UIColor yellowColor];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>结果如下图所示，我们很方便就把前面 7 个字变成了红色。</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-attribute-string-as-argument.png" alt="" /></p>

<p>更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的内容、颜色、字体大小等信息。我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。</p>

<p>我们规定排版的模版文件为 JSON 格式。JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成。iOS 从 5.0 开始，提供了名为<code>NSJSONSerialization</code>的类库来方便开发者对 JSON 的解析。在 iOS5.0 之前，业界也有很多相关的 JSON 解析开源库，例如 JSONKit 可供大家使用。</p>

<p>我们的排版模版示例文件如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[ { "color" : "blue",
</span><span class='line'>    "content" : " 更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的 ",
</span><span class='line'>    "size" : 16,
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "red",
</span><span class='line'>    "content" : " 内容、颜色、字体 ",
</span><span class='line'>    "size" : 22,
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "black",
</span><span class='line'>    "content" : " 大小等信息。\n",
</span><span class='line'>    "size" : 16,
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  },
</span><span class='line'>  { "color" : "default",
</span><span class='line'>    "content" : " 我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。",
</span><span class='line'>    "type" : "txt"
</span><span class='line'>  }
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<p>通过苹果提供的<code>NSJSONSerialization</code>类，我们可以将上面的模版文件转换成 NSArray 数组，每一个数组元素是一个 NSDictionary，代表一段相同设置的文字。为了简单，我们的配置文件只支持配置颜色和字号，但是读者可以依据同样的思想，很方便地增加其它配置信息。</p>

<p>接下来我们要为<code>CTFrameParser</code>增加一个方法，让其可以从如上格式的模版文件中生成<code>CoreTextData</code>。最终我们的实现代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>// 方法一
</span><span class='line'>+ (CoreTextData *)parseTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config {
</span><span class='line'>    NSAttributedString *content = [self loadTemplateFile:path config:config];
</span><span class='line'>    return [self parseAttributedContent:content config:config];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 方法二
</span><span class='line'>+ (NSAttributedString *)loadTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config {
</span><span class='line'>    NSData *data = [NSData dataWithContentsOfFile:path];
</span><span class='line'>    NSMutableAttributedString *result = [[NSMutableAttributedString alloc] init];
</span><span class='line'>    if (data) {
</span><span class='line'>        NSArray *array = [NSJSONSerialization JSONObjectWithData:data
</span><span class='line'>                                           options:NSJSONReadingAllowFragments
</span><span class='line'>                                             error:nil];
</span><span class='line'>        if ([array isKindOfClass:[NSArray class]]) {
</span><span class='line'>            for (NSDictionary *dict in array) {
</span><span class='line'>                NSString *type = dict[@"type"];
</span><span class='line'>                if ([type isEqualToString:@"txt"]) {
</span><span class='line'>                    NSAttributedString *as =
</span><span class='line'>                       [self parseAttributedContentFromNSDictionary:dict
</span><span class='line'>                                                             config:config];
</span><span class='line'>                    [result appendAttributedString:as];
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return result;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 方法三
</span><span class='line'>+ (NSAttributedString *)parseAttributedContentFromNSDictionary:(NSDictionary *)dict
</span><span class='line'>                                                        config:(CTFrameParserConfig*)config {
</span><span class='line'>    NSMutableDictionary *attributes = [self attributesWithConfig:config];
</span><span class='line'>    // set color
</span><span class='line'>    UIColor *color = [self colorFromTemplate:dict[@"color"]];
</span><span class='line'>    if (color) {
</span><span class='line'>        attributes[(id)kCTForegroundColorAttributeName] = (id)color.CGColor;
</span><span class='line'>    }
</span><span class='line'>    // set font size
</span><span class='line'>    CGFloat fontSize = [dict[@"size"] floatValue];
</span><span class='line'>    if (fontSize &gt; 0) {
</span><span class='line'>        CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@"ArialMT", fontSize, NULL);
</span><span class='line'>        attributes[(id)kCTFontAttributeName] = (__bridge id)fontRef;
</span><span class='line'>        CFRelease(fontRef);
</span><span class='line'>    }
</span><span class='line'>    NSString *content = dict[@"content"];
</span><span class='line'>    return [[NSAttributedString alloc] initWithString:content attributes:attributes];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 方法四
</span><span class='line'>+ (UIColor *)colorFromTemplate:(NSString *)name {
</span><span class='line'>    if ([name isEqualToString:@"blue"]) {
</span><span class='line'>        return [UIColor blueColor];
</span><span class='line'>    } else if ([name isEqualToString:@"red"]) {
</span><span class='line'>        return [UIColor redColor];
</span><span class='line'>    } else if ([name isEqualToString:@"black"]) {
</span><span class='line'>        return [UIColor blackColor];
</span><span class='line'>    } else {
</span><span class='line'>        return nil;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 方法五
</span><span class='line'>+ (CoreTextData *)parseAttributedContent:(NSAttributedString *)content config:(CTFrameParserConfig*)config {
</span><span class='line'>    // 创建 CTFramesetterRef 实例
</span><span class='line'>    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)content);
</span><span class='line'>
</span><span class='line'>    // 获得要缓制的区域的高度
</span><span class='line'>    CGSize restrictSize = CGSizeMake(config.width, CGFLOAT_MAX);
</span><span class='line'>    CGSize coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0,0), nil, restrictSize, nil);
</span><span class='line'>    CGFloat textHeight = coreTextSize.height;
</span><span class='line'>
</span><span class='line'>    // 生成 CTFrameRef 实例
</span><span class='line'>    CTFrameRef frame = [self createFrameWithFramesetter:framesetter config:config height:textHeight];
</span><span class='line'>
</span><span class='line'>    // 将生成好的 CTFrameRef 实例和计算好的缓制高度保存到 CoreTextData 实例中，最后返回 CoreTextData 实例
</span><span class='line'>    CoreTextData *data = [[CoreTextData alloc] init];
</span><span class='line'>    data.ctFrame = frame;
</span><span class='line'>    data.height = textHeight;
</span><span class='line'>
</span><span class='line'>    // 释放内存
</span><span class='line'>    CFRelease(frame);
</span><span class='line'>    CFRelease(framesetter);
</span><span class='line'>    return data;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 方法六
</span><span class='line'>+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter
</span><span class='line'>                                  config:(CTFrameParserConfig *)config
</span><span class='line'>                                  height:(CGFloat)height {
</span><span class='line'>
</span><span class='line'>    CGMutablePathRef path = CGPathCreateMutable();
</span><span class='line'>    CGPathAddRect(path, NULL, CGRectMake(0, 0, config.width, height));
</span><span class='line'>
</span><span class='line'>    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, NULL);
</span><span class='line'>    CFRelease(path);
</span><span class='line'>    return frame;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>以上代码主要由 6 个子方法构成：</p>

<ul>
<li>方法一用于提供对外的接口，调用方法二实现从一个 JSON 的模版文件中读取内容，然后调用方法五生成<code>CoreTextData</code>。</li>
<li>方法二读取 JSON 文件内容，并且调用方法三获得从<code>NSDictionary</code>到<code>NSAttributedString</code>的转换结果。</li>
<li>方法三将<code>NSDictionary</code>内容转换为<code>NSAttributedString</code>。</li>
<li>方法四提供将<code>NSString</code>转为<code>UIColor</code>的功能。</li>
<li>方法五接受一个<code>NSAttributedString</code>和一个<code>config</code>参数，将<code>NSAttributedString</code>转换成<code>CoreTextData</code>返回。</li>
<li>方法六是方法五的一个辅助函数，供方法五调用。</li>
</ul>


<p>然后我们将<code>ViewController</code>中的调用代码作一下更改，使其从模版文件中加载内容，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>
</span><span class='line'>    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];
</span><span class='line'>    config.width = self.ctView.width;
</span><span class='line'>    NSString *path = [[NSBundle mainBundle] pathForResource:@"content" ofType:@"json"];
</span><span class='line'>    CoreTextData *data = [CTFrameParser parseTemplateFile:path config:config];
</span><span class='line'>    self.ctView.data = data;
</span><span class='line'>    self.ctView.height = data.height;
</span><span class='line'>    self.ctView.backgroundColor = [UIColor whiteColor];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>最后运行得到的结果如下所示，可以看到，通过一个简单的模板文件，我们已经可以很方便地定义排版的配置信息了。</p>

<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-load-from-json-template.png" alt="" /></p>

<p>说明：读者可以在示例工程中使用<code>git checkout json_template</code>，查看可以运行的示例代码。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/13/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/11/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>赞助商</h1>
  <p>
     <a href="http://zc.pgyer.com" target="_blank"><img width="260px" src="/images/ad_pgyer.png" /></a>
  </p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/17/how-to-read-a-book-summary/">教你阅读图书的「方法论」- 评《如何阅读一本书》</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/12/saul-introdution/">MagicalRecord 作者 Saul Mora 的故事</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/10/atswift-conference-summary/">首届Swift开发者大会见闻</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/03/reactive-cocoa-discussion/">ReactiveCocoa 讨论会</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/02/2015-summary/">2015 年个人总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/24/resume-cheat-story/">培训机构出来的 iOS 学员怎么了？</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/18/from-dev-to-manager/">涅槃重生:我的技术转管理之路</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/26/yykit-auther-interview/">专访 YYKit 作者 Ibireme: 开源大牛是怎样炼成的</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/21/apps-damaged-bug/">Mac 应用出现「已损坏」问题，苹果到底犯了什么傻逼错误？</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/14/charles-introduction/">Charles 从入门到精通(中国5折特惠)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/02/mvc-and-mvvm/">被误解的 MVC 和被神化的 MVVM</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/25/one-on-one-summary/">浅析一对一沟通</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>About Me</h1>
  <p>InfoQ编辑, 《<a href="http://item.jd.com/11598468.html" target="_blank">iOS开发进阶</a>》作者, 在猿题库创业。<br/>
      <br/>Java开发工程师，曾开发网易邮箱、微博。
      <br/>iOS开发工程师，曾开发有道云笔记、猿题库、小猿搜题。
  </p>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  &copy; 2016 - 唐巧 -
  <span class="credit">基于 <a href="http://octopress.org" target="_blank">Octopress</a></span>
  <span class="credit">, 感谢 <a href="http://gitcafe.com/signup?invited_by=tangqiaoboy" target="_blank">GitCafe</a> 为本站提供存储空间</span>
</p>

</footer>
  









<script src=" http://tjs.sjs.sinajs.cn/open/api/js/wb.js?appkey=2351546126" type="text/javascript" charset="utf-8"></script>
<script>
WB2.anyWhere(function(W){
W.widget.followButton({
    uid: 1708947107,
    id: "wb_follow_btn"
    });
});
</script>


</body>
</html>
